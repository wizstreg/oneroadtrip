<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<script>
// D√©finir la langue du document dynamiquement
(function(){
  const SUP = ['fr','en','it','es','pt','ar'];
  let lang = new URLSearchParams(location.search).get('lang')
           || localStorage.getItem('lang')
           || (navigator.languages && navigator.languages[0]) || navigator.language || 'fr';
  lang = (lang||'fr').slice(0,2).toLowerCase();
  if(!SUP.includes(lang)) lang='fr';
  document.documentElement.lang = lang;
  document.documentElement.dir = (lang==='ar') ? 'rtl' : 'ltr';
  localStorage.setItem('lang', lang);
})();
</script>
<meta name="viewport" content="width=device-width,initial-scale=1">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JK3QGQGDDL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JK3QGQGDDL');
</script>
<!-- Mobile redirect (skip in iframes/artifacts) -->
<script>
(function(){
  // Skip in iframes (artifacts, embeds)
  if (window.self !== window.top) return;
  // Skip if forced desktop mode
  if (/mobile=0/.test(location.search)) return;
  // Detect mobile via user-agent (plus fiable que innerWidth au chargement)
  var isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  if (!isMobile) return;
  
  var alertKey = 'ort_mobile_alert_shown';
  
  // Already shown this session? Redirect immediately
  if (sessionStorage.getItem(alertKey)) {
    var newUrl = location.href.replace(/roadtrip_detail(_simple)?(\.html)?/, 'roadtrip_mobile.html');
    if (newUrl === location.href) newUrl = location.href.replace(/\/([^\/]*)$/, '/roadtrip_mobile.html$1');
    location.replace(newUrl);
    return;
  }
  
  // Wait for DOM to show alert
  document.addEventListener('DOMContentLoaded', function() {
    sessionStorage.setItem(alertKey, '1');
    var overlay = document.createElement('div');
    overlay.id = 'ortMobileOverlay';
    overlay.style.cssText = 'position:fixed;inset:0;background:rgba(17,63,122,0.95);z-index:99999;display:flex;align-items:center;justify-content:center;padding:20px;';
    overlay.innerHTML = '<div style="background:#fff;border-radius:16px;padding:24px;max-width:320px;text-align:center;color:#113f7a;">' +
      '<div style="font-size:40px;margin-bottom:12px;">üì±</div>' +
      '<div style="font-size:18px;font-weight:700;margin-bottom:8px;">Version mobile</div>' +
      '<div style="font-size:14px;color:#64748b;margin-bottom:20px;">Redirection vers la version optimis√©e...</div>' +
      '<button id="ortMobileGo" style="background:#113f7a;color:#fff;border:none;padding:14px 28px;border-radius:10px;font-size:16px;font-weight:600;cursor:pointer;width:100%;">Continuer</button>' +
      '</div>';
    document.body.appendChild(overlay);
    
    var redirect = function() {
      var newUrl = location.href.replace(/roadtrip_detail(_simple)?(\.html)?/, 'roadtrip_mobile.html');
      if (newUrl === location.href) newUrl = location.href.replace(/\/([^\/]*)$/, '/roadtrip_mobile.html$1');
      location.replace(newUrl);
    };
    document.getElementById('ortMobileGo').onclick = redirect;
    setTimeout(redirect, 2500);
  });
})();
</script>
<title>OneRoadTrip - D√©tails du roadtrip</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css">
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css">
<style>
:root{--bg:#113f7a;--card:#fff;--ink:#113f7a;--bd:#c3d6b6;--mut:#6b7a99;--danger:#c62828;--ok:#1b5e20}
*{box-sizing:border-box}
html,body{height:100%;overflow-x:hidden}
body{margin:0;background:url("/assets/image_index.webp") center/cover fixed #113f7a;color:#e7f6fb;font-family:system-ui,sans-serif}
.wrap{max-width:1400px;margin:0 auto;padding:16px}
.card{background:var(--card);color:var(--ink);border-radius:14px;border:1px solid rgba(0,0,0,.08);padding:14px}
.small{font-size:.9rem;color:#1a3a7f}

/* header principal d√©fini plus bas dans le CSS minifi√© */
.brandlink{display:flex;align-items:center;gap:10px;color:#fff;text-decoration:none}
.brandlink img{width:40px;height:40px}
header .brand{font-weight:800}
header .sp{flex:1}
.hdr-btn{padding:8px 10px;border-radius:10px;border:1px solid #113f7a;background:#fff;color:#113f7a;cursor:pointer;font-weight:600}
.toolbar-band{display:flex;flex-wrap:wrap;justify-content:center;align-items:center;gap:10px;padding:10px 16px;background:linear-gradient(135deg,#e8f4f8 0%,#f0f7ff 100%);border-bottom:1px solid #c3d6b6;box-shadow:0 2px 8px rgba(17,63,122,0.1)}

.topband{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin-bottom:12px}
.pill{background:#ffffff1a;color:#fff;border:1px solid #ffffff55;border-radius:999px;padding:6px 14px;font-weight:700;cursor:default}
.pill.clickable{cursor:pointer}
.pill.clickable:hover{background:#ffffff2b}
.pill.title{font-size:1.1rem;background:#fff;color:#113f7a;border:1px solid #113f7a}
.counter{font-weight:800}
.counter.ok{color:#22c55e}
.counter.bad{color:#f87171}

.main{display:grid;grid-template-columns:1fr 1fr;gap:14px;align-items:start}
@media (max-width:1100px){.main{grid-template-columns:1fr}}


#map{
  width:100%;
  max-width:100%;
  height:calc(100vh - 200px);
  min-height:500px;
  max-height:900px;
  border-radius:10px;
  position:relative;
  border:0;
}

/* Popup Leaflet : largeur fixe et vignettes carr√©es (pas √©tir√©es) */
.leaflet-popup-content-wrapper{max-width:none}
.leaflet-popup-content{width:360px !important; margin:0}
.leaflet-popup{width:auto !important}

/* Grille d‚Äôimages dans le popup (couvre la plupart des cas) */
.leaflet-popup-content .grid,
.leaflet-popup-content .photos,
.leaflet-popup-content .thumbs{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}

/* Images non d√©form√©es, carr√©es */
.leaflet-popup-content img{
  width:100%;
  height:auto;
  display:block;
  border-radius:8px;
  object-fit:cover;
}

.leaflet-popup-content .grid img,
.leaflet-popup-content .photos img,
.leaflet-popup-content .thumbs img{
  aspect-ratio:1/1;        /* carr√© */
  object-fit:cover;        /* pas d‚Äô√©tirement */
}
/* Tooltip hover des "Autres lieux" */
.leaflet-tooltip.ort-hover{
  background:#fff; color:#0b3b6f; border:1px solid #cfd6e4;
  border-radius:8px; box-shadow:0 6px 14px rgba(0,0,0,.15);
  padding:8px; max-width:280px; z-index:12005;
}
.leaflet-tooltip.ort-hover img{ width:100%; height:auto; border-radius:6px; margin-top:6px; object-fit:cover }




.step-row{
  display: grid;
  /* 7 colonnes : #, Ville, Distance, Nuits, Dates, H√¥tel, X */
  grid-template-columns:
    100px                         /* # √©tape + ≈ìil + drag */
    minmax(150px, 2fr)            /* nom lieu */
    minmax(90px, auto)            /* distance */
    minmax(55px, auto)            /* nuits */
    minmax(85px, auto)            /* dates (2 lignes) */
    minmax(110px, 1fr)            /* h√¥tel */
    40px;                         /* bouton ‚úï */
  column-gap: 10px;
  align-items: center;
  background:#fff;
  border:1px solid #e5e7eb;
  border-radius:10px;
  padding:10px;
  margin-bottom:10px;
  transition: all .2s;
}
.step-row .cell:last-child{ justify-self:end } /* ‚úï √† droite */
.step-row:hover{ background:#f8fafc; box-shadow:0 2px 8px rgba(0,0,0,.08) }

/* Pour √©viter les d√©bords sur la 2e colonne (nom) */
.step-row .cell:nth-child(2){ min-width:0; overflow:hidden }
.step-row .cell:nth-child(2) a,
.step-row .cell:nth-child(2) .title,
.step-row .cell:nth-child(2) .name{
  display:inline-block; max-width:100%;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}

.step-row.highlight{background:#fef2f2;border-color:#fca5a5}

/* === MOBILE : Design carte simplifi√©e === */
@media (max-width: 700px){
  .step-row{
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 6px 12px;
    padding: 10px 12px;
  }
  
  /* Num√©ro √©tape */
  .step-row .cell:nth-child(1) {
    flex: 0 0 auto;
    font-size: 0.9rem;
  }
  
  /* Nom ville - prend le reste de la ligne */
  .step-row .cell:nth-child(2) {
    flex: 1 1 auto;
    min-width: 0;
    font-size: 0.95rem;
  }
  
  /* Distance */
  .step-row .cell:nth-child(3) {
    flex: 0 0 auto;
    font-size: 0.8rem;
    color: #64748b;
  }
  
  /* Nuits */
  .step-row .cell:nth-child(4) {
    flex: 0 0 auto;
    font-size: 0.85rem;
  }
  
  /* CACHER : Dates et bouton supprimer */
  .step-row .cell.dates-cell,
  .step-row .cell:last-child {
    display: none !important;
  }
  
  /* H√¥tel - bouton compact */
  .step-row .cell.hotel-cell {
    flex: 0 0 auto;
  }
  .step-row .cell.hotel-cell .btn {
    padding: 6px 10px !important;
    font-size: 0.75rem !important;
  }
  .step-row .cell.hotel-cell > div:last-child {
    display: none; /* cacher "X nuits" sous le bouton */
  }
}

/* Mobile tr√®s petit */
@media (max-width: 480px){
  .step-row {
    padding: 8px 10px;
    gap: 4px 8px;
  }
  .step-row .cell:nth-child(2) { font-size: 0.85rem; }
  .step-row .stars { font-size: 0.65rem !important; letter-spacing: -1px; }
  .step-row .group-label { display: none !important; }
  .step-row .link-icon { display: none !important; }
}

.step-row[draggable="true"]{cursor:grab}
.step-row.dragging{opacity:.6;border-style:dashed}
.cell{padding:4px}

/* Animation loading pour recherche h√¥tel */
.loading-dots::after {
  content: '';
  animation: loadingDots 1.5s infinite;
}
@keyframes loadingDots {
  0% { content: ''; }
  25% { content: '.'; }
  50% { content: '..'; }
  75% { content: '...'; }
  100% { content: ''; }
}

.step-num{
  display:inline-flex;align-items:center;justify-content:center;
  width:28px;height:28px;border-radius:50%;
  background:#113f7a;color:#fff;font-weight:800;font-size:14px;
  border:2px solid #fff;box-shadow:0 1px 3px rgba(0,0,0,.25);
  flex-shrink:0;
}
.eye-btn{
  font-size:16px;
}
.eye-btn:hover{background:#e2e8f0}

.cell .mut{color:var(--mut);font-size:.85rem}
.input{width:100%;padding:8px;border:1px solid #cbd5e1;border-radius:8px}
.btn{padding:8px 12px;border-radius:10px;border:1px solid #ffffff80;background:#113f7a;color:#fff;cursor:pointer;font-size:14px}
.btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.btn.active{background:#22c55e;border-color:#22c55e}
.btn.danger{background:#fee2e2;color:#dc2626;border:1px solid #fca5a5}
.iconbtn{background:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:6px;cursor:pointer;width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center}

/* Fl√®che ‚Äúd√©tail √©tape‚Äù + popover */
.go-btn{font-weight:700}
.go-pop{
  position:fixed; z-index:12000; background:#fff; color:#113f7a;
  border:1px solid #cfd6e4; border-radius:10px; box-shadow:0 10px 28px rgba(0,0,0,.18);
  padding:10px 12px; width:280px; max-width:90vw;
}
.go-pop .row{display:flex;gap:8px;justify-content:flex-end;margin-top:8px}
.go-pop .btn{background:#113f7a;border-color:#113f7a;color:#fff}
.go-pop .btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.sidebar{position:sticky;top:92px}


#map.pointer-mode{cursor:crosshair!important}
#map.pointer-mode .leaflet-container{cursor:crosshair!important}
.leaflet-container{border-radius:10px}
.leaflet-marker-icon{transition:all .2s!important}
.leaflet-marker-icon.marker-highlight{transform:scale(1.4)!important;filter:drop-shadow(0 0 12px #ef4444)!important;z-index:10000!important}
/* [F.1] le zoom part du centre (√©vite que le num√©ro ‚Äús‚Äôenvole‚Äù) */
.leaflet-marker-icon{transform-origin:center center!important}
.custom-marker{background:transparent!important;border:none!important}

/* Markers de pr√©visualisation (verts) */
.preview-marker {
  background: #22c55e !important;
  border-color: #16a34a !important;
}

.preview-marker .marker-num {
  background: #22c55e;
  border-color: #16a34a;
}
/* === SURVOL LIGNE / POPUP === */
.leaflet-marker-icon.marker-hover{
  transform:scale(1.4)!important;
  filter:drop-shadow(0 0 10px #ef4444)!important;
  color:#ef4444!important;
  z-index:9999!important;
}

/* Pop-up unique en position:fixed avec z-index haut */
.map-popup{
  position:fixed; top:0; right:0;
  width:420px; 
  max-width: 90vw; /* s'adapte sur petits √©crans */
  height:100vh;
  background:#fff; border-left:4px solid #113f7a; border-radius:0;
  box-shadow:-4px 0 20px rgba(0,0,0,.25); 
  overflow-y:auto; /* important: pas de scroll sur le parent */
  z-index:12000; display:none;
  transition: left 0.2s ease, right 0.2s ease;
}
.map-popup.show{display:block;}

/* En mode plein √©cran carte : le popup passe √† gauche */
body.view-map-only .map-popup{
  left:0; right:auto;
  border-left:0; border-right:4px solid #113f7a;
  box-shadow:4px 0 20px rgba(0,0,0,.25);
}

/* Bouton ‚úï collant en haut du flux scrollable */
.popup-close{

  position: sticky;
  top: 0;
  margin-left: auto;           /* pousse √† droite dans .popup-content */
  display: flex; align-items: center; justify-content: center;
  width: 28px; height: 28px;
  background:#fff;
  border:1px solid #e5e7eb; border-radius:6px;
  cursor:pointer; z-index:10;
  /* lisibilit√© quand on scrolle sous des photos */
  box-shadow: 0 2px 6px rgba(0,0,0,.08);
}

/* Le contenu reste scrollable, le ‚úï reste visible en haut */
  .popup-content{
  position: relative;
  padding: 12px 12px 80px 12px; /* plus d'espace en bas pour le bouton */
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  height: calc(100vh - 44px); /* hauteur fixe moins le bouton close */
  -webkit-overflow-scrolling: touch; /* scroll fluide sur iOS */
}

/* FIX: garantir un flux s√©par√© et √©viter tout chevauchement */
#descVisits, #descActivities{
  display: flow-root; /* nouveau contexte de formatage, √©vite le recouvrement */
  clear: both;
  margin: 8px 0;
}

/* Carrousel photos popup */
.popup-photos{
  position:relative;
  width:100%;
  margin-bottom:10px;
}
.popup-photos .carousel-container{
  position:relative;
  width:100%;
  overflow:hidden;
  border-radius:8px;
}
.popup-photos .carousel-img{
  width:100%;
  aspect-ratio:4/3;
  object-fit:cover;
  display:block;
  border-radius:8px;
  border:1px solid #e5e7eb;
}
.popup-photos .carousel-nav{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  background:rgba(17,63,122,0.7);
  color:#fff;
  border:none;
  width:36px;
  height:36px;
  border-radius:50%;
  cursor:pointer;
  font-size:18px;
  display:flex;
  align-items:center;
  justify-content:center;
  transition:background 0.2s;
  z-index:10;
}
.popup-photos .carousel-nav:hover{background:rgba(17,63,122,0.9)}
.popup-photos .carousel-nav.prev{left:8px}
.popup-photos .carousel-nav.next{right:8px}
.popup-photos .carousel-nav:disabled{opacity:0.3;cursor:default}
.popup-photos .carousel-dots{
  display:flex;
  justify-content:center;
  gap:6px;
  margin-top:8px;
}
.popup-photos .carousel-dot{
  width:8px;
  height:8px;
  border-radius:50%;
  background:#cbd5e1;
  border:none;
  cursor:pointer;
  transition:background 0.2s;
}
.popup-photos .carousel-dot.active{background:#113f7a}

.popup-title{font-weight:700;font-size:1.05rem;margin-bottom:8px;color:#113f7a}
.popup-desc{font-size:.85rem;color:#475569;line-height:1.4;position:relative;z-index:1}
.popup-desc p{margin:8px 0}

footer{text-align:center;margin:18px 0 28px;font-size:14px;opacity:.9}

/* Boutons dans la fiche lat√©rale : forc√©s en plein (bleu ORT sur fond blanc) */
.map-popup .btn{
  background:#113f7a !important;
  color:#fff !important;
  border:1px solid #113f7a !important;
  width: 100%; /* bouton pleine largeur */
  padding: 12px !important; /* plus facile √† cliquer sur tablette */
  font-size: 15px !important;
   font-weight: 600 !important;
}

/* Conteneur d‚Äôactions sp√©cifique, plus ‚Äúdernier enfant‚Äù g√©n√©rique */
.map-popup .popup-actions{
  position: sticky;
  bottom: 0;
  background: #fff;
  padding: 12px 0;
  margin: 0 -12px -80px -12px; /* compense le padding du parent */
  padding-left: 12px;
  padding-right: 12px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.08);
  z-index: 10;
}
.map-popup .btn.ghost{
  background:#fff !important;
  color:#113f7a !important;

  border:1px solid #113f7a !important;
}


/* === FICHE PAYS ‚Äî bouton lat√©ral + tiroir === */
/* Ic√¥ne üåà en pilule blanche, toujours visible */
#countryTab{
  display:none !important;
  align-items:center; justify-content:center;
  width:32px; height:32px;
  margin-left:8px;
  background:#fff; color:#113f7a;
  border:1px solid #cfd6e4; border-radius:999px;
  font-size:18px; line-height:1; padding:0;
  cursor:pointer; box-shadow:0 2px 6px rgba(0,0,0,.12);
}
#countryTab:hover{ background:#f6f8fb; transform:scale(1.03); }


#countryDrawer{
  position:fixed; top:0; right:0; height:100vh; width:min(520px,88vw);
  background:#fff; color:#113f7a; z-index:12600; display:none;
  border-left:4px solid #113f7a; box-shadow:-6px 0 24px rgba(0,0,0,.22);
}
#countryDrawer.show{ display:block }
#countryDrawer .cd-head{
  position:sticky; top:0; background:#f8fbfc; padding:12px 14px;
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  border-bottom:1px solid #e5e7eb; z-index:1;
}
#countryDrawer .cd-title{ font-weight:900; font-size:1.05rem }
#countryDrawer .cd-close{
  background:#fff; border:1px solid #cfd6e4; border-radius:8px;
  width:32px; height:32px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer;
}
#countryDrawer .cd-body{ padding:14px; overflow-y:auto; height:calc(100% - 56px) }
#countryDrawer .tabs{ display:flex; flex-wrap:wrap; gap:8px; padding:6px 0 12px }
#countryDrawer .tab{ background:#f1f5f9; border:1px solid #e2e8f0; padding:6px 10px; border-radius:999px; cursor:pointer; font-weight:700; color:#113f7a }
#countryDrawer .tab.active{ background:#c3d6b6; border-color:#c3d6b6 }
#countryDrawer .pane{ display:none; white-space:pre-wrap; line-height:1.45 }
#countryDrawer .pane.active{ display:block }


footer a{color:#c3d6b6;text-decoration:none}

.step-marker {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  font-size: 13px;
  font-weight: bold;
  text-align: center;
  line-height: 24px;
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
/* [P.2] teinte rouge au survol ligne (sans changer le transform) */
.step-marker.marker-red{ background:#ef4444; border-color:#fecaca; }


/* [J.1] Grossissement sur le chiffre interne (√©vite le ‚Äúsaut‚Äù) */
.step-marker .marker-num { transition: transform .15s ease; position: relative; }
.step-marker .marker-num.num-boost { transform: scale(1.35); transform-origin: center; }

/* Drapeau pour les hubs (√©tapes avec nuits) */
.step-marker .hub-flag {
  position: absolute;
  top: -10px;
  right: -8px;
  font-size: 12px;
  filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
  animation: flag-wave 2s ease-in-out infinite;
}
@keyframes flag-wave {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}

/* === OVERRIDES LAYOUT ‚Äî prend le dessus sur #map par !important === */


/* Carte r√©duite en mode empil√© */
  height:calc(50vh - 80px) !important;
  min-height:280px !important;
  max-height:400px !important;
}


/* C√¥te-√†-c√¥te : laisser de la place au popup √† droite */
#map{
  width:calc(100% - 24px) !important;   /* carte un peu plus √©troite */
  margin-right:12px !important;
}

/* Popup custom : largeur fixe et position selon layout */
#map .map-popup{width:380px;max-width:380px}

/* En c√¥te-√†-c√¥te : d√©porter le popup √† droite DEHORS de la carte */
#map .map-popup{
  right:10px; left:auto;
  top:4px;                            /* plus haut */
}

/* En empil√© : le popup reste au-dessus de la carte, centr√© visuellement */
  left:auto; right:10px;                /* redevient interne √† la carte */
}


/* === Map / Itin full view toggles === */
.main{position:relative}
/* garder la carte sticky en scroll */
.sidebar{position:sticky; top:92px}

/* Overlays de la carte (en haut √† droite) */
#mapActions{
  position:absolute; top:140px; right:8px; z-index:1000;
  display:flex; gap:6px;
}

@media (max-width:580px){
  #mapActions{
    top: 80px;
    right: 8px;
  }
  #mapActions .tool{
    width: 44px;
    height: 44px;
    font-size: 22px;
  }
}

/* >>> Assure que les contr√¥les Leaflet passent DEVANT #mapActions */
.leaflet-control-container{ z-index: 1201 !important; }

/* Optionnel : l√©ger d√©calage √† droite pour laisser respirer le layers-control */
.leaflet-top.leaflet-right{ right: 46px !important; }

/* Style g√©n√©rique pour tous les petits boutons carr√©s */
.ctl{
  width:32px; height:32px; border-radius:8px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#fff; color:#0b3b6f; border:1px solid #cfd6e4;
  box-shadow:0 2px 6px rgba(0,0,0,.12); cursor:pointer;
  padding:0;           /* assure le carr√© strict */
}
.ctl:hover{ background:#f6f8fb }

/* Style historique conserv√© pour les overlays de carte */
#mapActions .tool{
  width:40px; height:40px; border-radius:8px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#fff; color:#0b3b6f; border:2px solid #cfd6e4;
  box-shadow:0 2px 6px rgba(0,0,0,.12); cursor:pointer;
  font-size:20px; font-weight:bold;
}
#mapActions .tool:hover{background:#f6f8fb}
#mapActions #btnMapFull, #mapActions #btnMapExit {
  background:#dc3545; color:#fff; border-color:#dc3545;
}
#mapActions #btnMapFull:hover, #mapActions #btnMapExit:hover {
  background:#c82333; border-color:#bd2130;
}

/* Plein √©cran carte */
body.view-map-only {
  overflow: hidden; /* Emp√™che le scroll du body */
}
body.view-map-only .main{display:block}
body.view-map-only .main>section{display:none !important}
body.view-map-only .main>aside{
  width:100% !important;
  position: fixed;
  top: 92px;
  left: 0;
  right: 0;
  height: calc(100vh - 92px);
  padding-top: 0;
  z-index: 1;
}

body.view-map-only #map{
  height: 100% !important;
  min-height: 520px !important;
  width: 100% !important;
  position: relative;
}

/* D√©calage des contr√¥les Leaflet en plein √©cran pour √©viter le header */
body.view-map-only .leaflet-top {
  top: 110px !important;
}


/* Plein √©cran itin√©raire */
body.view-itin-only {
  overflow: hidden;
}
body.view-itin-only header {
  display: none !important;
}
body.view-itin-only .main{display:block}
body.view-itin-only .main>aside{display:none !important}
body.view-itin-only .main>section{
  width:100% !important;
  max-width: 100% !important;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  height: 100vh;
  overflow-y: auto;
  padding: 48px 10px 10px 10px;
  z-index: 9999;
  background: var(--bg);
  border-radius: 0;
  box-shadow: none;
}
body.view-itin-only .main>section>.small,
body.view-itin-only .main>section>div:first-child {
  display: none !important;
}
body.view-itin-only .main>section>div:last-child {
  display: none !important; /* Cacher boutons sauvegarder en bas */
}
body.view-itin-only #rows{
  max-width: 100%;
  margin: 0;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 3px 8px;
}
/* Lignes ultra-compactes en plein √©cran */
body.view-itin-only .step-row {
  padding: 3px 6px !important;
  margin-bottom: 3px !important;
  border-radius: 4px !important;
  min-height: auto !important;
  font-size: 0.8rem !important;
  column-gap: 6px !important;
  grid-template-columns:
    32px                          /* # √©tape */
    minmax(120px, 1.5fr)          /* nom lieu */
    70px                          /* distance */
    50px                          /* nuits */
    75px                          /* dates */
    minmax(90px, 1fr)             /* h√¥tel */
    24px !important;              /* bouton ‚úï */
}
body.view-itin-only .step-row .cell {
  padding: 1px 2px !important;
}
body.view-itin-only .step-row .drag-handle {
  padding: 1px 3px !important;
  font-size: 0.85rem !important;
}
body.view-itin-only .step-row .stars {
  font-size: 0.65rem !important;
}
body.view-itin-only .step-row .visit-time {
  font-size: 0.7rem !important;
}
/* Cacher les √©l√©ments non essentiels */
body.view-itin-only .step-row .link-icon,
body.view-itin-only .step-row [data-i18n-title="step.link"] {
  display: none !important;
}
/* R√©duire la taille des badges h√¥tel */
body.view-itin-only .hotel-card {
  padding: 3px 5px !important;
  font-size: 0.65rem !important;
  line-height: 1.15 !important;
  border-radius: 4px !important;
}
body.view-itin-only .hotel-card img {
  display: none !important;
}
body.view-itin-only .hotel-card .hotel-name {
  max-width: 80px !important;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* Cacher bouton "Proposer autre h√¥tel" en mode compact */
body.view-itin-only .hotel-card + button,
body.view-itin-only [data-change-hotel] {
  display: none !important;
}
/* R√©duire padding dans la carte h√¥tel */
body.view-itin-only .hotel-card > div {
  margin-bottom: 1px !important;
  line-height: 1.1 !important;
}
/* Nom h√¥tel compact */
body.view-itin-only .hotel-card > div:first-child,
body.view-itin-only .hotel-card > div[style*="font-weight:700"] {
  font-size: 0.65rem !important;
  margin-bottom: 1px !important;
}
/* √âtoiles et rating */
body.view-itin-only .hotel-card > div:nth-child(2) {
  margin-bottom: 1px !important;
}
body.view-itin-only .hotel-card span[style*="fbbf24"] {
  font-size: 0.55rem !important;
}
body.view-itin-only .hotel-card span[style*="065f46"] {
  font-size: 0.55rem !important;
  padding: 0 2px !important;
}
/* Prix */
body.view-itin-only .hotel-card > div[style*="059669"] {
  font-size: 0.7rem !important;
}
/* Total nuits */
body.view-itin-only .hotel-card > div:last-child {
  font-size: 0.55rem !important;
  display: none !important;
}
/* Bouton supprimer plus petit */
body.view-itin-only .step-row .del-btn {
  width: 18px !important;
  height: 18px !important;
  font-size: 10px !important;
  padding: 0 !important;
}
/* Input nuits plus compact */
body.view-itin-only .step-row input[type="number"] {
  width: 32px !important;
  height: 22px !important;
  font-size: 0.75rem !important;
  padding: 1px !important;
}
/* Dates plus compactes */
body.view-itin-only .step-row .dates-cell {
  font-size: 0.7rem !important;
  line-height: 1.1 !important;
}
/* Label groupe compact */
body.view-itin-only .step-row .group-label {
  font-size: 0.6rem !important;
  padding: 1px 4px !important;
}
/* Bouton r√©duire visible en haut √† droite */
body.view-itin-only #btnListExit {
  position: fixed;
  top: 5px;
  right: 12px;
  z-index: 10002;
  background: rgba(255,255,255,0.95);
  color: #113f7a;
  border: none;
  padding: 6px 14px;
  font-size: 13px;
  font-weight: 600;
  border-radius: 5px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  display: flex !important;
  align-items: center;
  gap: 5px;
}
body.view-itin-only #btnListExit:hover {
  background: #fff;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
/* Responsive: 1 colonne sur petits √©crans */
@media (max-width: 1100px) {
  body.view-itin-only #rows {
    grid-template-columns: 1fr;
  }
}

/* Ic√¥nes SVG (taille unifi√©e) */
.btn-ico{width:18px;height:18px;vertical-align:-2px}

/* Ic√¥ne r√©organisation en mode plein √©cran (BAS GAUCHE) */

/* Modal d'information r√©organisation */
#reorgInfoModal{
  position:fixed; inset:0; z-index:13000;
  background:rgba(0,0,0,.6); display:none;
  align-items:center; justify-content:center;
  backdrop-filter:blur(4px);
}
#reorgInfoModal.show{ display:flex; }
.reorg-info-box{
  background:#fff; color:#113f7a;
  border:4px solid #113f7a; border-radius:16px;
  padding:24px 28px; max-width:min(560px,90vw);
  box-shadow:0 12px 40px rgba(0,0,0,.3);
  position:relative;
}
.reorg-info-box h2{
  margin:0 0 16px; font-size:1.4rem; font-weight:800;
  color:#113f7a; display:flex; align-items:center; gap:10px;
}
.reorg-info-box p{
  margin:10px 0; line-height:1.6; font-size:1rem;
}
.reorg-info-box strong{
  color:#113f7a; font-weight:700;
}
.reorg-info-box .btn-close-info{
  margin-top:20px; width:100%; padding:12px;
  background:#113f7a; color:#fff; border:2px solid #113f7a;
  border-radius:10px; font-size:1.05rem; font-weight:700;
  cursor:pointer; transition:all .2s;
}
.reorg-info-box .btn-close-info:hover{
  background:#1a4d8f; border-color:#1a4d8f;
}

/* === Panneau lat√©ral de r√©organisation === */
#reorgPanel {
  position: fixed;
  top: 0;
  right: -420px; /* cach√© par d√©faut */
  width: 400px;
  height: 100vh;
  background: #fff;
  color: #113f7a;
  border-left: 4px solid #113f7a;
  box-shadow: -6px 0 24px rgba(0,0,0,.22);
  z-index: 13500;
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
}

#reorgPanel.show {
  right: 0;
}

/* Header du panneau */
.reorg-panel-header {
  background: #113f7a;
  color: #fff;
  padding: 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.reorg-panel-header h3 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 800;
}

.reorg-panel-close {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: all 0.2s;
}

.reorg-panel-close:hover {
  background: rgba(255,255,255,0.3);
  transform: scale(1.05);
}

/* Corps du panneau (liste des √©tapes) */
.reorg-panel-body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 16px 16px 100px 16px; /* beaucoup plus d'espace en bas */
  -webkit-overflow-scrolling: touch; /* scroll fluide iOS */
}

/* Item d'√©tape */
.reorg-step-item {
  background: #f8f9fa;
  border: 2px solid #e5e7eb;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  display: flex;
  align-items: center;
  gap: 12px;
}

.reorg-step-item:hover {
  border-color: #113f7a;
  transform: translateX(-4px);
}

/* √âtape modifi√©e (position chang√©e) */
.reorg-step-item.selected {
  background: #fee;
  border-color: #ef4444;
}

/* √âtape supprim√©e */
.reorg-step-item.deleted {
  background: #fecaca;
  border-color: #ef4444;
  opacity: 0.7;
  text-decoration: line-through;
}

/* Num√©ro d'ordre */
.reorg-step-num {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #113f7a;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 14px;
  flex-shrink: 0;
}

.reorg-step-item.selected .reorg-step-num {
  background: #ef4444;
}

.reorg-step-item.deleted .reorg-step-num {
  background: #ef4444;
}

/* Info de l'√©tape */
.reorg-step-info {
  flex: 1;
  min-width: 0;
}

.reorg-step-name {
  font-weight: 700;
  font-size: 1rem;
  color: #113f7a;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.reorg-step-meta {
  font-size: 0.85rem;
  color: #64748b;
  margin-top: 4px;
}

/* Badge √©tat (supprim√©/modifi√©) */
.reorg-step-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  background: #ef4444;
  color: #fff;
  font-size: 11px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 12px;
}

.reorg-step-item.deleted .reorg-step-badge {
  background: #ef4444;
}

/* Ic√¥nes flottants sous les instructions */
.reorg-float-tools{
  position: relative;
  display: flex;
  gap: 12px;
  margin-top: 12px;
  overflow: visible;           /* √©vite le rognage du tooltip */
}
.reorg-fab{
  position: relative;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 2px solid #113f7a;
  background: #fff;
  color: #113f7a;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 3px 10px rgba(0,0,0,.12);
}
.reorg-fab:hover{ transform: translateY(-1px); }
.reorg-fab:active{ transform: translateY(0); }

/* Tooltip I18N (toujours DANS le panneau) */
.reorg-tip{
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translate(-50%, -2px);
  z-index: 5;
  background: #0b3b6f;
  color: #fff;
  font-size: 12px;
  line-height: 1.35;
  padding: 8px 10px;
  border-radius: 8px;
  white-space: normal;
  width: 260px;                /* largeur fixe lisible */
  max-width: calc(100vw - 80px);
  box-shadow: 0 6px 18px rgba(0,0,0,.18);
  opacity: 0;
  pointer-events: none;
  transition: opacity .15s ease, transform .15s ease;
}
.reorg-fab:hover .reorg-tip{ opacity: 1; }

/* r√©alignements anti-d√©coupage */
.reorg-tip.align-left{  left: 0;   transform: translateY(-2px); }
.reorg-tip.align-right{ right: 0;  left: auto; transform: translateY(-2px); }

/* Bouton Pr√©visualiser - rouge centr√© en haut de la carte */
.reorg-save-btn {
  position: fixed;
  top: 140px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  background: #c62828;
  color: #fff;
  border: 2px solid #a21919;
  border-radius: 10px;
  padding: 12px 28px;
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: none;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: 0 4px 16px rgba(198, 40, 40, 0.3);
}

/* Visible uniquement quand le panneau de r√©organisation est ouvert */
.reorg-panel.show .reorg-save-btn,
body.reorg-active .reorg-save-btn {
  display: flex;
}

.reorg-save-btn:hover {
  background: #d32f2f;
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 20px rgba(198, 40, 40, 0.5);
}

.reorg-save-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: translateX(-50%);
}


/* Instructions en haut du panneau */
.reorg-instructions {
  background: #e3f2fd;
  border: 2px solid #2196F3;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 16px;
  font-size: 0.9rem;
  line-height: 1.5;
  color: #0b3b6f;
}

.reorg-instructions strong {
  color: #113f7a;
}

/* Overlay pendant la r√©organisation */
body.reorg-active #reorgPanel {
  right: 0;
}

body.reorg-active #map {
  pointer-events: all;
}

/* Marqueur en mode r√©organisation */
body.reorg-active .leaflet-marker-icon {
  cursor: pointer !important;
  transition: transform 0.2s, filter 0.2s;
}

body.reorg-active .leaflet-marker-icon:hover {
  transform: scale(1.15);
}

/* Marqueur s√©lectionn√© (bleu) */
.leaflet-marker-icon.reorg-selected {
  filter: hue-rotate(200deg) brightness(1.2);
}

/* Marqueur supprim√© (rouge gris√©) */
.leaflet-marker-icon.reorg-deleted {
  filter: grayscale(80%) brightness(0.8);
  opacity: 0.5;
}

/* Animations pour effet miroir liste ‚Üí carte */
@keyframes marker-pulse-red {
  0% { filter: drop-shadow(0 0 0px transparent); }
  50% { filter: drop-shadow(0 0 16px #ef4444); }
  100% { filter: drop-shadow(0 0 0px transparent); }
}

@keyframes marker-pulse-green {
  0% { filter: drop-shadow(0 0 0px transparent); }
  50% { filter: drop-shadow(0 0 16px #22c55e); }
  100% { filter: drop-shadow(0 0 0px transparent); }
}

@keyframes marker-pulse-gray {
  0% { filter: grayscale(0%); }
  50% { filter: grayscale(100%); }
  100% { filter: grayscale(0%); }
}

.leaflet-marker-icon.marker-animate-red {
  animation: marker-pulse-red 0.6s ease;
}

.leaflet-marker-icon.marker-animate-green {
  animation: marker-pulse-green 0.6s ease;
}

.leaflet-marker-icon.marker-animate-gray {
  animation: marker-pulse-gray 0.6s ease;
}

/* Modal de pr√©visualisation de r√©organisation */
#reorgPreviewModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  background: transparent;
  display: none;
  align-items: center;
  justify-content: flex-start;
  z-index: 11000;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
}

#reorgPreviewModal.show {
  opacity: 1;
  pointer-events: none;
}

.reorg-preview-box {
  background: #fff;
  border-radius: 0 14px 14px 0;
  padding: 16px 16px 120px 16px; /* plus d'espace en bas pour les boutons */
  width: 320px;
  max-width: 90vw; /* s'adapte aux petits √©crans */
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.25);
  margin-left: 0;
  pointer-events: auto;
  -webkit-overflow-scrolling: touch; /* scroll fluide iOS */
  display: flex;
  flex-direction: column;
}

.reorg-preview-box h2 {
  margin: 0 0 16px 0;
  font-size: 1.3rem;
  color: #113f7a;
}

.preview-step-item {
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.preview-step-num {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  flex-shrink: 0;
}

.preview-step-content {
  flex: 1;
}

.preview-step-name {
  font-weight: 600;
  color: #113f7a;
  margin-bottom: 4px;
}

.preview-step-nights {
  font-size: 0.85rem;
  color: #64748b;
}

/* Conteneur des boutons de pr√©visualisation - sticky en bas */
.reorg-preview-box > div:last-child {
  position: sticky;
  bottom: 0;
  background: #fff;
  padding: 16px 0 0 0;
  margin: 16px -16px -120px -16px; /* compense le padding du parent */
  padding-left: 16px;
  padding-right: 16px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
  z-index: 10;
}

.btn-preview-cancel,
.btn-preview-validate {
  padding: 12px 24px !important;
  font-size: 15px !important;
  font-weight: 600 !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  transition: all 0.2s;
}

.btn-preview-cancel {
  border: 2px solid #94a3b8 !important;
  background: #fff !important;
  color: #475569 !important;
}

.btn-preview-cancel:hover {
  background: #f1f5f9 !important;
  border-color: #64748b !important;
}

.btn-preview-validate {
  border: none !important;
  background: #113f7a !important;
  color: #fff !important;
}

.btn-preview-validate:hover {
  background: #0d3461 !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(17, 63, 122, 0.3);
}

/* Zone de contenu scrollable de la pr√©visualisation */
#reorgPreviewContent {
  flex: 1;
  overflow-y: auto !important;
  overflow-x: hidden;
  max-height: calc(100vh - 200px) !important;
  padding-bottom: 20px;
  -webkit-overflow-scrolling: touch;
}

/* Aide/L√©gende √† c√¥t√© du titre */
.help-anchor{position:relative;display:flex;align-items:center;gap:8px;flex-wrap:wrap}
```css

.reorg-preview-box h2 {
  margin: 0 0 16px 0;
  font-size: 1.3rem;
  color: #113f7a;
}

.preview-step-item {
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.preview-step-num {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  flex-shrink: 0;
}

.preview-step-content {
  flex: 1;
}

.preview-step-name {
  font-weight: 600;
  color: #113f7a;
  margin-bottom: 4px;
}

.preview-step-nights {
  font-size: 0.85rem;
  color: #64748b;
}

.btn-preview-cancel:hover {
  background: #f1f5f9;
}

.btn-preview-validate:hover {
  background: #0d3461;
}


/* Ic√¥nes actions dans la ligne du header (avant la date) */
.rt-inline-icons{
  position:static;            /* plus d'absolu */
  display:inline-flex;
  gap:8px;
  z-index:auto;
  margin-right:8px;           /* petit espace avant la date */
  transform:none;
}
.pill-ico{
  width:32px;height:32px;border-radius:999px;


  display:inline-flex;align-items:center;justify-content:center;
  background:#fff; color:#113f7a;
  border:1px solid #cfd6e4; box-shadow:0 2px 6px rgba(0,0,0,.12);
  cursor:pointer; line-height:1; font-size:18px; padding:0;
}
.pill-ico.danger{ display:none !important; color:#dc2626; border-color:#fecaca; }
.pill-ico.saved{ background:#c3d6b6; color:#0f5132; border-color:#c3d6b6; }

/* Badge moyenne (‚òÖ 8.2/10) */
#rtAvgBadge{
  font:700 12px/1 system-ui; color:#113f7a; background:#fff;
  border:1px solid #cfd6e4; border-radius:10px; padding:4px 8px;
  display:none; align-items:center; gap:4px;
}

/* Popover de notation */
.rate-pop{
  position:absolute; z-index:12000;
  background:#fff; color:#113f7a; border:1px solid #cfd6e4;
  border-radius:12px; box-shadow:0 10px 28px rgba(0,0,0,.18);
  padding:12px; width:min(320px,92vw);
}
.rate-pop .row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
.rate-pop .btn{background:#113f7a;color:#fff;border:1px solid #113f7a}
.rate-pop .btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.rate-pop .mut{color:#64748b;font-size:.9rem}

/* Couleurs de note (texte) */
.note-bad{color:#dc2626}
.note-mid{color:#d97706}
.note-good{color:#16a34a}

/* Pav√© stats compact */
.pill.stats{background:#ffffff; color:#113f7a; border-color:#113f7a}
.pill.stats span{font-weight:700}



/* === Header align√© sur 'presentation.html' === */
header{position:sticky;top:0;z-index:10;background:url("/assets/image_index.webp") center/cover no-repeat #113f7a;color:#fff;padding:12px 16px;display:flex;align-items:center;gap:12px;border-bottom:2px solid rgba(255,255,255,0.2);box-shadow:0 2px 12px rgba(0,0,0,0.2)}
.brandlink{display:flex;align-items:center;gap:10px;color:#fff;text-decoration:none}
.brandlink img{width:80px;height:80px}
.brand{font-weight:800;font-size:20px}
.spacer{flex:1}
.langpick{appearance:none;background:#fff;border:1px solid #113f7a;border-radius:10px;padding:8px 10px;cursor:pointer;color:#113f7a}
.btn{padding:8px 12px;border-radius:10px;border:1px solid #ffffff80;background:#ffffff1a;color:#fff;cursor:pointer}
.btn:hover{background:#ffffff2b}
.btn:disabled{opacity:.6;cursor:not-allowed}
.auth{position:relative}
.auth-pop{position:absolute;right:0;top:44px;background:#fff;color:#113f7a;border:1px solid #c3d6b6;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:8px;display:none;min-width:260px}
.auth-pop .btn{display:block;width:100%;margin:6px 0;background:#113f7a;border:1px solid #113f7a;color:#fff}
.auth-pop .btn.out{background:#fff;color:#113f7a}

/* == Outils dans le header == */
.rt-tools{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-right:8px}
.rt-tools .btn{background:#ffffff1a;border-color:#ffffff80}
.rt-tools .btn.ghost{background:#fff;color:#113f7a;border-color:#113f7a}

/* == Carte sans "tour" (pas de carte encart√©e) == */
.sidebar > .card{background:transparent;border:0;padding:0}
#map{border:0 !important;border-radius:10px}

/* On supprime toute mention d‚Äôaide sous la carte ‚Üí pas besoin de place */
#map + .small{display:none}

/* === Mobile toolbar (‚â§ 580px) === */
@media (max-width:580px){
  header .brandlink img{width:48px;height:48px}
  header .brand{font-size:18px}
  .rt-tools{gap:6px}

  /* on ne garde visibles que + √©tape et + carte ; le reste passe dans "‚ãØ" */

  /* bouton "‚ãØ Plus" visible uniquement sur mobile */
  #toolbarMore{ display:inline-flex }
  /* boutons visibles: */
}

/* === Mobile : Titre et stats plus lisibles === */
@media (max-width: 700px){
  .topband {
    flex-direction: column;
    align-items: stretch;
    gap: 8px;
  }
  
  .pill.title {
    font-size: 0.95rem;
    padding: 10px 14px;
    text-align: center;
    line-height: 1.3;
  }
  
  .pill.stats {
    font-size: 0.8rem;
    padding: 8px 12px;
    text-align: center;
    display: flex;
    justify-content: center;
    gap: 6px;
    flex-wrap: wrap;
  }
  
  /* Cacher le bouton fiche pays sur mobile */
  #countryTab { display: none; }
  
  /* R√©duire "Glissez pour r√©ordonner" */
  .small { font-size: 0.75rem; }
  
  /* Boutons en bas plus compacts */
  #btnSave, #btnExport, #btnResetGroups {
    font-size: 0.8rem;
    padding: 8px 10px;
  }
}

@media (max-width: 480px){
  .pill.title { font-size: 0.85rem; padding: 8px 12px; }
  .pill.stats { font-size: 0.75rem; }
  .pill.stats span { display: inline; }
}

/* Par d√©faut (desktop), on cache "‚ãØ Plus" */

/* Popover du menu mobile */
.more-pop{
  position:absolute; right:16px; top:64px;
  background:#fff; color:#113f7a;
  border:1px solid #c3d6b6; border-radius:12px;
  box-shadow:0 10px 30px rgba(0,0,0,.15);
  padding:8px; min-width:220px; display:none; z-index:12000;
}
.more-pop.show{ display:block }
.more-pop .btn{ display:block; width:100%; margin:6px 0; background:#113f7a; border:1px solid #113f7a; color:#fff }
.more-pop .btn.ghost{ background:#fff; color:#113f7a }

/* Labels de groupe au-dessus des points */
.step-label{
  position:relative;
  transform: translate(-50%, -28px); /* centr√© au-dessus du point */
  background:#fff; color:#113f7a; border:1px solid #cfd6e4;
  border-radius:10px; padding:2px 6px; font-size:12px; font-weight:700;
  box-shadow:0 2px 6px rgba(0,0,0,.12);
  white-space:nowrap; pointer-events:none; /* ne capte pas la souris */
  user-select:none;
}

.step-label.group-label {
  pointer-events: auto; /* Rendre cliquable */
  cursor: pointer;
  transition: all 0.2s ease;
}

.step-label.group-label:hover,
.step-label.group-label.highlighted {
  transform: translate(-50%, -28px) scale(1.5);
  z-index: 1000;
  background: #fef3c7;
  border-color: #f59e0b;
  box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
}

/* Mini marqueurs pour les sous-√©tapes (multi-nuits) */
.mini-step-marker {
  width: 20px;
  height: 20px;
  background: #3b82f6;
  border: 2px solid white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.mini-step-num {
  color: white;
  font-size: 10px;
  font-weight: 700;
  line-height: 1;
}

.mini-step-marker-hover {
  width: 32px !important;
  height: 32px !important;
  transform: scale(1.3);
  background: #2563eb;
  border-color: #fbbf24;
  box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
  z-index: 1000 !important;
}

.mini-step-marker-hover .mini-step-num {
  font-size: 13px;
}

/* Forcer l‚Äôaffichage des boutons de disposition en desktop */
@media (min-width:581px){
}

/* === CLUSTERS PERSONNALIS√âS === */
.marker-cluster {
  background: transparent !important;
}

.marker-cluster div {
  background: rgba(30, 136, 229, 0.85);
  border-radius: 50%;
  font-weight: 600;
  color: #fff;
  font-size: 11px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  border: 2px solid #fff;
}

.marker-cluster-small div {
  width: 28px;
  height: 28px;
  font-size: 10px;
}

.marker-cluster-medium div {
  background: rgba(46, 125, 50, 0.85);
  width: 34px;
  height: 34px;
  font-size: 11px;
}

.marker-cluster-large div {
  background: rgba(255, 152, 0, 0.9);
  width: 40px;
  height: 40px;
  font-size: 12px;
}

/* === √âTOILES (incontournables) === */
.star-marker {
  filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
  transition: transform 0.15s ease;
}

.star-marker:hover {
  transform: scale(1.2);
}

.star-marker.selected {
  filter: drop-shadow(0 2px 4px rgba(225,29,72,0.5));
}

/* === L√âGENDE CARTE === */
.color-legend {
  position: absolute;
  bottom: 20px;
  left: 10px;
  background: rgba(255,255,255,0.95);
  border-radius: 10px;
  padding: 10px 14px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  z-index: 1000;
  font-size: 12px;
  color: #113f7a;
}

.legend-title {
  font-weight: 700;
  margin-bottom: 8px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 6px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 4px 0;
}

.legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  border: 1.5px solid #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.legend-dot.recommended { background: #43A047; }
.legend-dot.discover { background: #7CB342; }
.legend-dot.selected-dot { background: #e11d48; }

.legend-star { display: block; }
</style>

<!-- ‚¨áÔ∏è AJOUTER AVANT </head> -->
<script src="/js/ort-config.js"></script>
<script src="/js/ort-i18n.js"></script>
<script>
// === I18N fallback pour cl√©s manquantes ===
(function(){
  if (!window.ORT_I18N) window.ORT_I18N = {};
  const add = (k, v) => { if (!window.ORT_I18N[k]) window.ORT_I18N[k] = v; };
  add('min', {fr:'min',en:'min',it:'min',es:'min',pt:'min',ar:'ÿØ'});
  add('night', {fr:'nuit',en:'night',it:'notte',es:'noche',pt:'noite',ar:'ŸÑŸäŸÑÿ©'});
  add('nights', {fr:'nuits',en:'nights',it:'notti',es:'noches',pt:'noites',ar:'ŸÑŸäÿßŸÑŸä'});
  add('choose', {fr:'Choisir',en:'Choose',it:'Scegli',es:'Elegir',pt:'Escolher',ar:'ÿßÿÆÿ™ÿ±'});
  add('passage', {fr:'(passage)',en:'(transit)',it:'(transito)',es:'(paso)',pt:'(passagem)',ar:'(ÿπÿ®Ÿàÿ±)'});
  add('searchHotelAt', {fr:'Chercher un h√©bergement √†',en:'Search accommodation in',it:'Cerca alloggio a',es:'Buscar alojamiento en',pt:'Procurar alojamento em',ar:'ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ≥ŸÉŸÜ ŸÅŸä'});
  add('viewDetails', {fr:'Voir d√©tails',en:'View details',it:'Vedi dettagli',es:'Ver detalles',pt:'Ver detalhes',ar:'ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ'});
})();
</script>
<script>
// === Fonction t() globale pour les traductions ===
if (typeof window.t !== 'function') {
  window.t = function(key) {
    const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0, 2);
    if (window.ORT_I18N?.[key]?.[lang]) return window.ORT_I18N[key][lang];
    if (window.ORT_I18N?.[key]?.fr) return window.ORT_I18N[key].fr;
    return key;
  };
}
</script>
<script>
// === CR√âATEUR MODE ===
window.IS_CREATOR = false;

// CSS pour masquer widgets en mode cr√©ateur
const style = document.createElement('style');
style.textContent = `
  body.creator-mode .hotels-widget,
  body.creator-mode .gyg-widget,
  body.creator-mode .photos-widget,
  body.creator-mode [data-widget="hotel"],
  body.creator-mode [data-widget="photos"],
  body.creator-mode .partner-widget {
    display: none !important;
  }
`;
document.head.appendChild(style);
(function(){
  const host = location.hostname;
  const isPreprod = /oneroadtrip-preprod|localhost|127\.0\.0\.1|0\.0\.0\.0/.test(host);
  const cfg  = isPreprod ? (window.ORT_CONFIG?.PREPROD || {}) : (window.ORT_CONFIG?.PROD || {});
  const safe = (cfg && cfg.apiKey) ? cfg : (window.ORT_CONFIG?.PREPROD || {});
  window.__FIREBASE_CONFIG__ = safe;
})();
</script>

<!-- Stay22 Affiliate Script -->
<script>
  (function (s, t, a, y, twenty, two) {
    s.Stay22 = s.Stay22 || {};
    s.Stay22.params = { lmaID: '692f0c75b2478d16bb9b22fa' };
    twenty = t.createElement(a);
    two = t.getElementsByTagName(a)[0];
    twenty.async = 1;
    twenty.src = y;
    two.parentNode.insertBefore(twenty, two);
  })(window, document, 'script', 'https://scripts.stay22.com/letmeallez.js');
</script>

<!-- Flatpickr date picker i18n -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
<style>
/* Flatpickr ORT theme */
.flatpickr-calendar{font-family:system-ui,sans-serif;border-radius:10px;box-shadow:0 4px 20px rgba(17,63,122,0.15);border:1px solid #c3d6b6}
.flatpickr-months{background:#113f7a;border-radius:10px 10px 0 0}
.flatpickr-months .flatpickr-month{color:#fff;fill:#fff}
.flatpickr-current-month .flatpickr-monthDropdown-months{color:#fff;background:#113f7a}
.flatpickr-current-month input.cur-year{color:#fff}
.flatpickr-months .flatpickr-prev-month,.flatpickr-months .flatpickr-next-month{fill:#fff}
.flatpickr-months .flatpickr-prev-month:hover,.flatpickr-months .flatpickr-next-month:hover{fill:#c3d6b6}
.flatpickr-day.selected,.flatpickr-day.selected:hover{background:#113f7a;border-color:#113f7a}
.flatpickr-day:hover{background:#e7f6fb;border-color:#c3d6b6}
.flatpickr-day.today{border-color:#113f7a}
</style>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/fr.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/it.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/es.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/pt.js"></script>
<script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/ar.js"></script>
</head>
<body>


<header>
    <a class="brandlink" id="homeLink" href="#">
    <img src="../assets/symbol.webp" alt="Logo"><div class="brand">OneRoadTrip</div>
  </a>
  <div class="spacer"></div>



  <select id="langSel" class="langpick" aria-label="Langue">

    <option value="fr">Fran√ßais</option>
    <option value="en">English</option>
    <option value="it">Italiano</option>
    <option value="es">Espa√±ol</option>
    <option value="pt">Portugu√™s</option>
    <option value="ar">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
  </select>
  <div class="auth">
    <button id="openAuth" class="btn" type="button" data-i18n="signIn">Se connecter</button>
    <div id="authPop" class="auth-pop" role="dialog" aria-label="Connexion">
      <button id="btnGoogle" class="btn" type="button">Google</button>
      <button id="btnEmail" class="btn" type="button">E-mail</button>
      <button id="btnLogout" class="btn out" type="button" style="display:none" data-i18n="logout">D√©connexion</button>
    </div>
  </div>
</header>

<!-- ‚¨áÔ∏è LANGUAGE SELECTOR HANDLER -->
<script>
(function(){
  const langSel = document.getElementById('langSel');
  if (!langSel) return;
  
  const currentLang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  langSel.value = currentLang;
  
  langSel.addEventListener('change', function(e) {
    const newLang = e.target.value;
    localStorage.setItem('lang', newLang);
    document.documentElement.lang = newLang;
    document.documentElement.dir = (newLang === 'ar') ? 'rtl' : 'ltr';
    
    if (typeof window.applyI18N === 'function') {
      window.applyI18N();
    }
    
    window.dispatchEvent(new StorageEvent('storage', {
      key: 'lang',
      newValue: newLang,
      oldValue: currentLang
    }));
    
    console.log('[LANG] Chang√© vers:', newLang);
  });
  
  console.log('[LANG] ‚úÖ S√©lecteur initialis√©');
})();
</script>

<!-- Bandeau outils sp√©cifiques roadtrip_detail -->
<div id="ortToolbar" class="toolbar-band"></div>

<script>
!function(){
  try{
    console.log('[TOOLBAR] Script d√©marr√©');
    // Fonction t() locale avec fallback si ort-i18n.js pas encore charg√©
    var lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2).toLowerCase();
    var I18N_TOOLBAR = {
      dashboard: {fr:'Dashboard',en:'Dashboard',es:'Panel',it:'Dashboard',pt:'Dashboard',ar:'ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ'},
      mustBeSignedIn: {fr:'Vous devez √™tre enregistr√© pour acc√©der au Dashboard.',en:'You must be signed in to access the Dashboard.',es:'Debe estar registrado para acceder.',it:'Devi essere registrato.',pt:'Voc√™ precisa estar conectado.',ar:'Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖÿ≥ÿ¨ŸëŸÑŸãÿß'},
      centerOnRoute: {fr:'Centrer trajet',en:'Center route',es:'Centrar ruta',it:'Centra percorso',pt:'Centralizar rota',ar:'ÿ™Ÿàÿ≥Ÿäÿ∑ ÿßŸÑŸÖÿ≥ÿßÿ±'},
      generatePDF: {fr:'G√©n√©rer PDF',en:'Generate PDF',es:'Generar PDF',it:'Genera PDF',pt:'Gerar PDF',ar:'ÿ•ŸÜÿ¥ÿßÿ° PDF'},
      pdfModuleNotLoaded: {fr:'Module PDF non charg√©',en:'PDF module not loaded',es:'M√≥dulo PDF no cargado',it:'Modulo PDF non caricato',pt:'M√≥dulo PDF n√£o carregado',ar:'Ÿàÿ≠ÿØÿ© PDF ÿ∫Ÿäÿ± ŸÖÿ≠ŸÖŸÑÿ©'}
    };
    var t = function(k) {
      // Utiliser window.t si disponible (ort-i18n.js), sinon fallback local
      if (typeof window.t === 'function') return window.t(k);
      return I18N_TOOLBAR[k]?.[lang] || I18N_TOOLBAR[k]?.fr || k;
    };

    // 1) Cible le bandeau toolbar (pas le header)
    var hdr = document.getElementById('ortToolbar'); if(!hdr) return;
    hdr.style.display = 'flex';
    hdr.style.flexWrap = 'wrap';
    hdr.style.justifyContent = 'center';
    hdr.style.alignItems = 'center';
    hdr.style.gap = '10px';
    hdr.style.padding = '8px 16px';
    hdr.style.background = 'rgba(255,255,255,0.1)';
    hdr.style.marginBottom = '10px';

    // 2) √âvite les doublons si d√©j√† inject√©
    if(document.getElementById('ortDashRow')) return;

    // 3) Conteneur des boutons (dans le toolbar)
var row = document.createElement('div');
row.id = 'ortDashRow';
row.style.display = 'flex';
row.style.flexWrap = 'wrap';
row.style.justifyContent = 'center';
row.style.alignItems = 'center';
row.style.gap = '10px';

    // 5) Le bouton "Dashboard"
    var a = document.createElement('a');
    a.href = 'dashboard_user.html?lang=' + lang;
    a.textContent = t('dashboard');
    a.className = 'hdr-btn';
    // renforts visuels au cas o√π hdr-btn n‚Äôexiste pas partout
    a.style.textDecoration = 'none';
    a.style.whiteSpace = 'nowrap';
    a.style.padding = a.style.padding || '6px 12px';
    a.style.borderRadius = a.style.borderRadius || '10px';

    // 6) Si non connect√©, bloque et affiche un pop-up i18n
    a.addEventListener('click', function(ev){
      var user = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) || null;
      if(!user){
        ev.preventDefault();
        var box = document.createElement('div');
        Object.assign(box.style, {
          position:'fixed', left:'50%', top:'18px', transform:'translateX(-50%)',
          background:'#fff', color:'#113f7a',
          padding:'10px 14px', borderRadius:'10px',
          border:'1px solid #c3d6b6', boxShadow:'0 6px 18px rgba(0,0,0,.15)',
          zIndex:9999, maxWidth:'90%', fontFamily:'system-ui,Segoe UI,Roboto,Arial,sans-serif'
        });
        box.textContent = t('mustBeSignedIn');
        document.body.appendChild(box);
        setTimeout(function(){ box.remove(); }, 2400);
      }
    });

    row.appendChild(a);

    // Bouton "Centrer trajet" √† c√¥t√© du Dashboard
    var centerBtn = document.createElement('button');
    centerBtn.id = 'centerRouteBtn';
    centerBtn.className = 'hdr-btn';
    centerBtn.type = 'button';
    centerBtn.textContent = 'üéØ ' + t('centerOnRoute');
    centerBtn.title = t('centerOnRoute');
    centerBtn.style.whiteSpace = 'nowrap';
    row.appendChild(centerBtn);

    // Bouton "PDF" √† c√¥t√© de Centrer trajet
    var pdfBtn = document.createElement('button');
    pdfBtn.id = 'btnExportPDFHeader';
    pdfBtn.className = 'hdr-btn';
    pdfBtn.type = 'button';
    pdfBtn.textContent = 'üìÑ Carnet';
    pdfBtn.title = t('generatePDF');
    pdfBtn.style.whiteSpace = 'nowrap';
    pdfBtn.addEventListener('click', function(){
      if (window.ORT_PDF && window.state) {
        const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
        ORT_PDF.export(state, lang);
      } else {
        alert(t('pdfModuleNotLoaded'));
      }
    });
    row.appendChild(pdfBtn);

    // === DATE PICKER avec Flatpickr (i18n) ===
    var d = document.getElementById('rtStartDate');
if(!d){
  d = document.createElement('input');
  d.type = 'text';
  d.id = 'rtStartDate';
  d.readOnly = true;
  Object.assign(d.style, {
    padding:'6px 10px', borderRadius:'10px',
    border:'1px solid #c3d6b6', color:'#113f7a',
    cursor:'pointer', width:'130px', textAlign:'center',
    background:'#fff'
  });
  
  // i18n
  const lang = (document.documentElement.lang||'fr').slice(0,2);
  const TITLES = {
    fr:'Date de commencement du RT',
    en:'Road trip start date',
    it:'Data di inizio del road trip',
    es:'Fecha de inicio del road trip',
    pt:'Data de in√≠cio do road trip',
    ar:'ÿ™ÿßÿ±ŸäÿÆ ÿ®ÿØÿ° ÿßŸÑÿ±ÿ≠ŸÑÿ©'
  };
  const PLACEHOLDERS = {
    fr:'jj/mm/aaaa',
    en:'mm/dd/yyyy',
    it:'gg/mm/aaaa',
    es:'dd/mm/aaaa',
    pt:'dd/mm/aaaa',
    ar:'ŸäŸàŸÖ/ÿ¥Ÿáÿ±/ÿ≥ŸÜÿ©'
  };
  const DATE_FORMATS = {
    fr:'d/m/Y',
    en:'m/d/Y',
    it:'d/m/Y',
    es:'d/m/Y',
    pt:'d/m/Y',
    ar:'d/m/Y'
  };
  d.title = TITLES[lang] || TITLES.fr;
  d.placeholder = PLACEHOLDERS[lang] || PLACEHOLDERS.fr;
  
  // Initialiser flatpickr apr√®s insertion dans le DOM
  setTimeout(() => {
    if (window.flatpickr) {
      const urlDepart = new URLSearchParams(location.search).get('depart') || '';
      const savedDate = urlDepart || localStorage.getItem('ort.rtStartDate') || '';
      
      const fp = flatpickr(d, {
        locale: lang === 'en' ? 'default' : lang,
        dateFormat: DATE_FORMATS[lang] || 'd/m/Y',
        defaultDate: savedDate || null,
        allowInput: false,
        disableMobile: true,
        onChange: function(selectedDates, dateStr) {
          // Stocker en format ISO pour compatibilit√©
          const isoDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
          localStorage.setItem('ort.rtStartDate', isoDate);
          if (window.state) {
            state.startDateStr = isoDate;
            renderRows();
          }
        }
      });
      
      // Stocker la r√©f√©rence pour acc√®s global
      window.ortDatePicker = fp;
    }
  }, 100);
}
// Helpers notation (cl√© par itin√©raire)
function rtKeyForRating(){
  const qs = new URLSearchParams(location.search);
  return decodeURIComponent(qs.get('itin') || qs.get('rtKey') || 'RT');
}
function loadRatings(){
  try{ return JSON.parse(localStorage.getItem('ort.rtRatings::'+rtKeyForRating())||'[]'); }catch(_){ return []; }
}
function saveRatings(arr){
  try{ localStorage.setItem('ort.rtRatings::'+rtKeyForRating(), JSON.stringify(arr)); }catch(_){}
}
function myRatingGet(){ try{ return JSON.parse(localStorage.getItem('ort.myRtRating::'+rtKeyForRating())||'null'); }catch(_){ return null; } }
function myRatingSet(obj){ try{ localStorage.setItem('ort.myRtRating::'+rtKeyForRating(), JSON.stringify(obj||null)); }catch(_){ } }
function avg(arr){ if(!arr.length) return null; const s=arr.reduce((a,x)=>a+Number(x.score||0),0); return Math.round((s/arr.length)*10)/10; }
function noteClass(v){ if(v==null) return ''; if(v<4) return 'note-bad'; if(v<7) return 'note-mid'; return 'note-good'; }

// I18N tooltips - utilise le syst√®me ort-i18n.js
const LANG = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);

// Helper pour obtenir les traductions dynamiquement
const getTrans = (key, fallback) => (window.t ? window.t(key) : fallback);
const getTip = (key) => getTrans(key, {
  tipSave: 'Enregistrer',
  tipFlag: 'Signaler',
  tipRate: 'Noter'
}[key] || key);

const getLabel = (key) => getTrans(key, {
  haveDone: 'Effectu√©',
  yes: 'Oui',
  no: 'Non',
  score: 'Note',
  save: 'Enregistrer',
  yourScore: 'Votre note',
  average: 'Moyenne',
  commentOptional: 'Commentaire (optionnel)',
  feedbackPlaceholder: 'Votre avis...',
  thanksFeedback: 'Merci !'
}[key] || key);

// == Ic√¥nes √† GAUCHE de la date (sans d√©caler la date) ==
let icoWrap = document.getElementById('rtInlineIcons');
if(!icoWrap){
  icoWrap = document.createElement('div');
  icoWrap.id = 'rtInlineIcons';
  icoWrap.className = 'rt-inline-icons';
  // boutons
  const bSave = document.createElement('button');
  const tipSave = window.t ? window.t('tipSave') : 'Enregistrer';
  bSave.type='button'; bSave.className='pill-ico'; bSave.title=tipSave; bSave.setAttribute('aria-label',tipSave); bSave.textContent='üíæ';
  
  const bFlag = document.createElement('button');
  const tipFlag = window.t ? window.t('tipFlag') : 'Signaler une erreur';
  bFlag.type='button'; bFlag.className='pill-ico danger'; bFlag.title=tipFlag; bFlag.setAttribute('aria-label',tipFlag); bFlag.textContent='‚ùó'; bFlag.style.display='none';
  
  const bRate = document.createElement('button');
  const tipRate = window.t ? window.t('tipRate') : 'Noter ce road trip';
  bRate.type='button'; bRate.className='pill-ico'; bRate.title=tipRate; bRate.setAttribute('aria-label',tipRate);
  bRate.id = 'rtRateBtn';  // ID pour acc√®s depuis menu
  window.rtRateBtn = bRate; // Rendu global pour le menu
  bRate.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">'
                  +   '<circle cx="12" cy="12" r="10" fill="#fff" stroke="#ff4040" stroke-width="2"></circle>'
                  +   '<text x="12" y="16" text-anchor="middle" font-size="12" font-family="Arial" font-weight="700" fill="#ff4040">10</text>'
                  + '</svg>';

  // Badge moyenne
  const avgBadge = document.createElement('span');

  avgBadge.id='rtAvgBadge';

  // √©tat saved visuel si d√©j√† dans ORTSaves (heuristique locale)
  try{
    const u=currentUser(); if(u){
      const arr = ORTSaves.load(u.uid);
      const here = (arr||[]).some(x=>x?.detailUrl===location.href || x?.id===ensureRid());
      if(here) bSave.classList.add('saved');
    }
  }catch(_){}

  // actions
  // actions
  bSave.addEventListener('click', ()=>{ document.getElementById('btnSave')?.click(); bSave.classList.add('saved'); });

  // ‚ùó Alerter ‚Üí bo√Æte de dialogue + envoi silencieux
  function openNoteDialog(){
    const title = window.t ? window.t('tipFlag') : 'Signaler une erreur';
    const note = prompt(title + '\n\n√âcrivez votre message libre :');
    if(!note || !note.trim()) return;

    const payload = {
      subject: '[ORT] Signalement ‚Äî Roadtrip',
      message:
        `URL: ${location.href}\nLang: ${LANG}\nUser: ${(currentUser()?.email||'guest')}\n\n` +
        `Note:\n${note.trim()}`
    };

    fetch('https://formsubmit.co/ajax/contact@oneroadtrip.com', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    })
    .then(r => { console.log('[Signalement ORT]', r.status); toast(t('reportSent')); })
    .catch(e => { console.warn('Erreur signalement ORT', e); toast(t('sendError')); });
  }
  window.openNoteDialog = openNoteDialog;  // Rendu global pour le menu
  bFlag.addEventListener('click', openNoteDialog);

  // popover Notation (+ commentaire + e-mail + stockage)
  function openRatePopover(anchor){
    // cleanup existant
    document.querySelectorAll('.rate-pop').forEach(x=>x.remove());
    const pop=document.createElement('div'); pop.className='rate-pop';

    const mine = myRatingGet() || { done:false, score:7, comment:'' };
    
    // Obtenir les traductions au moment de la cr√©ation de la modale
    const L_DONE = getLabel('haveDone');
    const L_YES = getLabel('yes');
    const L_NO = getLabel('no');
    const L_SCORE = getLabel('score');
    const L_SAVE = getLabel('save');
    const L_YOUR = getLabel('yourScore');
    const L_AVG = getLabel('average');
    const L_COMMENT = getLabel('commentOptional');
    const L_PLACEHOLDER = getLabel('feedbackPlaceholder');
    const L_SENT_OK = getLabel('thanksFeedback');
    
    pop.innerHTML = `
      <div class="row"><strong>${L_DONE}</strong>
        <span>
          <label><input type="radio" name="rtDone" value="1" ${mine.done?'checked':''}> ${L_YES}</label>
          <label style="margin-left:10px"><input type="radio" name="rtDone" value="0" ${!mine.done?'checked':''}> ${L_NO}</label>
        </span>
      </div>
      <div class="row">
        <label for="rtScore"><strong>${L_SCORE}</strong></label>
        <input id="rtScore" type="range" min="1" max="10" step="1" value="${mine.score||7}" style="width:160px">
        <span id="rtScoreLbl">${mine.score||7}/10</span>
      </div>

      <div class="row" style="align-items:flex-start">
        <label for="rtComment" style="margin-right:8px"><strong>üñä ${L_COMMENT}</strong></label>
      </div>
      <div class="row" style="display:block">
        <textarea id="rtComment" rows="3" placeholder="${L_PLACEHOLDER}"
          style="width:100%;padding:8px;border:1px solid #cfd6e4;border-radius:8px;resize:vertical">${mine.comment?String(mine.comment).replace(/</g,'&lt;'):''}</textarea>
      </div>

      <div class="mut" id="rtAvgLine" style="margin:6px 0"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button class="btn ghost" data-act="cancel" type="button">‚úï</button>
        <button class="btn" data-act="save" type="button">${L_SAVE}</button>
      </div>
    `;
    document.body.appendChild(pop);
    // positionnement
    const r=anchor.getBoundingClientRect();
    pop.style.left = Math.min(window.innerWidth- pop.offsetWidth-12, Math.max(12, r.left + window.scrollX - 6))+'px';
    pop.style.top  = (r.bottom + window.scrollY + 8)+'px';

    // interactions
    const score   = pop.querySelector('#rtScore');
    const lbl     = pop.querySelector('#rtScoreLbl');
    const avgLine = pop.querySelector('#rtAvgLine');
    const comment = pop.querySelector('#rtComment');

    function refreshAvgLine(){
      const arr=loadRatings(); const A=avg(arr);
      const mineVal = Number(score.value||7);
      const cls = noteClass(mineVal);
      const avgTxt = (A==null)?'‚Äî':`${A}/10`;
      avgLine.innerHTML = `<strong>${L_YOUR}:</strong> <span class="${cls}">${mineVal}/10</span>  ¬∑  <strong>${L_AVG}:</strong> ${avgTxt}`;
      // badge
      const badge = document.getElementById('rtAvgBadge');
      if(badge){ 
        if(A!=null){ badge.style.display='inline-flex'; badge.innerHTML=`‚≠ê ${A}/10`; } 
        else { badge.style.display='none'; }
      }
    }
    score.addEventListener('input', ()=>{ lbl.textContent = `${score.value}/10`; refreshAvgLine(); });
    refreshAvgLine();

    pop.addEventListener('click', async (e)=>{
      const act=e.target?.dataset?.act;
      if(act==='cancel'){ pop.remove(); }
      if(act==='save'){
        const done = pop.querySelector('input[name="rtDone"]:checked')?.value==='1';
        const sc   = Number(score.value||7);
        const cmt  = (comment?.value||'').trim();

        // 1) MAJ mon vote (incl. commentaire)
        const mineNow = { done, score: sc, comment: cmt, ts: Date.now() };
        myRatingSet(mineNow);

        // 2) MAJ pool local (1 vote par navigateur ‚Üí index 0)
        const arr=loadRatings();
        if(!arr.length){ arr.push(mineNow); } else { arr[0]=mineNow; }
        saveRatings(arr);

        // 3) Envoi e-mail silencieux
        try{
          const rtKey = (new URLSearchParams(location.search).get('itin')||new URLSearchParams(location.search).get('rtKey')||'RT');
          const user  = (currentUser()?.email || 'guest');
          const payload = {
            subject: '[ORT] Nouvelle note de roadtrip',
            message:
              `URL: ${location.href}\nLang: ${ (localStorage.getItem('lang') || document.documentElement.lang || 'fr') }\n` +
              `User: ${user}\nRT: ${rtKey}\nDone: ${done}\nScore: ${sc}/10\nComment:\n${cmt||'(vide)'}\n` +
              `When: ${new Date().toISOString()}`
          };
          fetch('https://formsubmit.co/ajax/contact@oneroadtrip.com', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          }).then(r=>console.log('[Rating mail]', r.status)).catch(()=>{});
        }catch(_){}

        // 4) Push optionnel vers API (si dispo)
        try{
          const FEED_API = (localStorage.ORT_FEEDBACK_API || '').replace(/\/+$/,'');
          if(FEED_API){
            const qs = new URLSearchParams(location.search);
            const body = {
              itin: decodeURIComponent(qs.get('itin')||''),
              cc:   (qs.get('cc')||'').toUpperCase(),
              score: sc,
              done,
              comment: cmt,
              url: location.href,
              user: (currentUser()?.email || null),
              ts: Date.now()
            };
            fetch(`${FEED_API}/ratings`, {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify(body)
            }).catch(()=>{});
          }
        }catch(_){}

        refreshAvgLine();
        pop.remove();
        toast(L_SENT_OK);
      }
    });

    document.addEventListener('click', function onDoc(e){
      if(!pop.contains(e.target) && e.target!==anchor){ pop.remove(); document.removeEventListener('click', onDoc); }
    }, {capture:true});
  }
  window.openRatePopover = openRatePopover;  // Rendu global pour le menu
  bRate.addEventListener('click', (e)=>{ e.stopPropagation(); openRatePopover(bRate); });

  icoWrap.appendChild(bSave);

  icoWrap.appendChild(avgBadge);
  // bRate d√©plac√© dans le menu Outils
  // on n'accroche pas ici : on le fera apr√®s avoir ins√©r√© 'd' dans 'row'
}

// ins√©rer la date AVANT le bouton Dashboard
row.insertBefore(d, a);

// puis placer les ic√¥nes √† GAUCHE de la date
row.insertBefore(icoWrap, d);

// puis terminer comme avant
row.appendChild(a);
hdr.appendChild(row);
console.log('[TOOLBAR] ‚úÖ Row ajout√© au toolbar');

// Init badge moyenne au chargement
(function(){
  const badge = document.getElementById('rtAvgBadge');
  const A = avg(loadRatings());
  if(badge){
    if(A!=null){ badge.style.display='inline-flex'; badge.innerHTML=`‚≠ê ${A}/10`; }
    else { badge.style.display='none'; }
  }
})();

// === Ic√¥nes R√©servation (‚úàÔ∏é / üöò / üõ° Assurances) √† droite du Dashboard ===
(function(){
  // √©viter les doublons si re-render
  if(row.querySelector('[data-rt-resv="wrap"]')) return;

  const getParam = (k)=> new URLSearchParams(location.search).get(k)||'';
  const rtKey = window.CURRENT_TRIP_ID || getParam('rtKey') || 'trip_demo';

  const uidRaw = (window.CURRENT_USER_ID || localStorage.ORT_USER_ID || localStorage.getItem('ORT_USER_EMAIL') || 'guest')+'';
  const uid = uidRaw.toLowerCase().replace(/[^a-z0-9]/g,'');

  const pagePath = location.pathname + location.search;
  const lang=(document.documentElement.lang||'fr').slice(0,2);

  // √©tats r√©servations (persist√©s localStorage) ‚Äî avion/voiture
  const flightKey = `ort.rtBooked.flight.${rtKey}`;
  const carKey    = `ort.rtBooked.car.${rtKey}`;
  if(localStorage.getItem(flightKey)!=='1') localStorage.setItem(flightKey,'0');
  if(localStorage.getItem(carKey)!=='1')    localStorage.setItem(carKey,'0');
  const flightBooked = localStorage.getItem(flightKey)==='1';
  const carBooked    = localStorage.getItem(carKey)==='1';

  // I18N tooltips
  const TIP_FLIGHT={
    fr:'R√©servez votre avion', en:'Book your flight',
    it:'Prenota il tuo volo', es:'Reserva tu vuelo',
    pt:'Reserve seu voo', ar:'ÿßÿ≠ÿ¨ÿ≤ ÿ±ÿ≠ŸÑÿ™ŸÉ ÿßŸÑÿ¨ŸàŸäÿ©'
  }[lang] || 'Book your flight';

  const TIP_CAR={
    fr:'R√©servez votre v√©hicule de location', en:'Book your rental car',
    it:'Prenota la tua auto a noleggio', es:'Reserva tu coche de alquiler',
    pt:'Reserve seu carro alugado', ar:'ÿßÿ≠ÿ¨ÿ≤ ÿ≥Ÿäÿßÿ±ÿ™ŸÉ ÿßŸÑŸÖÿ§ÿ¨ÿ±ÿ©'
  }[lang] || 'Book your rental car';

  // I18N libell√© assurances (tooltip + aria-label)
  const TIP_INS={
    fr:'Assurez votre voyage', en:'Insure your trip',
    it:'Assicura il tuo viaggio', es:'Asegura tu viaje',
    pt:'Assegure a sua viagem', ar:'ÿ£ŸÖŸêŸëŸÜ ÿ±ÿ≠ŸÑÿ™ŸÉ'
  }[lang] || 'Insure your trip';

  const wrap = document.createElement('span');
  wrap.setAttribute('data-rt-resv','wrap');
  wrap.style.display='inline-flex';
  wrap.style.gap='10px';
  wrap.style.marginLeft='10px';


  // ‚úàÔ∏è Vols: ouvre la modal partenaire avec widget
  const bFlight = document.createElement('a');
  bFlight.innerHTML = '‚úàÔ∏è';
  bFlight.title = TIP_FLIGHT;
  bFlight.href = '#';
  bFlight.onclick = (e) => { e.preventDefault(); showPartnerModal('flight'); };
  bFlight.style.cssText = `text-decoration:none;display:inline-flex;align-items:center;justify-content:center;
    width:34px;height:34px;border-radius:50%;border:1px solid #c3d6b6;
    background:${flightBooked?'#0f9d58':'#e63b2e'};color:#fff;font-size:18px;
    box-shadow:0 2px 8px rgba(0,0,0,.12);line-height:1;`;
  
  // üöó Voiture & Transferts: ouvre la modal partenaire (emoji standard)
  const bCar = document.createElement('a');
  bCar.innerHTML = 'üöó';
  bCar.title = TIP_CAR;
  bCar.href = '#';
  bCar.onclick = (e) => { e.preventDefault(); showPartnerModal('vehicle'); };
  bCar.style.cssText = `text-decoration:none;display:inline-flex;align-items:center;justify-content:center;
    width:34px;height:34px;border-radius:50%;border:1px solid #c3d6b6;
    background:#fff;
    box-shadow:0 2px 8px rgba(0,0,0,.12);line-height:1;overflow:hidden;font-size:18px;`;

  // üõ° bouton assurances - ouvre la modal partenaire
  const bIns = document.createElement('a');
  bIns.innerHTML = 'üõ°';
  bIns.title = TIP_INS;
  bIns.href = '#';
  bIns.onclick = (e) => { e.preventDefault(); showPartnerModal('insurance'); };
  bIns.style.cssText = `text-decoration:none;display:inline-flex;align-items:center;justify-content:center;width:34px;height:34px;border-radius:50%;border:1px solid #c3d6b6;background:#e63b2e;color:#fff;font-size:18px;box-shadow:0 2px 8px rgba(0,0,0,.12);line-height:1;`;


  // === MENU OUTILS (avec i18n) ===
  (function(){
    console.log('[TOOLBAR] === MENU OUTILS - Cr√©ation d√©but ===');
    const toolsWrap = document.createElement('div');
    toolsWrap.style.cssText = 'display:inline-flex; position:relative; z-index:100;';

    const toolsBtn = document.createElement('button');
    const updateToolsLabel = () => {
      toolsBtn.innerHTML = 'üîß ' + (window.t ? window.t('tools') : 'Outils');
    };
    updateToolsLabel();
    toolsBtn.style.cssText = 'padding:8px 14px;border-radius:6px;border:1px solid #c3d6b6;background:#f8fafc;cursor:pointer;font-weight:600;font-size:14px;display:inline-flex;align-items:center;gap:6px;box-shadow:0 2px 8px rgba(0,0,0,.12);';
    
    const dropdown = document.createElement('div');
    dropdown.style.cssText = 'position:absolute;top:calc(100% + 8px);left:0;background:#fff;border:1px solid #ddd;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);min-width:200px;z-index:1001;display:none;';
    
    const menuItems = [
      { key: 'rateItinerary', emoji: '‚≠ê', click: () => { if(window.openRatePopover && window.rtRateBtn) window.openRatePopover(window.rtRateBtn); } },
      { key: 'reportError', emoji: '‚ùó', click: () => { if(typeof openNoteDialog === 'function') openNoteDialog(); } },
      { key: 'countrySheet', emoji: 'üåç', click: () => { document.getElementById('countryTab')?.click(); } }
    ];
    
    function renderMenuItems() {
      dropdown.innerHTML = '';
      console.log('[TOOLBAR] Menu Outils: renderMenuItems d√©but, menuItems.length=', menuItems.length);
      menuItems.forEach((item, i) => {
        const btn = document.createElement('button');
        const text = window.t ? window.t(item.key) : item.key;
        btn.innerHTML = `<span style="font-size:16px;margin-right:8px;">${item.emoji}</span>${text}`;
        btn.style.cssText = `display:block;width:100%;padding:10px 16px;border:none;background:none;text-align:left;cursor:pointer;font-size:14px;color:#1f2937;${i===0?'border-radius:8px 8px 0 0':''}${i===menuItems.length-1?'border-radius:0 0 8px 8px':''}`;
        btn.onmouseover = () => btn.style.background = '#f5f5f5';
        btn.onmouseout = () => btn.style.background = 'none';
        btn.onclick = (e) => { console.log('[TOOLBAR] Click item Outils:', item.key); e.stopPropagation(); item.click(); dropdown.style.display = 'none'; };
        dropdown.appendChild(btn);
        console.log('[TOOLBAR] Item Outils ajout√©:', item.key, i+1, '/', menuItems.length);
      });
      console.log('[TOOLBAR] Menu Outils: renderMenuItems fin, dropdown.children=', dropdown.children.length);
    }
    
    renderMenuItems();
    console.log('[TOOLBAR] Menu Outils items cr√©√©s, attachement listeners...');
    toolsBtn.onclick = (e) => { 
      console.log('[TOOLBAR] Click sur toolsBtn'); 
      e.stopPropagation(); 
      const newDisplay = dropdown.style.display === 'none' ? 'block' : 'none';
      dropdown.style.display = newDisplay;
      console.log('[TOOLBAR] Dropdown Outils display chang√© √†:', newDisplay, 'children:', dropdown.children.length);
    };
    document.addEventListener('click', (e) => { if(!toolsWrap.contains(e.target)) dropdown.style.display = 'none'; });
    
    // Ecouter les changements de langue
    window.addEventListener('storage', (e) => { if(e.key === 'lang') { updateToolsLabel(); renderMenuItems(); } });
    const langObserver = new MutationObserver(() => { updateToolsLabel(); renderMenuItems(); });
    langObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['lang'] });
    
    toolsWrap.appendChild(toolsBtn);
    toolsWrap.appendChild(dropdown);
    wrap.appendChild(toolsWrap);
    console.log('[TOOLBAR] ‚úÖ Menu Outils ajout√© √† wrap');
  })();

  // === MENU SERVICES (avec i18n) ===
  (function(){
    console.log('[TOOLBAR] === MENU SERVICES - Cr√©ation d√©but ===');
    const servicesWrap = document.createElement('div');
    servicesWrap.style.cssText = 'display:inline-flex; position:relative; z-index:100;';

    const servicesBtn = document.createElement('button');
    const updateServicesLabel = () => {
      servicesBtn.innerHTML = 'üõ†Ô∏è ' + (window.t ? window.t('services') || 'Services' : 'Services');
    };
    updateServicesLabel();
    servicesBtn.style.cssText = 'padding:8px 14px;border-radius:6px;border:1px solid #c3d6b6;background:#f8fafc;cursor:pointer;font-weight:600;font-size:14px;display:inline-flex;align-items:center;gap:6px;box-shadow:0 2px 8px rgba(0,0,0,.12);';
    
    const dropdown = document.createElement('div');
    dropdown.style.cssText = 'position:absolute;top:calc(100% + 8px);left:0;background:#fff;border:1px solid #ddd;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.15);min-width:200px;z-index:1001;display:none;';
    
    const menuItems = [
      { key: 'bookFlight', emoji: '‚úàÔ∏è', action: 'flight' },
      { key: 'bookCar', emoji: 'üöó', action: 'vehicle' },
      { key: 'bookInsurance', emoji: 'üõ°Ô∏è', action: 'insurance' },
      { key: 'bookActivities', emoji: 'üé≠', action: 'activities' }
    ];
    
    function renderMenuItems() {
      dropdown.innerHTML = '';
      console.log('[TOOLBAR] Menu Services: renderMenuItems d√©but, menuItems.length=', menuItems.length);
      menuItems.forEach((item, i) => {
        const btn = document.createElement('button');
        const text = window.t ? window.t(item.key) : item.key;
        btn.innerHTML = `<span style="font-size:16px;margin-right:8px;">${item.emoji}</span>${text}`;
        btn.style.cssText = `display:block;width:100%;padding:10px 16px;border:none;background:none;text-align:left;cursor:pointer;font-size:14px;color:#1f2937;${i===0?'border-radius:8px 8px 0 0':''}${i===menuItems.length-1?'border-radius:0 0 8px 8px':''}`;
        btn.onmouseover = () => btn.style.background = '#f5f5f5';
        btn.onmouseout = () => btn.style.background = 'none';
        btn.onclick = (e) => { console.log('[TOOLBAR] Click item Services:', item.key); e.stopPropagation(); if(typeof showPartnerModal === 'function') showPartnerModal(item.action); dropdown.style.display = 'none'; };
        dropdown.appendChild(btn);
        console.log('[TOOLBAR] Item Services ajout√©:', item.key, i+1, '/', menuItems.length);
      });
      console.log('[TOOLBAR] Menu Services: renderMenuItems fin, dropdown.children=', dropdown.children.length);
    }
    
    renderMenuItems();
    console.log('[TOOLBAR] Menu Services items cr√©√©s, attachement listeners...');
    servicesBtn.onclick = (e) => { 
      console.log('[TOOLBAR] Click sur servicesBtn'); 
      e.stopPropagation(); 
      const newDisplay = dropdown.style.display === 'none' ? 'block' : 'none';
      dropdown.style.display = newDisplay;
      console.log('[TOOLBAR] Dropdown Services display chang√© √†:', newDisplay, 'children:', dropdown.children.length);
    };
    document.addEventListener('click', (e) => { if(!servicesWrap.contains(e.target)) dropdown.style.display = 'none'; });
    
    // Ecouter les changements de langue
    window.addEventListener('storage', (e) => { if(e.key === 'lang') { updateServicesLabel(); renderMenuItems(); } });
    const langObserver = new MutationObserver(() => { updateServicesLabel(); renderMenuItems(); });
    langObserver.observe(document.documentElement, { attributes: true, attributeFilter: ['lang'] });
    
    servicesWrap.appendChild(servicesBtn);
    servicesWrap.appendChild(dropdown);
    wrap.appendChild(servicesWrap);
    console.log('[TOOLBAR] ‚úÖ Menu Services ajout√© √† wrap');
  })();
  console.log('[TOOLBAR] ‚úÖ Les deux menus cr√©√©s, ajout wrap √† row...');
  row.appendChild(wrap);
  console.log('[TOOLBAR] ‚úÖ Wrap ajout√© √† row');
})();

  }catch(e){ console.error('[TOOLBAR] Erreur:', e); }

}();
</script>

<div class="wrap">
  <div class="card topband">
  <div class="help-anchor">
    <div id="rtTitle" class="pill title" data-i18n="loading">Chargement...</div>
<button id="countryTab" title="Fiche pays" data-i18n-title="countrySheet" style="display:none;">
  <img src="../assets/icon-country.webp" alt="Fiche pays" style="width:22px;height:22px">
</button>
    <div id="quickStats" class="pill stats" title="Survolez pour la l√©gende">
      <span id="qsNights">‚Äî <span data-i18n="nights">nuits</span></span> ¬∑ <span id="qsDelta">Œî 0</span> ¬∑
      <span id="qsKm">‚Äî km</span> ¬∑ <span id="qsTime">‚Äî h ‚Äî min</span><span id="qsTravelDays" style="display:none"></span>
    </div>
  </div>


</div>



  <div id="creatorSection" class="card" style="display:none;background:linear-gradient(135deg,#f3f4f6,#e5e7eb);border-left:4px solid #113f7a;padding:24px;margin-bottom:16px">
    <div style="display:flex;gap:20px;align-items:flex-start">
      <!-- Logo cr√©ateur -->
      <div style="flex-shrink:0">
        <img id="creatorLogo" src="" alt="Logo" style="width:80px;height:80px;border-radius:12px;object-fit:cover;box-shadow:0 2px 8px rgba(0,0,0,0.1)">
      </div>
      
      <!-- Info cr√©ateur -->
      <div style="flex:1">
        <div style="font-size:12px;color:#666;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px;font-weight:600" data-i18n="byCreator">PAR</div>
        <div style="font-size:22px;font-weight:700;color:#113f7a;margin-bottom:4px" id="creatorName"></div>
        
        <!-- Bio multi-lignes -->
        <div id="creatorBio" style="font-size:14px;color:#444;line-height:1.6;margin-bottom:16px;max-width:600px;white-space:pre-wrap;word-wrap:break-word"></div>
        
        <!-- Lien avec ic√¥ne -->
        <a id="creatorLink" href="" target="_blank" rel="noopener" style="display:inline-flex;align-items:center;gap:8px;padding:10px 18px;background:#113f7a;color:#fff;border-radius:8px;font-size:14px;text-decoration:none;font-weight:600;transition:background 0.2s;cursor:pointer" onmouseover="this.style.background='#0d2a5c'" onmouseout="this.style.background='#113f7a'">
          <span>Visiter le profil</span>
          <span style="font-size:16px">‚Üí</span>
        </a>
      </div>
    </div>
  </div>

  <div class="main">
    <section class="card">
     <div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-bottom:12px">
  <div class="small" data-i18n="dragToReorder">Glissez pour r√©ordonner</div>
  <div style="display:flex;gap:6px;">
    <button id="btnListFull" class="iconbtn" type="button" title="Plein √©cran liste" data-i18n-title="fullscreenList">‚§¢</button>
    <button id="btnListExit" class="iconbtn" type="button" title="Quitter plein √©cran" data-i18n-title="exitFullscreen" style="display:none">‚§° <span data-i18n="reduce">R√©duire</span></button>
  </div>
</div>


      <div id="rows"></div>
      <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn" id="btnSave" data-i18n="save">üíæ Sauvegarder</button>
        <button class="btn ghost" id="btnExport" data-i18n="export">üì• Exporter</button>
        <button class="btn ghost" id="btnReorganizeHotels" title="Changer la strat√©gie de regroupement des h√¥tels (5 modes)" data-i18n-title="hotelStrategy" style="display:none">
          üè® <span data-i18n="reorganizeHotels">R√©organiser h√¥tels</span>
        </button>
        <button class="btn ghost" id="btnResetGroups" data-i18n-title="resetGroupsHelp">
          ‚úñ <span data-i18n="resetGroups">Annuler groupes/h√¥tels</span>
        </button>
      </div>
    </section>

    <aside class="sidebar">
  <div class="card">
    <!-- Bandeau et copies de boutons supprim√©s : tous les contr√¥les sont dans le header -->
 <div id="map">
  <!-- L√©gende des marqueurs -->
  <div class="color-legend" id="mapLegend">
    <div class="legend-title" data-i18n="places">Lieux</div>
    <div class="legend-item">
      <svg class="legend-star" width="16" height="16" viewBox="0 0 24 24" fill="#1565C0" stroke="#fff" stroke-width="2">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
      </svg> 
      <span data-i18n="mustSee">Incontournable</span>
    </div>
    <div class="legend-item"><div class="legend-dot recommended"></div> <span data-i18n="recommended">Recommand√©</span></div>
    <div class="legend-item"><div class="legend-dot discover"></div> <span data-i18n="toDiscover">√Ä d√©couvrir</span></div>
  </div>
  
  <!-- Overlay actions carte -->
    <!-- Overlay actions carte -->
  <div id="mapActions" aria-label="Actions carte">
<button id="btnMapFull" class="tool" type="button" title="Plein √©cran" data-i18n-title="fullscreen">‚§¢</button>
<button id="btnMapExit" class="tool" type="button" title="Quitter plein √©cran" data-i18n-title="exitFullscreen" style="display:none">‚§°</button>

   
  </div>

</div>
         <!-- Aide "Survolez un marqueur" supprim√©e -->
->
  </div>
</aside>

  </div>
</div>

<footer id="footer-legal"></footer>

<!-- === FICHE PAYS (tiroir lat√©ral global) === -->

<div id="countryDrawer" role="dialog" aria-label="Fiche pays">
  <div class="cd-head">
    <div class="cd-title" id="cdTitle" data-i18n="country">Pays</div>
    <button class="cd-close" id="cdClose" aria-label="Fermer" data-i18n-aria-label="close">‚úï</button>
  </div>
  <div class="cd-body">
    <div class="tabs" id="cdTabs"></div>
    <div id="cdPanes"></div>
  </div>
</div><!-- === FICHE PAYS (tiroir lat√©ral global) === -->

<script>
// Place le bouton "Fiche pays" dans la barre d‚Äôic√¥nes du header (toujours visible)
(function ensureCountryTab(){
  function openDrawer(){
    const d = document.getElementById('countryDrawer');
    if (d) d.classList.add('show');
  }

  function mountInIcons(){
    const icoWrap = document.getElementById('rtInlineIcons'); // existe d√©j√† (cr√©√© dans le header)
    if (!icoWrap) return false;

    // retire une ancienne version
    document.getElementById('countryTab')?.remove();

    const btn = document.createElement('button');
    btn.id = 'countryTab';
    btn.className = 'pill-ico';
    btn.title = 'Fiche pays';
    btn.setAttribute('aria-label','Fiche pays');

    // image + fallback emoji si l‚Äôimage ne charge pas
    const img = new Image();
    img.src = '../assets/icon-country.webp';
    img.alt = '';
    img.style.width = '18px';
    img.style.height = '18px';
    img.style.display = 'block';
    img.onerror = () => { btn.textContent = 'üó∫Ô∏è'; };
    btn.appendChild(img);

    btn.addEventListener('click', openDrawer);
    icoWrap.insertBefore(btn, icoWrap.firstChild); // en premier, avant üíæ
    return true;
  }

  function mountFallback(){
    const anchor = document.querySelector('.help-anchor');
    if (!anchor) return;
    let btn = document.getElementById('countryTab');
    if (!btn) {
      btn = document.createElement('button');
      btn.id = 'countryTab';
      btn.className = 'pill-ico';
      btn.title = 'Fiche pays';
      btn.innerHTML = '<img src="../assets/icon-country.webp" alt="" style="width:18px;height:18px;display:block">';
      const stats = document.getElementById('quickStats');
      (stats ? anchor.insertBefore(btn, stats) : anchor.appendChild(btn));
    }
    if (!btn.__wired){ btn.addEventListener('click', openDrawer); btn.__wired = true; }
  }

  if (!mountInIcons()) mountFallback();

  const cdClose = document.getElementById('cdClose');
  if (cdClose && !cdClose.__wired){
    cdClose.addEventListener('click', () => {
      document.getElementById('countryDrawer')?.classList.remove('show');
    });
    cdClose.__wired = true;
  }
})();
</script>

<!-- HomeLink handler -->
<script>
(function(){
  const home = document.getElementById('homeLink');
  if (home) {
    home.addEventListener('click', function(e) {
      e.preventDefault();
      const lang = localStorage.getItem('lang') || 'fr';
      const u = new URL('presentation.html', location.href);
      u.searchParams.set('lang', lang);
      location.href = u.toString();
    });
  }
})();
</script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script src="js/ort-step-common.js"></script>
<!-- STATE MANAGER -->
<script src="js/ort-state-manager.js"></script>
<script src="js/ort-detail-adapter.js"></script>
<script>
 // === App script ===
 const ROUTE_API = null; // Non utilis√©, calculateDistance appelle OSRM directement

// === ORT Saves SDK (dashboard_user.html compatible) ===
const ORTSaves = {
  key(uid){ return `ort.saves::${uid}`; },
  load(uid){ try{ return JSON.parse(localStorage.getItem(this.key(uid))||'[]'); }catch(_){ return []; } },
  save(uid, arr){ try{ localStorage.setItem(this.key(uid), JSON.stringify(arr)); }catch(_){} },
  upsert(user, rt){
    if(!user){ toast(t('loginToSave')); return false; }
    if(window.ORT_STATE && typeof window.ORT_STATE.saveTrip === 'function') {
      const tripData = Object.assign({ createdAt: Date.now(), updatedAt: Date.now() }, rt);
      window.ORT_STATE.saveTrip(tripData);
      return true;
    }
    // Fallback localStorage (ancien syst√®me)
    const uid = user.uid, arr = this.load(uid);
    const key = `ort.saves::${uid || 'anon'}`;
    const i = arr.findIndex(x => x.id === rt.id);
    if(i >= 0) arr[i] = Object.assign({}, arr[i], rt, { updatedAt: Date.now() });
    else arr.push(Object.assign({ createdAt: Date.now(), updatedAt: Date.now() }, rt));
    localStorage.setItem(key, JSON.stringify(arr));
    return true;
  }
};
function currentUser(){ try{ return (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) || null; }catch(_){ return null; } }

// === G√©n√©rer un tripId unique ===
function getTripId() {
  const params = new URLSearchParams(location.search);
  const cc = params.get('cc');
  const itin = params.get('itin');
  
  // Pour les RT standards (cc+itin), cr√©er un tripId STABLE
  if (cc && itin) {
    const tripId = `user::${cc}::${itin}`.replace(/[^a-zA-Z0-9:_-]/g, '_');
    console.log('[getTripId] ‚úÖ TripId stable:', tripId);
    return tripId;
  }
  
  // Pour RT temporaires, v√©rifier si on a d√©j√† un tripId en cours
  const tempId = localStorage.getItem('ORT_CURRENT_TRIP_ID');
  if (tempId) {
    console.log('[getTripId] ‚úÖ TripId temporaire existant:', tempId);
    return tempId;
  }
  
  // Sinon, g√©n√©rer un nouveau tripId temporaire
  const newId = `trip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  localStorage.setItem('ORT_CURRENT_TRIP_ID', newId);
  console.log('[getTripId] ‚ö†Ô∏è Nouveau tripId temporaire:', newId);
  return newId;
}

// === Navigation vers le carnet d'√©tape (global scope) ===
function openStepPage(step, idx){
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üöÄ [OPEN STEP] Ouverture √©tape depuis roadtrip_detail');
  console.log('   step:', step);
  console.log('   idx:', idx);
  
const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').toLowerCase();
const url  = new URL('roadtrip_step.html', location.origin);

// Utilise le tripId de l'URL
  
  // IMPORTANT : R√©cup√©rer le tripId de mani√®re stable
const currentParams = new URLSearchParams(location.search);
const cc = currentParams.get('cc');
const itin = currentParams.get('itin');

let tripId;

if (cc && itin) {
  tripId = `user::${cc}::${itin}`.replace(/[^a-zA-Z0-9:_-]/g, '_');
  console.log('   ‚úÖ TripId stable g√©n√©r√©:', tripId);
} else if (currentParams.get('tripId')) {
  tripId = currentParams.get('tripId');
  console.log('   ‚úÖ TripId depuis URL:', tripId);
} else {
  tripId = getTripId();
  console.log('   ‚ö†Ô∏è TripId depuis getTripId():', tripId);
}
  
  console.log('   tripId:', tripId);
  console.log('   lang:', lang);
  
  url.searchParams.set('lang', lang);
  url.searchParams.set('tripId', tripId);
  url.searchParams.set('stepId', `day_${(idx||0)+1}`);
  
  if(step?.place_id) {
    url.searchParams.set('pid', step.place_id);
    console.log('   place_id:', step.place_id);
  }
  
  url.searchParams.set('focus','journal');

  /// üîπ Transmettre from & rtKey pour retour correct
  const from = currentParams.get('from');
  const rtKey = currentParams.get('rtKey');
  // cc et itin d√©j√† d√©clar√©s plus haut (lignes 2183-2184), on les r√©utilise
  
  console.log('   Param√®tres d√©tail:', { from, rtKey, cc, itin });

  if(from) {
    url.searchParams.set('from', from);
    console.log('   ‚úÖ from transmis:', from);
  }
  if(rtKey) {
    url.searchParams.set('rtKey', rtKey);
    console.log('   ‚úÖ rtKey transmis:', rtKey);
  }
  if(cc) {
    url.searchParams.set('cc', cc);
    console.log('   ‚úÖ cc transmis:', cc);
  }
  if(itin) {
    url.searchParams.set('itin', itin);
    console.log('   ‚úÖ itin transmis:', itin);
  }
  
  

  // üîπ On met en cache les donn√©es minimales de l'√©tape
  try {
    const payload = { 
      title: state?.title || '', 
      country: state?.country || '', 
      steps: state?.steps || [] 
    };
    
    console.log('üíæ [CACHE] Sauvegarde donn√©es:', {
      title: payload.title,
      country: payload.country,
      stepsCount: payload.steps?.length || 0
    });
    
    // Cache principal
    const cacheKey1 = `ort.step.cache::${tripId}`;
    localStorage.setItem(cacheKey1, JSON.stringify(payload));
    console.log('   ‚úÖ Cache 1:', cacheKey1);
    
    // Cache alternatif pour RT temp (par rtKey)
    if(rtKey) {
      const cacheKey2 = `ort.tmp.rt::${rtKey}`;
      localStorage.setItem(cacheKey2, JSON.stringify(payload));
      console.log('   ‚úÖ Cache 2:', cacheKey2);
    }
    
    console.log('üíæ [CACHE] V√©rification localStorage:');
    console.log('   Total cl√©s:', Object.keys(localStorage).length);
    Object.keys(localStorage).forEach(k => {
      if (k.includes('ort') && (k.includes('cache') || k.includes('tmp'))) {
        const val = localStorage.getItem(k);
        console.log(`   - ${k}: ${val.substring(0, 60)}...`);
      }
    });
    
  } catch(e) { 
    console.error('‚ùå [CACHE] Impossible:', e); 
  }

  console.log('üéØ [OPEN STEP] URL construite:', url.toString());
  console.log('üöÄ [OPEN STEP] Redirection...');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  location.href = url.toString();
}

// I18N minimal pour le popup
function L_step(){
  const lang=(localStorage.getItem('lang')||document.documentElement.lang||'fr').slice(0,2).toLowerCase();
  const t={
    go:{fr:"Aller sur le d√©tail de l‚Äô√©tape ?",en:"Go to step detail?",it:"Aprire il dettaglio della tappa?",es:"Ir al detalle de la etapa?",pt:"Ir ao detalhe da etapa?",ar:"ŸÅÿ™ÿ≠ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖÿ±ÿ≠ŸÑÿ©ÿü"},
    need:{fr:"Vous devez √™tre connect√© pour ouvrir le carnet.",en:"You must be signed in to open the journal.",it:"Devi essere connesso per aprire il diario.",es:"Debe estar conectado para abrir el diario.",pt:"√â necess√°rio estar ligado para abrir o di√°rio.",ar:"Ÿäÿ¨ÿ® ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ ŸÑŸÅÿ™ÿ≠ ÿßŸÑŸÖŸÅŸÉÿ±ÿ©."},
    open:{fr:"Ouvrir",en:"Open",it:"Apri",es:"Abrir",pt:"Abrir",ar:"ŸÅÿ™ÿ≠"},
    cancel:{fr:"Annuler",en:"Cancel",it:"Annulla",es:"Cancelar",pt:"Cancelar",ar:"ÿ•ŸÑÿ∫ÿßÿ°"}
  }; return {go:t.go[lang]||t.go.fr, need:t.need[lang]||t.need.fr, open:t.open[lang]||t.open.fr, cancel:t.cancel[lang]||t.cancel.fr};
}

// Popover ancr√© au bouton "‚Üó"
function showGoPopover(anchorEl, step, idx){
  const t=L_step();
  const u=currentUser();
  document.querySelectorAll('.go-pop').forEach(x=>x.remove());
  const box=document.createElement('div'); box.className='go-pop';
  box.innerHTML = u
    ? `<div>${t.go}</div><div class="row"><button class="btn ghost" data-act="cancel">${t.cancel}</button><button class="btn" data-act="open">${t.open}</button></div>`
    : `<div>${t.need}</div><div class="row"><button class="btn" data-act="cancel">OK</button></div>`;
  document.body.appendChild(box);
  const r=anchorEl.getBoundingClientRect();
  box.style.left = Math.min(window.innerWidth-box.offsetWidth-12, Math.max(12, r.left + window.scrollX - 8)) + 'px';
  box.style.top  = (r.bottom + window.scrollY + 8) + 'px';
  box.addEventListener('click', (e)=>{
    const act=e.target?.dataset?.act;
    if(act==='open'){ openStepPage(step, idx); }
    box.remove();
  });
  document.addEventListener('click', function onDoc(e){
    if(!box.contains(e.target) && e.target!==anchorEl){ box.remove(); document.removeEventListener('click', onDoc); }
  }, {capture:true});
}

function ensureRid(){
  // A) cl√© par URL (stable, sans d√©pendre de variables hors scope)
  const urlKey = `ort.rid.url::${location.pathname}${location.search}`;
  let rid = localStorage.getItem(urlKey);
  if (rid) return rid;

  // B) fallback par param√®tres d'URL (itin / rtKey), sinon 'RT'
  const qs = new URLSearchParams(location.search);
  const base = qs.get('itin') || qs.get('rtKey') || 'RT';
  const k = `ort.rid::${base}`;
  rid = localStorage.getItem(k) || crypto.randomUUID();

  localStorage.setItem(urlKey, rid);
  return rid;
}

let __asTimer = null;
let __hasUnsavedChanges = false;

// Marquer qu'il y a des modifications non sauvegard√©es
function markUnsavedChanges() {
  if (__hasUnsavedChanges) return; // D√©j√† marqu√©
  __hasUnsavedChanges = true;
  
  // Afficher un badge/indicateur visuel
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) {
    indicator.style.display = 'flex';
  } else {
    // Cr√©er l'indicateur s'il n'existe pas
    const div = document.createElement('div');
    div.id = 'unsavedIndicator';
    div.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:#f59e0b;color:#000;padding:8px 16px;border-radius:20px;font-size:13px;font-weight:600;z-index:9999;display:flex;align-items:center;gap:8px;box-shadow:0 2px 10px rgba(0,0,0,0.2);';
    div.innerHTML = `${window.t ? window.t('unsavedChanges') : '‚ö†Ô∏è Modifications non sauvegard√©es'} <button onclick="document.getElementById('unsavedIndicator').style.display='none'" style="background:none;border:none;cursor:pointer;font-size:16px;padding:0 0 0 8px;">‚úï</button>`;
    document.body.appendChild(div);
  }
  
  // Toast une seule fois
  if (typeof toast === 'function') {
    toast(window.t ? window.t('unsavedToast') : 'üí° Pensez √† sauvegarder vos modifications via le bouton üíæ', 4000);
  }
}

// R√©initialiser le flag (appel√© apr√®s sauvegarde r√©ussie)
function clearUnsavedChanges() {
  __hasUnsavedChanges = false;
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) indicator.style.display = 'none';
}

// Ancienne fonction d√©sactiv√©e - remplac√©e par markUnsavedChanges
function scheduleAutosave(){
  // D√âSACTIV√â - le dashboard n'est aliment√© que via le bouton sauvegarder explicite
  // markUnsavedChanges() - SUPPRIM√â (arr√™te de spammer l'alerte)
}

// Petite fonction d'√©chappement HTML (utilis√©e par renderRow / showStepPreview)
function safe(v){
  return String(v ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}





// === SIDs uniques & stables ===
function __collectSids(){
  const set = new Set();
  (window.state?.steps||[]).forEach(s=>{ if(s && s.__sid) set.add(s.__sid); });
  return set;
}
function __nextSid(){
  const used = __collectSids();
  let n = 1;
  while(used.has(`D${String(n).padStart(2,'0')}`)) n++;
  return `D${String(n).padStart(2,'0')}`;
}
function ensureSid(step){
  if(!step) return null;
  if(step.__sid && !__collectSids().has(step.__sid)) return step.__sid;
  // (r√©)assigne un SID jamais utilis√©
  const sid = __nextSid();
  step.__sid = sid;
  return sid;
}

// ‚ûú AJOUT : parse JSON tol√©rant (utilis√© plus bas pour les objets TEMP)
function safeJSONParse(str){
  try{ return str ? JSON.parse(str) : null; }
  catch(e){ return null; }
}

// ============================================================================
// === SYST√àME AUTO-PLANNING : Calcul intelligent nuits + h√¥tels ===
// ============================================================================

/**
 * Calcule le temps de visite total pour un lieu (visits uniquement, pas activities)
 * Les activities sont des √©v√©nements optionnels/ponctuels
 * @param {string} place_id - ID du lieu (ex: "CH::geneva")
 * @returns {Object} { total: minutes, visitTime: min, activityTime: min, visits: [], activities: [] }
 */
function calculateVisitTime(place_id) {
  if (!place_id) {
    console.log(`[AUTO] ‚ö†Ô∏è place_id manquant`);
    return { total: 0, visitTime: 0, activityTime: 0, visits: [], activities: [] };
  }
  
  // V√©rifier si PLACES_INDEX existe et contient le lieu
  // IMPORTANT: typeof PLACES_INDEX en premier pour √©viter ReferenceError
  if (typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && typeof PLACES_INDEX === 'object' && PLACES_INDEX[place_id]) {
    const place = PLACES_INDEX[place_id];
    
    // Additionner UNIQUEMENT les temps de visite (pas les activit√©s)
    const visitTime = (place.visits || [])
      .reduce((sum, v) => sum + (v.visit_duration_min || 0), 0);
    
    // Les activit√©s sont informatives mais ne comptent pas pour les nuits
    const activityTime = (place.activities || [])
      .reduce((sum, a) => sum + (a.visit_duration_min || 0), 0);
    
    // Total = visites seulement
    const total = visitTime;
    
    if (total > 0) {
      console.log(`[AUTO] üìä ${place_id}: ${visitTime}min visites (${activityTime}min activit√©s ignor√©es) = ${total}min total`);
    }
    
    return {
      total: total,
      visitTime: visitTime,
      activityTime: activityTime,
      visits: place.visits || [],
      activities: place.activities || []
    };
  }
  
  // FALLBACK : Si pas dans PLACES_INDEX, chercher dans l'√©tape elle-m√™me
  const step = state.steps?.find(s => s.place_id === place_id);
  if (step && (step.visits || step.activities)) {
    const visitTime = (step.visits || [])
      .reduce((sum, v) => sum + (v.visit_duration_min || 0), 0);
    
    // Les activit√©s sont informatives mais ne comptent pas
    const activityTime = (step.activities || [])
      .reduce((sum, a) => sum + (a.visit_duration_min || 0), 0);
    
    // Total = visites seulement
    const total = visitTime;
    
    if (total > 0) {
      console.log(`[AUTO] üìä ${place_id} (depuis step): ${visitTime}min visites (${activityTime}min activit√©s ignor√©es) = ${total}min total`);
      return {
        total: total,
        visitTime: visitTime,
        activityTime: activityTime,
        visits: step.visits || [],
        activities: step.activities || []
      };
    }
  }
  
  // FALLBACK 2 : Estimer selon le type de lieu (4h par d√©faut)
  console.log(`[AUTO] ‚ö†Ô∏è ${place_id} non trouv√© - estimation par d√©faut 4h`);
  const defaultTime = 240; // 4h par d√©faut (ville moyenne)
  
  return {
    total: defaultTime,
    visitTime: defaultTime,
    activityTime: 0,
    visits: [],
    activities: [],
    _estimated: true
  };
}

/**
 * D√©termine le nombre de nuits n√©cessaires selon le temps de visite
 * R√®gles :
 * - < 4h ‚Üí 0 nuit (passage)
 * - 4-8h ‚Üí 1 nuit
 * - 8-14h ‚Üí 2 nuits
 * - > 14h ‚Üí 1 nuit par tranche de 7h
 * 
 * @param {number} totalMinutes - Temps total de visite en minutes
 * @returns {number} Nombre de nuits recommand√©es
 */
function determineNights(totalMinutes) {
  const hours = totalMinutes / 60;
  
  if (hours < 4) return 0;        // Passage rapide
  if (hours < 8) return 1;        // Journ√©e compl√®te
  if (hours < 14) return 2;       // 2 jours
  return Math.ceil(hours / 7);    // 1 nuit par 7h de visite
}

/**
 * Calcule la distance Haversine entre 2 points
 * @param {number} lat1, lon1, lat2, lon2
 * @returns {number} Distance en km
 */
function calculateHaversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Rayon de la Terre en km
  const toRad = (deg) => deg * Math.PI / 180;
  
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  
  const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
            Math.sin(dLon / 2) ** 2;
  
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return Math.round(R * c);
}

/**
 * Trouve les lieux dans un rayon donn√©
 * @param {string} place_id - Lieu de r√©f√©rence
 * @param {number} maxDistanceKm - Rayon max (d√©faut: 20km)
 * @returns {Array} Liste des lieux proches tri√©s par distance
 */
function findNearbyPlaces(place_id, maxDistanceKm = 20) {
  if (typeof PLACES_INDEX === 'undefined' || !PLACES_INDEX || !place_id) return [];
  
  const place = PLACES_INDEX[place_id];
  if (!place) return [];
  
  const nearby = [];
  
  for (const [pid, p] of Object.entries(PLACES_INDEX)) {
    if (pid === place_id) continue;
    if (!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) continue;
    
    const distance = calculateHaversineDistance(
      place.lat, place.lon,
      p.lat, p.lon
    );
    
    if (distance <= maxDistanceKm) {
      const visitTime = calculateVisitTime(pid);
      nearby.push({
        place_id: pid,
        name: p.name,
        distance: distance,
        visitTime: visitTime.total,
        visits: visitTime.visits,
        activities: visitTime.activities
      });
    }
  }
  
  return nearby.sort((a, b) => a.distance - b.distance);
}

// Calcul distance haversine (pour hub/satellite clustering)
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Rayon de la Terre en km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

/**
 * Applique le calcul automatique des nuits √† toutes les √©tapes
 * Modifie state.steps directement et sauvegarde automatiquement
 */
function autoCalculateNights(targetNights) {
  if (!state.steps || state.steps.length === 0) return;
  
  const steps = state.steps;
  const n = steps.length;
  
  // Ratio de compression bas√© sur les nuits cibles
  const totalSuggested = steps.reduce((s, st) => s + (st._suggestedDays || 1), 0);
  const ratio = targetNights > 0 ? targetNights / totalSuggested : 1;
  
  console.log('[NIGHTS] Calcul automatique - Target:', targetNights, 'Ratio:', ratio.toFixed(2));
  
  // === √âTAPE 1: Identifier les hubs potentiels ===
  const avgRating = steps.reduce((s, st) => s + (st.rating || 5), 0) / n;
  const sortedByDays = [...steps].sort((a, b) => (b._suggestedDays || 1) - (a._suggestedDays || 1));
  const top30Index = Math.max(0, Math.floor(n * 0.3) - 1);
  const top30Threshold = sortedByDays[top30Index]?._suggestedDays || 1;
  
  const hubs = [];
  steps.forEach((step, idx) => {
    const suggested = step._suggestedDays || 1;
    const rating = step.rating || 5;
    const isHub = suggested >= Math.min(1.5, top30Threshold) && rating >= avgRating;
    step._isHub = isHub;
    step._satellites = [];
    if (isHub) hubs.push(idx);
  });
  
  console.log('[NIGHTS] Hubs identifi√©s:', hubs.map(i => steps[i].name).join(', '));
  
  // === HUB PAR D√âFAUT SI AUCUN D√âTECT√â ===
  if(hubs.length === 0 && steps.length > 0){
    let bestIdx = 0;
    let bestRating = steps[0].rating || 0;
    steps.forEach((s, idx) => {
      if((s.rating || 0) > bestRating){
        bestRating = s.rating || 0;
        bestIdx = idx;
      }
    });
    
    steps[bestIdx]._isHub = true;
    steps[bestIdx]._hubGroup = bestIdx;
    steps[bestIdx]._satellites = [];
    hubs.push(bestIdx);
    console.log(`[NIGHTS] ‚ö†Ô∏è Aucun hub naturel ‚Üí "${steps[bestIdx].name}" promu hub par d√©faut (rating=${bestRating.toFixed(1)})`);
  }
  
  // === √âTAPE 2: Fusion des hubs cons√©cutifs (< 30km) ===
  const HUB_MERGE_DISTANCE = 30;
  
  for (let i = 0; i < hubs.length - 1; i++) {
    const hub1 = steps[hubs[i]];
    const hub2 = steps[hubs[i + 1]];
    
    if (hub1.lat && hub1.lon && hub2.lat && hub2.lon) {
      const dist = haversineDistance(hub1.lat, hub1.lon, hub2.lat, hub2.lon);
      
      if (dist < HUB_MERGE_DISTANCE) {
        console.log(`[NIGHTS] Fusion: "${hub2.name}" fusionn√© avec "${hub1.name}" (${dist.toFixed(1)}km < ${HUB_MERGE_DISTANCE}km)`);
        hub1._satellites.push(hubs[i+1]);
        hub2._mergedInto = hubs[i];
        hubs.splice(i + 1, 1);
        i--;
      }
    }
  }
  
  // === √âTAPE 3: Assigner satellites ===
  const SATELLITE_DISTANCE = 45;
  const SATELLITE_DAYS_RATIO = 2;
  
  steps.forEach((step, idx) => {
    if (step._isHub || step._mergedInto !== undefined) return;
    
    const stepDays = step._suggestedDays || 1;
    let closest = null;
    let closestDist = Infinity;
    
    hubs.forEach(hubIdx => {
      const hub = steps[hubIdx];
      if (!hub.lat || !hub.lon || !step.lat || !step.lon) return;
      
      const dist = haversineDistance(step.lat, step.lon, hub.lat, hub.lon);
      const hubDays = hub._suggestedDays || 1;
      
      if (dist < closestDist && dist <= SATELLITE_DISTANCE && stepDays <= hubDays * SATELLITE_DAYS_RATIO) {
        closest = hubIdx;
        closestDist = dist;
      }
    });
    
    if (closest !== null) {
      step._isSatellite = true;
      steps[closest]._satellites.push(idx);
      console.log('[NIGHTS]', step.name, '(', stepDays, 'j) ‚Üí satellite de', steps[closest].name, '(', closestDist.toFixed(1), 'km)');
    } else {
      step._isIndependentHub = true;
      console.log('[NIGHTS]', step.name, '‚Üí hub ind√©pendant (plus proche hub √†', closestDist === Infinity ? 'N/A' : closestDist.toFixed(1), 'km >',  SATELLITE_DISTANCE + 'km)');
    }
  });
  
  // === √âTAPE 4: Calculer les nuits ===
  steps.forEach((step, idx) => {
    const rawDays = (step._suggestedDays || 1) * ratio;
    
    if (step._isSatellite) {
      step.nights = 0;
    } else if (step._isHub) {
      const satellites = step._satellites || [];
      const satelliteDays = satellites.reduce((s, i) => s + (steps[i]._suggestedDays || 1), 0);
      const totalDays = ((step._suggestedDays || 1) + satelliteDays) * ratio;
      step.nights = Math.max(1, Math.ceil(totalDays));
    } else if (step._mergedInto !== undefined) {
      step.nights = 0;
    } else {
      step.nights = Math.max(1, Math.round(rawDays));
    }
  });
  
  // Log r√©sultat
  const totalNightsResult = steps.reduce((s, st) => s + (st.nights || 0), 0);
  console.log('[NIGHTS] R√©sultat:', totalNightsResult, 'nuits');
  
  return totalNightsResult;
}

// D√©clenchement automatique am√©lior√©
// 1. Au chargement initial (avec retry) - OPTION B : Toujours recalculer
// SAUF si on vient de pres_simple avec des param√®tres (PARAM_DAYS d√©fini)
window.addEventListener('load', () => {
  // V√©rifier si on vient de pres_simple avec param√®tres
  const qs = new URLSearchParams(location.search);
  const hasPresSimpleParams = qs.get('days') || qs.get('rythme');
  
  if(hasPresSimpleParams){
    console.log('[AUTO] ‚è≠Ô∏è Skip autoCalculateNights - param√®tres pres_simple d√©tect√©s');
    return;
  }
  
  let attempts = 0;
  const maxAttempts = 10;
  
  const tryAutoCalc = async () => {
    attempts++;
    
    if (state.steps && state.steps.length > 0) {
      // S'assurer que PLACES_INDEX est charg√©
      if (typeof PLACES_INDEX === 'undefined' || !PLACES_INDEX || Object.keys(PLACES_INDEX).length === 0) {
        console.log('[AUTO] Chargement de PLACES_INDEX...');
        try {
          await ensurePlacesIndex();
        } catch(e) {
          console.log('[AUTO] ‚ö†Ô∏è Erreur chargement PLACES_INDEX:', e);
        }
      }
      
      console.log('[AUTO] OPTION B : Recalcul syst√©matique des nuits');
      autoCalculateNights(state.targetNights);
      if (typeof renderRows === 'function') renderRows();
    } else if (attempts < maxAttempts) {
      console.log(`[AUTO] Tentative ${attempts}/${maxAttempts} - state pas encore pr√™t`);
      setTimeout(tryAutoCalc, 1000);
    }
  };
  
  setTimeout(tryAutoCalc, 500);
});

// 2. Hook sur le premier renderRows
const _originalRenderRows = window.renderRows;
let _autoCalcDone = false;

window.renderRows = async function() {
  // V√©rifier si on vient de pres_simple avec param√®tres
  const qs = new URLSearchParams(location.search);
  const hasPresSimpleParams = qs.get('days') || qs.get('rythme');
  
  // OPTION B : Toujours recalculer au premier appel SAUF si pres_simple
  if (!_autoCalcDone && state.steps && state.steps.length > 0 && !hasPresSimpleParams) {
    // S'assurer que PLACES_INDEX est charg√©
    if (typeof PLACES_INDEX === 'undefined' || !PLACES_INDEX || Object.keys(PLACES_INDEX).length === 0) {
      console.log('[AUTO] Hook renderRows - Chargement PLACES_INDEX...');
      try {
        await ensurePlacesIndex();
      } catch(e) {
        console.log('[AUTO] ‚ö†Ô∏è Erreur chargement PLACES_INDEX:', e);
      }
    }
    
    console.log('[AUTO] Hook renderRows - recalcul syst√©matique (Option B)');
    autoCalculateNights(state.targetNights);
    _autoCalcDone = true;
  } else if(hasPresSimpleParams && !_autoCalcDone){
    console.log('[AUTO] ‚è≠Ô∏è Skip hook autoCalculateNights - param√®tres pres_simple');
    _autoCalcDone = true;
  }
  
  // Appeler la fonction originale
  if (typeof _originalRenderRows === 'function') {
    return _originalRenderRows.apply(this, arguments);
  }
};

console.log('[AUTO-PLANNING] ‚úÖ Syst√®me charg√©');

// ============================================================================
// SYST√àME HOTELSBED - Recherche d'h√¥tels automatique
// ============================================================================

const HOTELSBED_CONFIG = {
  apiKey: '67167daf09899646a6f16d5d6e6c6bfb',
  secret: '93a4ae2b71',
  baseUrl: 'https://api.test.hotelbeds.com/hotel-api/1.0',
  // Proxy Netlify pour √©viter CORS
  proxyUrl: '/.netlify/functions/hotels-search',
  // Fallback local pour dev
  localProxyUrl: 'http://localhost:8888/.netlify/functions/hotels-search',
  cacheExpiry: 24 * 60 * 60 * 1000, // 24h en ms
  searchRadius: 15, // km
  maxResults: 3,
  useProxy: true,
  // D√âSACTIV√â EN LOCAL - Activer quand d√©ploy√© sur Netlify avec la function
  enabled: false  // ‚Üê Mettre √† true quand tu d√©ploies sur Netlify
};

// Cache en m√©moire pour √©viter les appels r√©p√©t√©s dans la m√™me session
const hotelCache = new Map();

/**
 * G√©n√®re la signature X-Signature pour l'API Hotelsbed
 * Format: SHA256(apiKey + secret + timestamp)
 */
async function generateHotelsSignature() {
  const timestamp = Math.floor(Date.now() / 1000);
  const toHash = HOTELSBED_CONFIG.apiKey + HOTELSBED_CONFIG.secret + timestamp;
  
  // Utiliser SubtleCrypto pour SHA256
  const encoder = new TextEncoder();
  const data = encoder.encode(toHash);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  return hashHex;
}

/**
 * Formate une date en YYYY-MM-DD
 */
function formatDateISO(date) {
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, '0');
  const d = String(date.getDate()).padStart(2, '0');
  return `${y}-${m}-${d}`;
}

/**
 * Recherche des h√¥tels via l'API Hotelsbed (via proxy Netlify)
 * @param {Object} params - { lat, lon, checkIn, checkOut, cityName }
 * @returns {Promise<Array>} Liste des h√¥tels tri√©s par prix
 */
async function searchHotelsAPI(params) {
  const { lat, lon, checkIn, checkOut, cityName } = params;
  
  // Cl√© de cache
  const cacheKey = `hotel_${lat.toFixed(3)}_${lon.toFixed(3)}_${checkIn}_${checkOut}`;
  
  // V√©rifier le cache localStorage
  const cached = localStorage.getItem(`ort.${cacheKey}`);
  if (cached) {
    try {
      const data = JSON.parse(cached);
      if (Date.now() - data.timestamp < HOTELSBED_CONFIG.cacheExpiry) {
        console.log(`[HOTELS] Cache hit pour ${cityName}`);
        return data.hotels;
      }
    } catch (e) {
      // Cache invalide, on continue
    }
  }
  
  // V√©rifier le cache m√©moire
  if (hotelCache.has(cacheKey)) {
    console.log(`[HOTELS] Memory cache hit pour ${cityName}`);
    return hotelCache.get(cacheKey);
  }
  
  console.log(`[HOTELS] Recherche API pour ${cityName} (${checkIn} ‚Üí ${checkOut})`);
  
  try {
    let hotels = [];
    
    if (HOTELSBED_CONFIG.useProxy) {
      // Utiliser le proxy Netlify (√©vite CORS)
      const proxyUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
        ? HOTELSBED_CONFIG.localProxyUrl
        : HOTELSBED_CONFIG.proxyUrl;
      
      console.log(`[HOTELS] Appel proxy: ${proxyUrl}`);
      
      const response = await fetch(proxyUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          lat: lat,
          lon: lon,
          checkIn: checkIn,
          checkOut: checkOut,
          radius: HOTELSBED_CONFIG.searchRadius,
          maxResults: HOTELSBED_CONFIG.maxResults
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(`Proxy Error: ${response.status} - ${errorData.error || response.statusText}`);
      }
      
      const data = await response.json();
      hotels = data.hotels || [];
      
    } else {
      // Appel direct (peut √©chouer √† cause de CORS)
      const signature = await generateHotelsSignature();
      
      const requestBody = {
        stay: {
          checkIn: checkIn,
          checkOut: checkOut
        },
        occupancies: [{
          rooms: 1,
          adults: 2,
          children: 0
        }],
        geolocation: {
          latitude: lat,
          longitude: lon,
          radius: HOTELSBED_CONFIG.searchRadius,
          unit: 'km'
        },
        filter: {
          maxHotels: HOTELSBED_CONFIG.maxResults * 2
        }
      };
      
      const response = await fetch(`${HOTELSBED_CONFIG.baseUrl}/hotels`, {
        method: 'POST',
        headers: {
          'Api-key': HOTELSBED_CONFIG.apiKey,
          'X-Signature': signature,
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'Accept-Encoding': 'gzip'
        },
        body: JSON.stringify(requestBody)
      });
      
      if (!response.ok) {
        throw new Error(`API Error: ${response.status} ${response.statusText}`);
      }
      
      const data = await response.json();
      
      // Parser les r√©sultats
      if (data.hotels && data.hotels.hotels) {
        for (const hotel of data.hotels.hotels.slice(0, HOTELSBED_CONFIG.maxResults)) {
          let minPrice = Infinity;
          let currency = 'EUR';
          
          if (hotel.rooms) {
            for (const room of hotel.rooms) {
              if (room.rates) {
                for (const rate of room.rates) {
                  const price = parseFloat(rate.net);
                  if (price < minPrice) {
                    minPrice = price;
                    currency = rate.currency || 'EUR';
                  }
                }
              }
            }
          }
          
          hotels.push({
            code: hotel.code,
            name: hotel.name,
            category: hotel.categoryName || `${hotel.category}*`,
            stars: parseInt(hotel.category) || 3,
            price: minPrice !== Infinity ? minPrice : null,
            currency: currency,
            latitude: hotel.latitude,
            longitude: hotel.longitude
          });
        }
      }
      
      // Trier par prix
      hotels.sort((a, b) => (a.price || 9999) - (b.price || 9999));
    }
    
    // Sauvegarder en cache
    if (hotels.length > 0) {
      localStorage.setItem(`ort.${cacheKey}`, JSON.stringify({
        timestamp: Date.now(),
        hotels: hotels
      }));
      hotelCache.set(cacheKey, hotels);
    }
    
    console.log(`[HOTELS] ‚úÖ ${hotels.length} h√¥tels trouv√©s pour ${cityName}`);
    return hotels;
    
  } catch (error) {
    console.error(`[HOTELS] ‚ùå Erreur API pour ${cityName}:`, error);
    return [];
  }
}

/**
 * Recherche d'h√¥tel pour une √©tape sp√©cifique
 * Utilise les dates calcul√©es automatiquement
 */
async function searchHotelForStep(step, stepIndex) {
  if (!step || !step.nights || step.nights <= 0) {
    return null;
  }
  
  const lat = step.lat || step.latitude;
  const lon = step.lon || step.longitude;
  
  if (!lat || !lon) {
    console.warn(`[HOTELS] Pas de coordonn√©es pour ${step.name}`);
    return null;
  }
  
  // Calculer les dates d'arriv√©e/d√©part
  const startStr = (state.startDateStr || '').trim();
  if (!startStr) {
    console.warn('[HOTELS] Pas de date de d√©part d√©finie');
    return null;
  }
  
  const baseDate = new Date(startStr + 'T00:00:00');
  let offsetDays = 0;
  for (let i = 0; i < stepIndex; i++) {
    offsetDays += Number(state.steps[i]?.nights || 0);
  }
  
  const checkInDate = new Date(baseDate);
  checkInDate.setDate(checkInDate.getDate() + offsetDays);
  
  const checkOutDate = new Date(checkInDate);
  checkOutDate.setDate(checkOutDate.getDate() + step.nights);
  
  const checkIn = formatDateISO(checkInDate);
  const checkOut = formatDateISO(checkOutDate);
  
  // V√©rifier que les dates sont dans le futur
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  if (checkInDate < today) {
    console.warn(`[HOTELS] Date pass√©e pour ${step.name}, utilisation dates exemple`);
    // Utiliser des dates futures pour le test
    const futureCheckIn = new Date(today);
    futureCheckIn.setDate(futureCheckIn.getDate() + 30);
    const futureCheckOut = new Date(futureCheckIn);
    futureCheckOut.setDate(futureCheckOut.getDate() + step.nights);
    
    return searchHotelsAPI({
      lat,
      lon,
      checkIn: formatDateISO(futureCheckIn),
      checkOut: formatDateISO(futureCheckOut),
      cityName: step.name || step.place_id
    });
  }
  
  return searchHotelsAPI({
    lat,
    lon,
    checkIn,
    checkOut,
    cityName: step.name || step.place_id
  });
}

/**
 * Formate le prix avec devise
 */
function formatHotelPrice(price, currency, nights) {
  if (!price) return '‚Äî';
  
  const symbols = { EUR: '‚Ç¨', GBP: '¬£', USD: '$', CHF: 'CHF' };
  const symbol = symbols[currency] || currency;
  const perNight = Math.round(price / nights);
  
  return `${symbol}${perNight}/nuit`;
}

/**
 * G√©n√®re les √©toiles HTML
 */
function renderStars(count) {
  return '‚òÖ'.repeat(Math.min(count, 5)) + '‚òÜ'.repeat(Math.max(0, 5 - count));
}

console.log('[HOTELSBED] ‚úÖ Syst√®me charg√©');

// ============================================================================


// --- Affichage du titre #rtTitle (d√©j√† multilingue) ---
function setTitleTranslated(raw){
  const el = document.getElementById('rtTitle');
  if(!el) return;
  el.removeAttribute('data-i18n');
  el.textContent = raw || '';
}

// === Layout buttons init (header uniquement) ===
// === Layout forc√© c√¥te-√†-c√¥te (mode simple) ===
document.body.classList.add('layout-side');


/* === Toggle carte plein √©cran (persist√©) === */
(function initMapFullscreen(){
  const body = document.body;
  const btnFull = document.getElementById('btnMapFull');
  const btnExit = document.getElementById('btnMapExit');

  // I18N tooltip pour le plein √©cran
  const LANG = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  const FULLSCREEN_HELP = {
    fr: "Vous passez en plein √©cran. Survolez une √©tape pour voir son descriptif. Cliquez pour d√©finir l'ordre (1‚Üín). Double-cliquez pour retirer une √©tape. Utilisez \"Valider\" pour appliquer les changements, ou \"Quitter\" pour annuler.",
    en: "You are entering fullscreen. Hover a step to see its description. Click to set order (1‚Üín). Double-click to remove a step. Use \"Validate\" to apply changes, or \"Exit\" to cancel.",
    it: "Passi a schermo intero. Passa il mouse su una tappa per vederne la descrizione. Clicca per definire l'ordine (1‚Üín). Doppio clic per rimuovere una tappa. Usa \"Conferma\" per applicare le modifiche, o \"Esci\" per annullare.",
    es: "Pasas a pantalla completa. Pasa el rat√≥n sobre una etapa para ver su descripci√≥n. Haz clic para definir el orden (1‚Üín). Doble clic para eliminar una etapa. Usa \"Validar\" para aplicar los cambios, o \"Salir\" para cancelar.",
    pt: "Voc√™ est√° entrando em tela cheia. Passe o mouse sobre uma etapa para ver sua descri√ß√£o. Clique para definir a ordem (1‚Üín). Clique duas vezes para remover uma etapa. Use \"Validar\" para aplicar as altera√ß√µes ou \"Sair\" para cancelar.",
    ar: "ÿ£ŸÜÿ™ ÿ™ÿØÿÆŸÑ Ÿàÿ∂ÿπ ŸÖŸÑÿ° ÿßŸÑÿ¥ÿßÿ¥ÿ©. ŸÖÿ±ÿ± ŸÅŸàŸÇ ÿÆÿ∑Ÿàÿ© ŸÑÿ±ÿ§Ÿäÿ© ŸàÿµŸÅŸáÿß. ÿßŸÜŸÇÿ± ŸÑÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿ™ÿ±ÿ™Ÿäÿ® (1‚Üín). ÿßŸÜŸÇÿ± ŸÖÿ±ÿ™ŸäŸÜ ŸÑÿ•ÿ≤ÿßŸÑÿ© ÿÆÿ∑Ÿàÿ©. ÿßÿ≥ÿ™ÿÆÿØŸÖ \"ÿ™ÿ£ŸÉŸäÿØ\" ŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ÿå ÿ£Ÿà \"ÿÆÿ±Ÿàÿ¨\" ŸÑŸÑÿ•ŸÑÿ∫ÿßÿ°."
  };
  
  if (btnFull) {
    btnFull.title = FULLSCREEN_HELP[LANG] || FULLSCREEN_HELP.fr;
  }

  function applyView(mode){
    // mode: 'map' | 'normal'
    const mapOnly = (mode === 'map');
    
    // S'assurer que le mode liste n'est pas actif
    if (mapOnly) {
      body.classList.remove('view-itin-only');
      const btnListFull = document.getElementById('btnListFull');
      const btnListExit = document.getElementById('btnListExit');
      if (btnListFull) btnListFull.style.display = '';
      if (btnListExit) btnListExit.style.display = 'none';
    }
    
    body.classList.toggle('view-map-only', mapOnly);
    // on ne touche pas √† 'view-itin-only' ici
    if (btnFull) btnFull.style.display = mapOnly ? 'none' : '';
    if (btnExit) btnExit.style.display = mapOnly ? '' : 'none';
localStorage.setItem('ort.view', mapOnly ? 'map' : 'normal');
    
    // Recalcule le sizing Leaflet pour √©viter les tuiles "grises"
    // Multiple invalidations avec d√©lais progressifs pour g√©rer les transitions CSS
    if (window.map?.invalidateSize) {
      // IMPORTANT : Forcer un reflow du DOM avant invalidateSize
      const mapContainer = document.getElementById('map');
      if (mapContainer) {
        // Force le navigateur √† recalculer les dimensions CSS
        void mapContainer.offsetHeight;
      }
      
      // Imm√©diat - d√©marre le recalcul
      window.map.invalidateSize({pan: false});
      // Apr√®s transition CSS initiale (100ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 100);
      // Apr√®s transition CSS compl√®te (250ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 250);
      // Final - surtout important en mode c√¥te-√†-c√¥te (400ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 400);
      // Extra s√©curit√© (800ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 800);
    }
  }

  // Restauration (si l'utilisateur a d√©j√† activ√© le plein √©cran)
  const saved = localStorage.getItem('ort.view') || 'normal';
  applyView(saved);

  btnFull?.addEventListener('click', ()=> applyView('map'));
  btnExit?.addEventListener('click', ()=> applyView('normal'));

  // √âchap = quitter plein √©cran carte
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && body.classList.contains('view-map-only')){
      applyView('normal');
    }
  });

  // Revalide la taille √† chaque resize (utile en mobile/orientation)
  window.addEventListener('resize', ()=> {
    if (window.map?.invalidateSize) window.map.invalidateSize();
  });

  // ‚úÖ PATCH : Forcer redimensionnement apr√®s sortie plein √©cran
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      console.log('[MAP] Sortie plein √©cran ‚Üí recalcul taille forc√©');
      if (window.map?.invalidateSize) {
        let count = 0;
        const fixInterval = setInterval(() => {
          window.map.invalidateSize();
          count++;
          if (count >= 6) clearInterval(fixInterval);
        }, 150);
      }
    }
  });
})();

/* === Toggle liste plein √©cran === */
(function initListFullscreen(){
  const body = document.body;
  const btnFull = document.getElementById('btnListFull');
  const btnExit = document.getElementById('btnListExit');

  function applyListView(mode){
    // mode: 'list' | 'normal'
    const listOnly = (mode === 'list');
    
    // S'assurer que le mode carte n'est pas actif
    if (listOnly) {
      body.classList.remove('view-map-only');
      const btnMapFull = document.getElementById('btnMapFull');
      const btnMapExit = document.getElementById('btnMapExit');
      if (btnMapFull) btnMapFull.style.display = '';
      if (btnMapExit) btnMapExit.style.display = 'none';
      
      // Ajouter un header compact avec titre et bouton r√©duire
      let fullHeader = document.getElementById('listFullHeader');
      if (!fullHeader) {
        fullHeader = document.createElement('div');
        fullHeader.id = 'listFullHeader';
        fullHeader.style.cssText = 'position:fixed;top:0;left:0;right:0;height:38px;background-color:#113f7a;background-image:linear-gradient(90deg, rgba(17,63,122,0.85) 0%, rgba(17,63,122,0.6) 50%, rgba(17,63,122,0.85) 100%), url(/assets/image_index.webp);background-position:center;background-size:cover;color:#fff;display:flex;align-items:center;justify-content:space-between;z-index:10001;font-weight:600;font-size:0.9rem;padding:0 12px 0 20px;box-shadow:0 2px 8px rgba(0,0,0,0.25);';
        const title = state?.title || 'Itin√©raire';
        const stepsCount = state?.steps?.length || 0;
        const totalNights = state?.steps?.reduce((s,x) => s + (x.nights || 0), 0) || 0;
        fullHeader.innerHTML = `
          <span>${title} ‚Äî ${stepsCount} √©tapes ¬∑ ${totalNights} nuits</span>
          <button id="btnListExitHeader" style="background:rgba(255,255,255,0.95);color:#113f7a;border:none;padding:6px 14px;font-size:13px;font-weight:600;border-radius:5px;cursor:pointer;display:flex;align-items:center;gap:5px;">‚§° R√©duire</button>
        `;
        document.body.appendChild(fullHeader);
        
        // Ajouter l'√©v√©nement click au bouton
        fullHeader.querySelector('#btnListExitHeader')?.addEventListener('click', () => applyListView('normal'));
      }
      fullHeader.style.display = 'flex';
      
      // Ajuster le padding top de la section
      const section = document.querySelector('.main > section');
      if (section) section.style.paddingTop = '42px';
    } else {
      // Masquer le header compact
      const fullHeader = document.getElementById('listFullHeader');
      if (fullHeader) fullHeader.style.display = 'none';
      
      // Restaurer le padding
      const section = document.querySelector('.main > section');
      if (section) section.style.paddingTop = '';
    }
    
    body.classList.toggle('view-itin-only', listOnly);
    if (btnFull) btnFull.style.display = listOnly ? 'none' : '';
    if (btnExit) btnExit.style.display = listOnly ? 'flex' : 'none';
    
    // R√©ordonner les lignes pour affichage colonne par colonne
    const rows = document.querySelectorAll('#rows .step-row');
    const n = rows.length;
    const half = Math.ceil(n / 2);
    
    rows.forEach((row, i) => {
      if (listOnly && n > 1) {
        // Colonne par colonne : 1,2,3,4,5 en col1 puis 6,7,8,9,10 en col2
        // Position visuelle : √©l√©ments 0..half-1 aux positions paires, half..n-1 aux impaires
        if (i < half) {
          row.style.order = i * 2;
        } else {
          row.style.order = (i - half) * 2 + 1;
        }
      } else {
        row.style.order = '';
      }
    });
    
    localStorage.setItem('ort.listView', listOnly ? 'list' : 'normal');
    
    // Recalcule Leaflet quand on quitte le plein √©cran liste
    if (!listOnly && window.map?.invalidateSize) {
      setTimeout(()=> window.map.invalidateSize({pan: false}), 100);
      setTimeout(()=> window.map.invalidateSize({pan: false}), 300);
    }
  }

  // Pas de restauration auto pour la liste (toujours en mode normal au chargement)
  applyListView('normal');

  btnFull?.addEventListener('click', ()=> applyListView('list'));
  btnExit?.addEventListener('click', ()=> applyListView('normal'));

  // √âchap = quitter plein √©cran liste
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && body.classList.contains('view-itin-only')){
      applyListView('normal');
    }
  });
})();

(function waitForLeaflet(){
  if(typeof L!=='undefined'){
    console.log('‚úÖ Leaflet charg√©');
    initApp();
  }else{
    console.log('‚è≥ Attente Leaflet...');
    setTimeout(waitForLeaflet,100);
  }
})();

function initApp(){
// Appliquer les traductions i18n
if(typeof applyI18N === 'function') applyI18N();

window.closeMapPopup=()=>{
  window.popupLocked = false; // d√©verrouille si on clique sur ‚úï
  document.getElementById('mapPopup').classList.remove('show');
};

const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));
const qs=new URLSearchParams(location.search);
const CC=(qs.get('cc')||'').toUpperCase();
const ITIN_ID=decodeURIComponent(qs.get('itin')||'');
const TEMP_MODE=qs.get('from')==='temp';
const RT_KEY=qs.get('rtKey')||'';

// === Nouveaux param√®tres depuis pres_simple ===
const PARAM_LANG = qs.get('lang') || 'fr';
const PARAM_BUDGET = qs.get('budget') || 'all';
const PARAM_DEPART = qs.get('depart') || '';
const PARAM_DAYS = parseInt(qs.get('days')) || 0;
const PARAM_RYTHME = qs.get('rythme') || 'normal';
const PARAM_MAX_HOTELS = parseInt(qs.get('maxHotels')) || 99;

// Coefficients rythme (nuits uniquement)
const RYTHME_COEF = { slow: 1.25, normal: 1.0, fast: 0.75 };

// Parsing budget ‚Üí {min, max}
function parseBudgetParam(b) {
  if (!b || b === 'all') return { min: 0, max: 99999 };
  const ranges = b.split(',');
  let min = Infinity, max = 0;
  ranges.forEach(r => {
    if (r.includes('+')) { min = Math.min(min, parseInt(r)); max = 99999; }
    else if (r.includes('-')) {
      const [lo, hi] = r.split('-').map(Number);
      min = Math.min(min, lo);
      max = Math.max(max, hi);
    }
  });
  return { min: min === Infinity ? 0 : min, max };
}
const BUDGET_RANGE = parseBudgetParam(PARAM_BUDGET);

// D√©tection miles (pays anglophones)
const MILES_COUNTRIES = ['US', 'GB', 'MM', 'LR'];
function detectDistanceUnit() {
  // Utiliser CC de l'URL en priorit√©, sinon navigator.language
  const urlCC = new URLSearchParams(location.search).get('cc')?.toUpperCase();
  if(urlCC){
    return MILES_COUNTRIES.includes(urlCC) ? 'mi' : 'km';
  }
  const locale = navigator.language || 'fr-FR';
  const cc = locale.split('-')[1]?.toUpperCase();
  return MILES_COUNTRIES.includes(cc) ? 'mi' : 'km';
}

// Appliquer la langue
if (PARAM_LANG) {
  document.documentElement.lang = PARAM_LANG;
  if (PARAM_LANG === 'ar') document.body.setAttribute('dir', 'rtl');
}

let PHOTOS_CACHE={};
const state={
  title:'Roadtrip', country:'XX', targetNights:0, steps:[],
  _rawItinsObj:null, _rawPlacesObj:null, 
  distanceUnit: detectDistanceUnit(),
  startDateStr: PARAM_DEPART || localStorage.getItem('ort.rtStartDate') || '',
  budgetRange: BUDGET_RANGE,
  rythme: PARAM_RYTHME,
  rythmeCoef: RYTHME_COEF[PARAM_RYTHME] || 1.0,
  requestedDays: PARAM_DAYS,
  maxHotels: PARAM_MAX_HOTELS
};

let TOTALS={km:0, minutes:0, travelDays:0};

const sumNights = ()=> state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
const fmtKm = (km)=> state.distanceUnit==='mi' ? `${Math.round(km*0.621371)} mi` : `${km} km`;
const fmtDur = (min)=>{ const h=Math.floor(min/60), m=min%60; return `${h} h ${m} min`; };

// === Stay22 Affiliate Integration ===
const STAY22_CONFIG = {
  AID: 'oneroadtrip',
  LMAID: '692f0c75b2478d16bb9b22fa',
  BASE_ALLEZ: 'https://www.stay22.com/allez/roam',
  BASE_MAP: 'https://www.stay22.com/embed/gm',
  MAINCOLOR: '113f7a',
  MARKERIMAGE: 'https://upload.wikimedia.org/wikipedia/commons/c/ca/1x1.png'
};

// Calculer dates check-in/checkout pour une √©tape (index)
function getStay22Dates(stepIndex) {
  const startStr = (state.startDateStr || '').trim();
  if (!startStr) return null;
  
  const base = new Date(startStr + 'T00:00:00');
  let offset = 0;
  for (let i = 0; i < stepIndex; i++) {
    offset += Number(state.steps[i]?.nights || 0);
  }
  
  const checkin = new Date(base);
  checkin.setDate(checkin.getDate() + offset);
  
  const nights = Number(state.steps[stepIndex]?.nights || 1);
  const checkout = new Date(checkin);
  checkout.setDate(checkout.getDate() + nights);
  
  return {
    checkin: checkin.toISOString().split('T')[0],
    checkout: checkout.toISOString().split('T')[0]
  };
}

// G√©n√©rer l'URL Stay22 Allez pour une √©tape
function getStay22AllezUrl(step, stepIndex) {
  const lat = step.lat || (step.coords && step.coords[0]) || null;
  const lng = step.lon || (step.coords && step.coords[1]) || null;
  const cityName = step.name || step.place_id?.split('::')[1] || '';
  
  // Besoin de coords OU d'une adresse
  if (!lat && !lng && !cityName) return null;
  
  const itinId = state._rawItinsObj?.itins?.[0]?.itin_id || 'unknown';
  const campaign = `ort_${itinId.replace(/::/g, '_')}_step${stepIndex + 1}`;
  
  const dates = getStay22Dates(stepIndex);
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.AID,
    campaign: campaign
  });
  
  // Pr√©f√©rer lat/lng si disponible, sinon address
  if (lat && lng) {
    params.append('lat', lat.toFixed(6));
    params.append('lng', lng.toFixed(6));
  } else if (cityName) {
    params.append('address', cityName + ' ' + (state.country || ''));
  }
  
  // Dates si disponibles
  if (dates) {
    params.append('checkin', dates.checkin);
    params.append('checkout', dates.checkout);
  }
  
  return `${STAY22_CONFIG.BASE_ALLEZ}?${params.toString()}`;
}

// G√©n√©rer l'URL Stay22 Map pour UNE √©tape
function getStay22MapUrl(step, stepIndex) {
  if (!step.lat || !step.lon) return null;
  
  const itinId = state._rawItinsObj?.itins?.[0]?.itin_id || 'unknown';
  const campaign = `ort_${itinId.replace(/::/g, '_')}_step${stepIndex + 1}`;
  
  const dates = getStay22Dates(stepIndex);
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.AID,
    lat: step.lat.toFixed(6),
    lng: step.lon.toFixed(6),
    campaign: campaign,
    maincolor: STAY22_CONFIG.MAINCOLOR,
    markerimage: STAY22_CONFIG.MARKERIMAGE
  });
  
  // Ajouter le nom du lieu
  if (step.name) {
    params.append('venue', step.name);
  }
  
  // Ajouter dates si disponibles
  if (dates) {
    params.append('checkin', dates.checkin);
    params.append('checkout', dates.checkout);
  }
  
  return `${STAY22_CONFIG.BASE_MAP}?${params.toString()}`;
}

// G√©n√©rer l'URL Stay22 Map pour l'itin√©raire complet (centre)
function getStay22MapUrlCenter() {
  const validSteps = state.steps.filter(s => s.lat && s.lon);
  if (validSteps.length === 0) return null;
  
  const centerLat = validSteps.reduce((s, x) => s + x.lat, 0) / validSteps.length;
  const centerLng = validSteps.reduce((s, x) => s + x.lon, 0) / validSteps.length;
  
  const itinId = state._rawItinsObj?.itins?.[0]?.itin_id || 'unknown';
  const campaign = `ort_${itinId.replace(/::/g, '_')}_map`;
  
  const dates = getStay22Dates(0);
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.AID,
    lat: centerLat.toFixed(6),
    lng: centerLng.toFixed(6),
    campaign: campaign,
    maincolor: STAY22_CONFIG.MAINCOLOR,
    markerimage: STAY22_CONFIG.MARKERIMAGE
  });
  
  if (dates) {
    params.append('checkin', dates.checkin);
    params.append('checkout', dates.checkout);
  }
  
  return `${STAY22_CONFIG.BASE_MAP}?${params.toString()}`;
}

// === Dates (point de d√©part + plage par √©tape)
function getStartDate(){
  const s = (state.startDateStr || '').trim();
  return s ? new Date(s+'T00:00:00') : null;
}
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function fmtD(d){
  if(!d) return '‚Äî';
  const lang=(document.documentElement.lang||'fr');
  return d.toLocaleDateString(lang, { day:'2-digit', month:'short' });
}
function stepDateRange(idx){
  const base = getStartDate();
  if(!base) return null;
  let offset = 0;
  for(let i=0;i<idx;i++){ offset += Number(state.steps[i]?.nights||0); }
  const n = Number(state.steps[idx]?.nights||0);
  const start = addDays(base, offset);
  const end   = addDays(start, Math.max(0, n-1));
  return {start, end};
}
// Tooltip i18n compact
function dateTipLabel(){
  const lang=(document.documentElement.lang||'fr').slice(0,2);
  const MAP={
    fr:'Premi√®re/derni√®re nuit',
    en:'First/last night',
    it:'Prima/ultima notte',
    es:'Primera/√∫ltima noche',
    pt:'Primeira/√∫ltima noite',
    ar:'ÿ£ŸàŸÑ/ÿ¢ÿÆÿ± ŸÑŸäŸÑÿ©'
  };
  return MAP[lang]||MAP.fr;
}

async function loadPhotosJSON(){
  try{
    const r=await fetch('./data/photos-json/photos_lieux.json',{cache:'no-store'});
    if(r.ok) PHOTOS_CACHE=await r.json()||{};
  }catch(e){console.error('Photos:',e)}
}

function getPhotosForPlace(pid){return (PHOTOS_CACHE[pid]||{}).photos||[]}

// Convertir un nom en slug pour matcher les place_id (format CC::nom-en-slug)
function toSlug(name) {
  if (!name) return '';
  return name
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/['']/g, '-')
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

// Trouver les photos pour un lieu (essaie plusieurs formats de cl√©)
function findPhotosForPlace(name, cc) {
  if (!name || !PHOTOS_CACHE) return [];
  
  const slug = toSlug(name);
  const ccUp = (cc || '').toUpperCase();
  
  const keys = [
    `${ccUp}::${slug}`,
    `${ccUp}::${name.toLowerCase()}`,
    slug,
    name.toLowerCase()
  ];
  
  for (const key of keys) {
    if (PHOTOS_CACHE[key]?.photos?.length) {
      return PHOTOS_CACHE[key].photos;
    }
  }
  
  // Recherche partielle par nom
  const found = Object.keys(PHOTOS_CACHE).find(k => {
    const kName = k.split('::').pop() || k;
    return kName === slug || kName.includes(slug) || slug.includes(kName);
  });
  
  if (found && PHOTOS_CACHE[found]?.photos?.length) {
    return PHOTOS_CACHE[found].photos;
  }
  
  return [];
}

// --- DEBUG POPUP PHOTOS ---
async function ensurePhotos(place) {
  console.log('[ensurePhotos] place', place);
  const cache = (window.photosLieux = window.photosLieux || {});
  const hit = cache[place.place_id]?.photos || [];
  if (hit.length >= 2) {
    console.log('[ensurePhotos] cache hit', hit.length);
    return hit;
  }

  try {
    const q = new URLSearchParams({
      country: (place.place_id || '').split('::')[0],
      place_id: place.place_id,
      name: place.name || place.title || (place.place_id || '').split('::').pop()
    });
    const apiUrl = (localStorage.ORT_PHOTOS_API || 'http://localhost:8057') + '/photos/place?' + q.toString();
    console.log('[ensurePhotos] fetch', apiUrl);
    const r = await fetch(apiUrl, { cache: 'no-store' });
    const d = await r.json().catch(e => {
      console.error('[ensurePhotos] JSON parse error', e);
      return { ok: false };
    });
    console.log('[ensurePhotos] response', d);

    if (d.ok && Array.isArray(d.photos) && d.photos.length >= 2) {
      cache[place.place_id] = { name: place.name || '', photos: d.photos };
      return d.photos;
    }
    return hit;
  } catch (err) {
    console.error('[ensurePhotos] fetch failed', err);
    return hit;
  }
}

async function renderPopup(place) {
  try {
    const step = place; // normalise: les blocs "visits/activities" lisent `step`
    console.log('[renderPopup] start', place);
    let photos = (window.photosLieux && window.photosLieux[place.place_id]?.photos) || [];
    if (photos.length < 2) photos = await ensurePhotos(place);
    console.log('[renderPopup] photos', photos);
    fillPhotos(photos);
  } catch (e) {
    console.error('[renderPopup] error', e);
  }
}


async function loadJSON(path){
  try{
    const r=await fetch(path,{cache:'no-store'});
    if(!r.ok) return null;
    const ct = r.headers.get('content-type')||'';
    if(!ct.includes('application/json')) {
      console.warn('[loadJSON] Not JSON:', path, 'content-type:', ct);
      return null;
    }
    return await r.json();
  }catch(e){console.error('[loadJSON] Error:',path,e);return null}
}

function isComposedId(id){return typeof id==='string'&&id.startsWith('COMPOSED::')}
function parseComposedIds(id){if(!isComposedId(id))return[];return id.replace('COMPOSED::','').split('+').map(decodeURIComponent).filter(Boolean)}
// D√©tection du mode tactile
const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);

let PLACES_INDEX=null;
// === Expose globals pour les scripts header (date de d√©part etc.)
window.state = state;

// === Fonction helper pour charger avec fallback langue ===
async function loadWithLangFallback(baseUrl, lang) {
  // Essayer dans l'ordre : langue demand√©e ‚Üí EN ‚Üí FR ‚Üí ancien format
  const langOrder = [lang, 'en', 'fr'].filter((v, i, a) => a.indexOf(v) === i); // unique
  
  for (const tryLang of langOrder) {
    const url = baseUrl.replace('.json', `-${tryLang}.json`);
    const result = await loadJSON(url);
    if (result) {
      console.log(`[LOAD] ‚úÖ Charg√©: ${url}`);
      return { data: result, lang: tryLang };
    }
  }
  
  // Fallback: ancien format sans suffixe
  const result = await loadJSON(baseUrl);
  if (result) {
    console.log(`[LOAD] ‚ö†Ô∏è Fallback ancien format: ${baseUrl}`);
    return { data: result, lang: 'fr' };
  }
  
  return null;
}

async function ensurePlacesIndex(){
  const cc = (CC || state.cc || state.country || '').toUpperCase();
  const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
  
  // Nouveau format avec suffixe langue
  const basePath = `./data/Roadtripsprefabriques/countries/${cc.toLowerCase()}/${cc.toLowerCase()}.places.master.json`;
  const result = await loadWithLangFallback(basePath, lang);
  
  if(result && result.data){
    const obj = result.data;
    const arr = Array.isArray(obj) ? obj : (obj.places||[]);
    PLACES_INDEX={};
    arr.forEach(pl=>{
      const pid=pl.place_id||pl.id;
      if(!pid) return;
      const visits = Array.isArray(pl.visits) ? pl.visits.map(v => (typeof v==='string'? {text:v} : v)) : [];
      const activities = Array.isArray(pl.activities) ? pl.activities.map(a => (typeof a==='string'? {text:a} : a)) : [];
      PLACES_INDEX[pid] = {
        lat:Number(pl.lat)||null,
        lon:Number(pl.lon)||Number(pl.lng)||null,
        name:pl.name||pl.title||'',
        visits,
        activities,
        rating: pl.rating || 1,
        suggested_days: pl.suggested_days || 1
      };
    });
    console.log(`[PLACES] ‚úÖ Master charg√© (${result.lang}): ${arr.length} lieux avec ratings`);
    
    // Injecter les ratings dans les steps existants
    if (state.steps && state.steps.length > 0) {
      state.steps.forEach(step => {
        if (step.place_id && PLACES_INDEX[step.place_id]) {
          step.rating = PLACES_INDEX[step.place_id].rating || 0;
        }
      });
      console.log(`[PLACES] ‚úÖ Ratings inject√©s dans ${state.steps.length} √©tapes`);
    }
    
    return;
  }
  
  PLACES_INDEX={};
}
function coordsFromMaster(pid){
  if(!PLACES_INDEX||!pid) return {lat:null,lon:null,name:''};
  const m=PLACES_INDEX[pid];
  return m?{lat:m.lat,lon:m.lon,name:m.name}:{lat:null,lon:null,name:''};
}


async function loadItin(){
  const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
  const basePath = `./data/Roadtripsprefabriques/countries/${CC.toLowerCase()}/${CC}.itins.modules.json`;
  const result = await loadWithLangFallback(basePath, lang);
  
  if(!result || !result.data) return null;
  
  const j = result.data;
  console.log(`[ITIN] Charg√© en ${result.lang}`);
  
  // Stocker la langue du fichier source
  state._sourceLanguage = result.lang;
  
  const itins=(j.itineraries||j.modules||[]).map(x=>({ ...x, __id:x.itin_id||x.id||x.slug||'', __title:x.title||x.name||'Roadtrip', __lang: x.language || result.lang }));
  if(isComposedId(ITIN_ID)){
    const ids=parseComposedIds(ITIN_ID);
    const found=ids.map(id=>itins.find(x=>x.__id===id)).filter(Boolean);
    if(!found.length)return null;
    let days_plan=[],places=[],titleParts=[];
    for(const it of found){
      titleParts.push(it.__title||'RT');
      if(Array.isArray(it.days_plan)&&it.days_plan.length)days_plan=days_plan.concat(it.days_plan);
      else if(Array.isArray(it.places)&&it.places.length)places=places.concat(it.places);
    }
    return{__id:`COMPOSED::${ids.join('+')}`,__title:titleParts.join(' + '),title:titleParts.join(' + '),days_plan:days_plan.length?days_plan:undefined,places:(!days_plan.length&&places.length)?places:undefined};
  }
  return itins.find(x=>x.__id===ITIN_ID)||null;
}


async function initFromItin(it){
  // === CR√âATEUR CHECK ===
  const isCreator = it.themes?.includes?.('creator') || it.themes === 'creator';
  window.IS_CREATOR = isCreator;
  
  if (isCreator) {
    document.body.classList.add('creator-mode');
    const creatorSection = document.getElementById('creatorSection');
    if (creatorSection) {
      // Afficher la section
      creatorSection.style.display = 'flex';
      
      // Remplir les donn√©es
      const logoEl = document.getElementById('creatorLogo');
      const nameEl = document.getElementById('creatorName');
      const bioEl = document.getElementById('creatorBio');
      const linkEl = document.getElementById('creatorLink');
      
      if (logoEl && it.creator_logo) logoEl.src = it.creator_logo;
      if (nameEl && it.creator_name) nameEl.textContent = it.creator_name;
      if (bioEl && it.creator_bio) bioEl.textContent = it.creator_bio;
      if (linkEl && it.creator_link_in_bio) {
        linkEl.href = it.creator_link_in_bio;
      } else if (linkEl) {
        linkEl.style.display = 'none';
      }
      
      console.log('üé® [CREATOR] Mode cr√©ateur activ√©');
    }
  } else {
    document.body.classList.remove('creator-mode');
  }
  
  await ensurePlacesIndex();
  
  // R√©cup√©rer estimated_days_base et pacing_rules si pr√©sents
  const estimatedDaysBase = it.estimated_days_base || 0;
  state._estimatedDaysBase = estimatedDaysBase;
  state._pacingRules = it.pacing_rules || null;
  
  // DEBUG
  console.log('üîç [COHERENCE] estimatedDaysBase:', estimatedDaysBase);
  console.log('üîç [COHERENCE] state.requestedDays:', state.requestedDays);
  console.log('üîç [COHERENCE] state.rythmeCoef:', state.rythmeCoef);
  console.log('üîç [COHERENCE] it.estimated_days_base:', it.estimated_days_base);
  console.log('üîç [COHERENCE] PARAM_DAYS:', PARAM_DAYS);
  
  let steps=[];
  if(Array.isArray(it.days_plan)&&it.days_plan.length){
    for(const d of it.days_plan){
      const pid=d.night?.place_id||'';
      const coords=d.night?.coords||[];
      let lat=coords[0]??null;
      let lon=coords[1]??null;

      // Fallback : si pas de coords dans l'itin, on prend celles du master
      if((lat==null||lon==null) && pid){
        const c=coordsFromMaster(pid);
        if(c.lat!=null && c.lon!=null){ lat=c.lat; lon=c.lon; }
      }

      let name='';
      if(pid){
        const parts=pid.split('::');
        name=parts[1]?parts[1].replace(/-/g,' ').replace(/\b\w/g,l=>l.toUpperCase()):pid;
      }
      
      // R√©cup√©rer donn√©es du master
      const masterData = PLACES_INDEX[pid] || {};
      const rating = masterData.rating || 1;
      const suggestedDays = masterData.suggested_days || 1;
      
      // Stocker temporairement pour calcul proportionnel apr√®s
      const visits=Array.isArray(d.visits)?d.visits.map(v=>typeof v==='string'?{text:v}:v):[];
      const activities=Array.isArray(d.activities)?d.activities.map(a=>typeof a==='string'?{text:a}:a):[];
      
      // R√©cup√©rer to_next_leg (trajet vers √©tape suivante)
      const toNextLeg = d.to_next_leg || null;
      
      steps.push({
        place_id:pid,name,lat,lon,
        nights: suggestedDays, // temporaire, sera ajust√©
        _suggestedDays: suggestedDays, // garder l'original
        _driveMinToNext: toNextLeg?.drive_min || 0,
        visits,activities,
        images:getPhotosForPlace(pid),
        description:visits.map(v=>v.text||v).join('. '),
        rating,
        suggested_days: suggestedDays,
        to_next_leg: toNextLeg
      });
    }
  }else if(Array.isArray(it.places)&&it.places.length){
    steps=it.places.map(p=>{
      const pid=p.place_id||p.id||p.slug||'';
      const masterData = PLACES_INDEX[pid] || {};
      const rating = masterData.rating || p.rating || 1;
      const suggestedDays = masterData.suggested_days || 1;
      const rawNights = suggestedDays * state.rythmeCoef;
      const nights = Math.max(1, Math.round(rawNights));
      return{
        place_id:pid,
        name:p.name||p.title||'',
        lat:Number(p.lat)||null,
        lon:Number(p.lon)||null,
        nights,
        visits:p.visits||[],
        activities:p.activities||[],
        images:getPhotosForPlace(pid),
        description:'',
        rating,
        suggested_days: suggestedDays,
        to_next_leg: null
      };
    });
  }
  
  
  // === FONCTION DISTANCE ROUTE (OSRM prioritaire, haversine √ó 1.3 fallback) ===
  function getRouteDistance(step1, step2) {
    // Si step1 a la distance OSRM vers step2 (√©tape suivante)
    if (step1._osrmDistanceKm && step1._osrmDistanceKm > 0) {
      return step1._osrmDistanceKm;
    }
    // Sinon haversine √ó 1.3 (facteur route vs vol d'oiseau)
    if (step1.lat && step1.lon && step2.lat && step2.lon) {
      return haversineDistance(step1.lat, step1.lon, step2.lat, step2.lon) * 1.3;
    }
    return 50; // D√©faut
  }
  
  // Distance entre 2 √©tapes quelconques (pas forc√©ment cons√©cutives)
  function getDistanceBetween(s1, s2) {
    if (s1.lat && s1.lon && s2.lat && s2.lon) {
      return haversineDistance(s1.lat, s1.lon, s2.lat, s2.lon) * 1.3;
    }
    return 50;
  }
  
  // === CALCUL INTELLIGENT DES NUITS ===
  
  // === BONUS TRANSPORT : longs trajets = demi-journ√©e ou journ√©e perdue ===
  // drive_min ‚â§ 180 (3h) : 0 bonus
  // drive_min 181-300 (3-5h) : +0.5 jour
  // drive_min > 300 (5h+) : +1.0 jour
  steps.forEach((step, idx) => {
    const driveMin = step._driveMinToNext || 0;
    let transportBonus = 0;
    if (driveMin > 300) {
      transportBonus = 1.0;
    } else if (driveMin > 180) {
      transportBonus = 0.5;
    }
    step._transportBonus = transportBonus;
    step._effectiveDays = (step._suggestedDays || step.suggested_days || 1) + transportBonus;
    if (transportBonus > 0) {
      console.log(`[TRANSPORT] ${step.name}: ${driveMin}min ‚Üí +${transportBonus}j bonus`);
    }
  });
  
  // 1. Calculer les moyennes pour r√©f√©rence (avec bonus transport)
  const totalSuggested = steps.reduce((s, x) => s + (x._effectiveDays || x._suggestedDays || x.suggested_days || 1), 0);
  const avgRating = steps.reduce((s, x) => s + (x.rating || 5), 0) / steps.length;
  const targetDays = state.requestedDays > 0 ? state.requestedDays : (estimatedDaysBase > 0 ? estimatedDaysBase : Math.ceil(totalSuggested) + 1);
  
  // 2. Calculer la distance totale et moyenne par √©tape (√ó 1.3 pour approcher distance route)
  let totalDistanceKm = 0;
  for(let i = 0; i < steps.length - 1; i++){
    const s1 = steps[i], s2 = steps[i + 1];
    if(s1.lat && s1.lon && s2.lat && s2.lon){
      const d = haversineDistance(s1.lat, s1.lon, s2.lat, s2.lon) * 1.3;
      steps[i]._distanceToNext = d;
      totalDistanceKm += d;
    } else {
      steps[i]._distanceToNext = 50; // D√©faut
      totalDistanceKm += 50;
    }
  }
  steps[steps.length - 1]._distanceToNext = 0;
  const avgDistanceKm = totalDistanceKm / Math.max(1, steps.length - 1);
  
  console.log(`[NIGHTS] Total sugg√©r√©: ${totalSuggested}j, Target: ${targetDays}j, Avg rating: ${avgRating.toFixed(1)}, Avg distance: ${avgDistanceKm.toFixed(0)}km`);
  
  // 2.5. FUSIONNER les √©tapes identiques (m√™me place_id)
  const mergedSteps = [];
  const placeMap = new Map(); // place_id ‚Üí index dans mergedSteps
  
  steps.forEach((step, idx) => {
    const placeId = step.place_id;
    
    if (!placeId || !placeMap.has(placeId)) {
      // Premi√®re occurrence ou pas de place_id ‚Üí ajouter
      placeMap.set(placeId, mergedSteps.length);
      mergedSteps.push(step);
    } else {
      // Doublon d√©tect√© ‚Üí fusionner avec la premi√®re occurrence
      const firstIdx = placeMap.get(placeId);
      const firstStep = mergedSteps[firstIdx];
      
      console.log(`[FUSION] Fusion de "${step.name}" (idx ${idx}) avec premi√®re occurrence (idx ${firstIdx})`);
      
      // Cumuler les visites
      if (step.visits && step.visits.length > 0) {
        if (!firstStep.visits) firstStep.visits = [];
        step.visits.forEach(v => {
          if (!firstStep.visits.includes(v)) {
            firstStep.visits.push(v);
          }
        });
      }
      
      // Cumuler les activit√©s
      if (step.activities && step.activities.length > 0) {
        if (!firstStep.activities) firstStep.activities = [];
        step.activities.forEach(a => {
          if (!firstStep.activities.includes(a)) {
            firstStep.activities.push(a);
          }
        });
      }
      
      // Cumuler les jours sugg√©r√©s
      const stepDays = step._suggestedDays || step.suggested_days || 0;
      const firstDays = firstStep._suggestedDays || firstStep.suggested_days || 0;
      firstStep._suggestedDays = firstDays + stepDays;
      firstStep.suggested_days = firstDays + stepDays;
      
      console.log(`[FUSION] ‚Üí Jours cumul√©s: ${firstDays} + ${stepDays} = ${firstStep._suggestedDays}j, visites: ${firstStep.visits?.length || 0}, activit√©s: ${firstStep.activities?.length || 0}`);
    }
  });
  
  // Remplacer les steps par les steps fusionn√©es
  if (mergedSteps.length < steps.length) {
    console.log(`[FUSION] ‚úÖ ${steps.length} √©tapes ‚Üí ${mergedSteps.length} √©tapes apr√®s fusion`);
    state.steps = mergedSteps;
    steps = mergedSteps;
    
    // Recalculer les distances apr√®s fusion (√ó 1.3 pour approcher distance route)
    totalDistanceKm = 0;
    for(let i = 0; i < steps.length - 1; i++){
      const s1 = steps[i], s2 = steps[i + 1];
      if(s1.lat && s1.lon && s2.lat && s2.lon){
        const d = haversineDistance(s1.lat, s1.lon, s2.lat, s2.lon) * 1.3;
        steps[i]._distanceToNext = d;
        totalDistanceKm += d;
      } else {
        steps[i]._distanceToNext = 50;
        totalDistanceKm += 50;
      }
    }
    steps[steps.length - 1]._distanceToNext = 0;
    
    // Recalculer totalSuggested et targetDays apr√®s fusion
    const newTotalSuggested = steps.reduce((s, x) => s + (x._suggestedDays || x.suggested_days || 1), 0);
    const newTargetDays = state.requestedDays > 0 ? state.requestedDays : (estimatedDaysBase > 0 ? estimatedDaysBase : newTotalSuggested);
    console.log(`[FUSION] Nouveau total sugg√©r√©: ${newTotalSuggested}j, Target: ${newTargetDays}j`);
  }
  
  // ‚ö†Ô∏è NETTOYER les anciens champs hub/satellite (peuvent venir du JSON)
  steps.forEach(step => {
    delete step._isHub;
    delete step._isSatellite;
    delete step._satellites;
    delete step._hubGroup;
    delete step._mergedInto;
  });
  
  // 3. Identifier les HUBS (grandes villes bien not√©es)
  // Un hub = rating >= moyenne ET (suggested_days >= 2 OU dans le top 30% des suggestions)
  const sortedBySuggested = [...steps].sort((a, b) => (b._suggestedDays || 1) - (a._suggestedDays || 1));
  const top30Threshold = sortedBySuggested[Math.floor(steps.length * 0.3)]?._suggestedDays || 2;
  
  const hubs = [];
  steps.forEach((step, idx) => {
    const suggestedDays = step._suggestedDays || 1;
    const isHub = (step.rating || 5) >= avgRating && suggestedDays >= Math.min(1.5, top30Threshold);
    step._isHub = isHub;
    if(isHub) hubs.push(idx);
  });
  console.log(`[NIGHTS] ${hubs.length} hubs identifi√©s (seuil: ${Math.min(1.5, top30Threshold).toFixed(1)}j):`, hubs.map(i => `${steps[i].name}(${steps[i]._suggestedDays}j)`).join(', '));
  
  // 3a-bis. SI AUCUN HUB D√âTECT√â ‚Üí Cr√©er un hub par d√©faut (meilleur rating)
  if(hubs.length === 0 && steps.length > 0){
    // Trouver l'√©tape avec le meilleur rating
    let bestIdx = 0;
    let bestRating = steps[0].rating || 0;
    steps.forEach((s, idx) => {
      if((s.rating || 0) > bestRating){
        bestRating = s.rating || 0;
        bestIdx = idx;
      }
    });
    
    steps[bestIdx]._isHub = true;
    steps[bestIdx]._hubGroup = bestIdx;
    steps[bestIdx]._satellites = [];
    hubs.push(bestIdx);
    console.log(`[NIGHTS] ‚ö†Ô∏è Aucun hub naturel ‚Üí "${steps[bestIdx].name}" promu hub par d√©faut (rating=${bestRating.toFixed(1)})`);
  }
  
  // 3b. FUSION DES HUBS TROP PROCHES (< 30km)
  // UNIQUEMENT si les hubs sont CONS√âCUTIFS dans l'itin√©raire (pas d'autre hub entre eux)
  const HUB_MERGE_DISTANCE = 30; // km - seuil de fusion
  const hubsToMerge = new Set();
  
  // Parcourir les hubs dans l'ordre de l'itin√©raire
  for(let i = 0; i < hubs.length - 1; i++){
    if(hubsToMerge.has(hubs[i])) continue;
    
    // Ne comparer qu'avec le hub SUIVANT dans l'itin√©raire
    const j = i + 1;
    if(hubsToMerge.has(hubs[j])) continue;
    
    const hub1 = steps[hubs[i]];
    const hub2 = steps[hubs[j]];
    
    // Calculer distance route (haversine √ó 1.3)
    const dist = getDistanceBetween(hub1, hub2);
    
    if(dist < HUB_MERGE_DISTANCE){
        // Garder le hub avec le meilleur rating, puis days si √©galit√©
        const rating1 = hub1.rating || 3;
        const rating2 = hub2.rating || 3;
        const days1 = hub1._suggestedDays || 1;
        const days2 = hub2._suggestedDays || 1;
        const hub1Wins = rating1 > rating2 || (rating1 === rating2 && days1 >= days2);
        
        if(hub1Wins){
          // hub2 devient satellite de hub1
          hub2._isHub = false;
          hub2._mergedInto = hubs[i];
          hubsToMerge.add(hubs[j]);
          console.log(`[NIGHTS] FUSION: "${hub2.name}" (rating=${rating2}, days=${days2}) ‚Üí absorb√© par "${hub1.name}" (rating=${rating1}, days=${days1}, dist=${dist.toFixed(1)}km)`);
        } else {
          // hub1 devient satellite de hub2
          hub1._isHub = false;
          hub1._mergedInto = hubs[j];
          hubsToMerge.add(hubs[i]);
          console.log(`[NIGHTS] FUSION: "${hub1.name}" (rating=${rating1}, days=${days1}) ‚Üí absorb√© par "${hub2.name}" (rating=${rating2}, days=${days2}, dist=${dist.toFixed(1)}km)`);
        }
    }
  }
  
  // Mettre √† jour la liste des hubs
  const finalHubs = hubs.filter(h => !hubsToMerge.has(h));
  console.log(`[NIGHTS] Apr√®s fusion: ${finalHubs.length} hubs finaux:`, finalHubs.map(i => steps[i].name).join(', '));
  
  // 4. Regrouper les petites villes proches autour des hubs
  // Calcul du seuil de proximit√© adaptatif bas√© sur la distance totale
  const PROXIMITY_BASE = 40; // km de base
  const PROXIMITY_SCALE = 0.015; // facteur d'√©chelle (1.5% de la distance totale)
  const proximityThreshold = Math.min(60, Math.max(25, 
    PROXIMITY_BASE + totalDistanceKm * PROXIMITY_SCALE
  ));
  const PROXIMITY_RATIO = proximityThreshold / avgDistanceKm;
  const PROXIMITY_MAX_KM = proximityThreshold;
  console.log(`[NIGHTS] Seuil proximit√© satellite: ${PROXIMITY_MAX_KM.toFixed(0)}km (distance totale: ${totalDistanceKm.toFixed(0)}km)`);
  
  // PASSE 1 : Initialiser tous les hubs d'abord
  steps.forEach((step, idx) => {
    if(step._isHub) {
      step._hubGroup = idx;
      step._satellites = [];
      console.log(`[NIGHTS] Init hub "${step.name}" (idx=${idx})`);
    }
  });
  
  // PASSE 1b : Rattacher les hubs fusionn√©s comme satellites
  steps.forEach((step, idx) => {
    if(step._mergedInto !== undefined){
      // Suivre la cha√Æne _mergedInto jusqu'au hub final
      let finalMaster = step._mergedInto;
      let safetyCounter = 0;
      while(steps[finalMaster]._mergedInto !== undefined && safetyCounter < 20){
        finalMaster = steps[finalMaster]._mergedInto;
        safetyCounter++;
      }
      const masterHub = steps[finalMaster];
      step._hubGroup = finalMaster;
      step._isSatellite = true;
      if(!masterHub._satellites) masterHub._satellites = [];
      masterHub._satellites.push(idx);
      console.log(`[NIGHTS] Hub fusionn√© "${step.name}" ‚Üí satellite de "${masterHub.name}"`);
    }
  });
  
  // PASSE 2 : D√©tecter les satellites (apr√®s que tous les hubs soient initialis√©s)
  // R√àGLE IMPORTANTE : un satellite ne peut √™tre rattach√© qu'√† un hub ADJACENT
  // (pas de hub entre l'√©tape et son hub de rattachement)
  // NOTE: Un hub fusionn√© (_mergedInto) compte aussi comme barri√®re
  steps.forEach((step, idx) => {
    if(step._isHub || step._mergedInto !== undefined) return; // Skip les hubs et hubs fusionn√©s
    
    // Chercher le hub le plus proche ADJACENT (sans autre hub/hub fusionn√© entre)
    let hubBefore = null;
    let distBefore = 0;
    let hubAfter = null;
    let distAfter = 0;
    
    // Chercher en arri√®re (premier hub OU hub fusionn√© rencontr√©)
    for(let h = idx - 1; h >= 0; h--){
      // Un hub fusionn√© compte comme barri√®re - on utilise son hub ma√Ætre final
      if(steps[h]._mergedInto !== undefined){
        // Suivre la cha√Æne _mergedInto jusqu'au hub final
        let masterIdx = steps[h]._mergedInto;
        let safetyCounter = 0;
        while(steps[masterIdx]._mergedInto !== undefined && safetyCounter < 20){
          masterIdx = steps[masterIdx]._mergedInto;
          safetyCounter++;
        }
        for(let k = masterIdx; k < idx; k++) distBefore += steps[k]._distanceToNext || 50;
        if(distBefore < PROXIMITY_MAX_KM){
          hubBefore = masterIdx;
        }
        break; // Barri√®re trouv√©e
      }
      if(steps[h]._isHub){
        // Calculer distance cumulative jusqu'√† ce hub
        for(let k = h; k < idx; k++) distBefore += steps[k]._distanceToNext || 50;
        if(distBefore < PROXIMITY_MAX_KM){
          hubBefore = h;
        }
        break; // Premier hub trouv√©, on arr√™te
      }
    }
    
    // Chercher en avant (premier hub OU hub fusionn√© rencontr√©)
    for(let h = idx + 1; h < steps.length; h++){
      if(steps[h]._mergedInto !== undefined){
        // Suivre la cha√Æne _mergedInto jusqu'au hub final
        let masterIdx = steps[h]._mergedInto;
        let safetyCounter = 0;
        while(steps[masterIdx]._mergedInto !== undefined && safetyCounter < 20){
          masterIdx = steps[masterIdx]._mergedInto;
          safetyCounter++;
        }
        for(let k = idx; k < masterIdx; k++) distAfter += steps[k]._distanceToNext || 50;
        if(distAfter < PROXIMITY_MAX_KM){
          hubAfter = masterIdx;
        }
        break; // Barri√®re trouv√©e
      }
      if(steps[h]._isHub){
        for(let k = idx; k < h; k++) distAfter += steps[k]._distanceToNext || 50;
        if(distAfter < PROXIMITY_MAX_KM){
          hubAfter = h;
        }
        break; // Premier hub trouv√©, on arr√™te
      }
    }
    
    // Choisir le hub le plus proche (avant ou apr√®s)
    let nearestHub = null;
    let nearestDist = Infinity;
    
    if(hubBefore !== null && distBefore < nearestDist){
      nearestDist = distBefore;
      nearestHub = hubBefore;
    }
    if(hubAfter !== null && distAfter < nearestDist){
      nearestDist = distAfter;
      nearestHub = hubAfter;
    }
    
    // Si proche d'un hub (distance r√©elle vers le hub, pas vers l'√©tape suivante)
    // ET si l'√©tape n'est pas mieux not√©e que le hub (sinon c'est elle qui devrait √™tre hub)
    // PLAFOND ABSOLU: jamais plus de PROXIMITY_MAX_KM (60km)
    if(nearestHub !== null && nearestDist < avgDistanceKm * PROXIMITY_RATIO && nearestDist < PROXIMITY_MAX_KM){
      const hubRating = steps[nearestHub].rating || 3;
      const stepRating = step.rating || 3;
      const hubDays = steps[nearestHub]._suggestedDays || 1;
      const stepDays = step._suggestedDays || 1;
      
      const shouldPromote = stepRating > hubRating || (stepRating === hubRating && stepDays > hubDays);
      
      // Si l'√©tape a un meilleur rating (ou days si √©galit√©), elle devient hub √† sa place
      if(shouldPromote){
        console.log(`[NIGHTS] PROMOTION: ${step.name} (rating=${stepRating}, days=${stepDays}) devient hub √† la place de ${steps[nearestHub].name} (rating=${hubRating}, days=${hubDays})`);
        
        // Promouvoir cette √©tape en hub
        step._isHub = true;
        step._hubGroup = idx;
        step._satellites = [];
        
        // L'ancien hub devient satellite de cette √©tape
        steps[nearestHub]._isHub = false;
        steps[nearestHub]._isSatellite = true;
        steps[nearestHub]._hubGroup = idx;
        step._satellites.push(nearestHub);
        
        // Transf√©rer les satellites de l'ancien hub vers le nouveau
        if(steps[nearestHub]._satellites){
          steps[nearestHub]._satellites.forEach(satIdx => {
            steps[satIdx]._hubGroup = idx;
            step._satellites.push(satIdx);
          });
          steps[nearestHub]._satellites = [];
        }
      } else {
        // NOUVELLE R√àGLE: satellite si < 20km ET <= 2 jours
        const stepDays = step._suggestedDays || 1;
        const GROUPING_DISTANCE = 30;  // km
        const GROUPING_MAX_DAYS = 2;   // jours
        
        const canBeSatellite = nearestDist < GROUPING_DISTANCE && stepDays <= GROUPING_MAX_DAYS;
        
        if(!canBeSatellite){
          // Hub ind√©pendant (> 20km OU > 2 jours)
          step._isHub = true;
          step._hubGroup = idx;
          step._satellites = [];
          console.log(`[NIGHTS] ${step.name} ‚Üí hub ind√©pendant`);
        } else {
          // Satellite - suivre la cha√Æne _mergedInto jusqu'au hub final
          let finalHub = nearestHub;
          let safetyCounter = 0;
          while(steps[finalHub]._mergedInto !== undefined && safetyCounter < 20){
            finalHub = steps[finalHub]._mergedInto;
            safetyCounter++;
          }
          
          step._hubGroup = finalHub;
          step._isSatellite = true;
          
          // S'assurer que le hub final a _satellites
          if(!steps[finalHub]._satellites){
            steps[finalHub]._satellites = [];
          }
          steps[finalHub]._satellites.push(idx);
          console.log(`[NIGHTS] ${step.name} ‚Üí satellite de ${steps[finalHub].name}`);
        }
      }
    } else {
      step._hubGroup = idx; // √âtape ind√©pendante
    }
  });
  
  // PASSE 2b: Rattacher les √©tapes TR√àS PROCHES d'un hub (< 20km) m√™me si pas adjacentes
  // MAIS seulement si <= 2 jours sugg√©r√©s
  const GROUPING_DISTANCE_2B = 30; // km
  const GROUPING_MAX_DAYS_2B = 2;  // jours
  
  steps.forEach((step, idx) => {
    if(step._isHub || step._isSatellite || step._mergedInto !== undefined) return;
    
    // Chercher le hub le plus proche g√©ographiquement
    let closestHub = null;
    let closestDist = Infinity;
    
    steps.forEach((h, hIdx) => {
      if(!h._isHub) return;
      const dist = getDistanceBetween(step, h);
      if(dist < closestDist){
        closestDist = dist;
        closestHub = hIdx;
      }
    });
    
    if(closestHub !== null && closestDist < GROUPING_DISTANCE_2B){
      const stepDays = step._suggestedDays || step.suggested_days || 1;
      const canBeSatellite = stepDays <= GROUPING_MAX_DAYS_2B;
      
      if(canBeSatellite){
        step._isSatellite = true;
        step._hubGroup = closestHub;
        steps[closestHub]._satellites.push(idx);
        console.log(`[NIGHTS] ${step.name} ‚Üí satellite de ${steps[closestHub].name} (proche: ${closestDist.toFixed(1)}km, ${stepDays}j)`);
      } else {
        // Trop de jours sugg√©r√©s ‚Üí hub ind√©pendant
        step._isHub = true;
        step._hubGroup = idx;
        step._satellites = [];
        console.log(`[NIGHTS] ${step.name} ‚Üí hub ind√©pendant malgr√© proximit√© (${stepDays}j > ${GROUPING_MAX_DAYS_2B}j)`);
      }
    }
  });
  
  // Fonction d'arrondi √† 0.5 pr√®s bas√© sur la note
  function roundToHalf(value, roundUp) {
    if (value <= 0.3) return 0.3; // Minimum
    if (roundUp) {
      // Arrondi sup : 1.2 ‚Üí 1.5, 1.6 ‚Üí 2
      return Math.ceil(value * 2) / 2;
    } else {
      // Arrondi inf : 1.8 ‚Üí 1.5, 1.4 ‚Üí 1
      return Math.floor(value * 2) / 2;
    }
  }
  
  // 5. Calculer les nuits avec ratio et arrondi intelligent
  const ratio = Math.min(1, targetDays / totalSuggested);
  console.log(`[NIGHTS] Ratio de r√©duction: ${ratio.toFixed(2)}`);
  
  steps.forEach((step, idx) => {
    // Utiliser _effectiveDays (avec bonus transport) pour le calcul
    const suggested = step._effectiveDays || step._suggestedDays || step.suggested_days || 1;
    const rawDays = suggested * ratio * state.rythmeCoef;
    
    // Arrondi bas√© sur la note
    const aboveAvg = (step.rating || 5) >= avgRating;
    
    if(step._isSatellite){
      // Satellite = 0 nuit seulement si PROCHE (< 20km) ET petit (< 1.5j)
      // Sinon 1 nuit minimum
      const minDays = (step.rating || 0) >= 4.5 ? 0.5 : 0.3;
      
      // Calculer distance au hub
      const hubIdx = step._hubGroup;
      const hub = steps[hubIdx];
      const distToHub = hub ? getDistanceBetween(step, hub) : 999;
      
      const SATELLITE_ZERO_NIGHT_DIST = 30; // km - seuil pour 0 nuit
      
      if (suggested >= 1.5 || distToHub >= SATELLITE_ZERO_NIGHT_DIST) {
        // Lieu important OU trop loin du hub ‚Üí minimum 1 nuit
        step.nights = 1;
        step.adjustedDays = Math.max(minDays, roundToHalf(rawDays, false));
        console.log(`[NIGHTS] Satellite ${step.name}: 1 nuit (${suggested}j sugg√©r√©s, ${distToHub.toFixed(0)}km du hub)`);
      } else {
        // Satellite proche ET petit : passage sans nuit
        step.nights = 0;
        step.adjustedDays = Math.max(minDays, roundToHalf(rawDays, false));
        console.log(`[NIGHTS] Satellite ${step.name}: passage (${distToHub.toFixed(0)}km du hub, ${step.adjustedDays}j)`);
      }
    } else if(step._isHub){
      // Hub = prendre en compte les satellites
      const satellites = step._satellites || [];
      const satelliteDays = satellites.reduce((s, i) => s + (steps[i]._effectiveDays || steps[i]._suggestedDays || 1), 0);
      const totalHubDays = (suggested + satelliteDays) * ratio * state.rythmeCoef;
      
      // Arrondi sup pour les hubs (on veut y rester)
      step.nights = Math.max(1, Math.ceil(totalHubDays));
      
      // adjustedDays = temps individuel du hub (pas le cumul)
      const hubRawDays = suggested * ratio * state.rythmeCoef;
      const minHubDays = (step.rating || 0) >= 4.5 ? 0.5 : 0.3;
      step.adjustedDays = Math.max(minHubDays, roundToHalf(hubRawDays, true)); // arrondi sup
      
      console.log(`[NIGHTS] HUB ${step.name}: ${suggested}j + ${satelliteDays}j satellites √ó ${ratio.toFixed(2)} = ${totalHubDays.toFixed(1)} ‚Üí ${step.nights} nuit(s), temps affich√©: ${step.adjustedDays}j`);
    } else {
      // √âtape normale (non satellite, non hub)
      // Minimum de temps affich√© selon la note
      const minDays = (step.rating || 0) >= 4.5 ? 0.5 : 0.3;
      
      if(aboveAvg){
        step.nights = Math.max(1, Math.ceil(rawDays)); // Arrondi sup
        step.adjustedDays = Math.max(minDays, roundToHalf(rawDays, true)); // arrondi sup
      } else {
        // IMPORTANT: minimum 1 nuit pour toute √©tape non-satellite
        // (on ne peut pas visiter un lieu sans y dormir, sauf satellite)
        step.nights = Math.max(1, Math.floor(rawDays)); // Arrondi inf, min 1
        step.adjustedDays = Math.max(minDays, roundToHalf(rawDays, false)); // arrondi inf
      }
      console.log(`[NIGHTS] ${step.name}: ${suggested}j √ó ${ratio.toFixed(2)} = ${rawDays.toFixed(1)}, rating ${step.rating?.toFixed(1) || '?'} ${aboveAvg ? '‚Üë' : '‚Üì'} ‚Üí ${step.nights} nuit(s), temps affich√©: ${step.adjustedDays}j`);
    }
  });
  
  // 6. Ajustement final pour coller au target
  let allocated = steps.reduce((s, x) => s + x.nights, 0);
  const targetNights = Math.max(1, targetDays - 1);
  let diff = allocated - targetNights;
  
  if(diff !== 0){
    console.log(`[NIGHTS] Ajustement: ${allocated} allou√©s vs ${targetNights} nuits cibles (${targetDays} jours - 1), diff=${diff}`);
    
    // Trier par priorit√© pour ajuster
    const adjustable = steps.filter(s => !s._isSatellite); // Ne pas toucher aux satellites
    adjustable.sort((a, b) => {
      const pa = (a.rating || 1) * (a._suggestedDays || 1);
      const pb = (b.rating || 1) * (b._suggestedDays || 1);
      return diff > 0 ? pa - pb : pb - pa;
    });
    
    for(let i = 0; diff !== 0 && i < adjustable.length * 2; i++){
      const step = adjustable[i % adjustable.length];
      // IMPORTANT: minimum 1 nuit pour toute √©tape non-satellite (on doit y dormir)
      // Seuls les satellites peuvent avoir 0 nuits
      if(diff > 0 && step.nights > 1){
        step.nights--;
        diff--;
      } else if(diff < 0){
        step.nights++;
        diff++;
      }
    }
    
    // Si diff > 0 apr√®s ajustement, on n'a pas pu atteindre la cible
    // ‚Üí Proposer √† l'utilisateur de forcer des passages (0 nuits)
    if(diff > 0){
      console.log(`[NIGHTS] ‚ö†Ô∏è Impossible d'atteindre ${targetNights} nuits (reste ${diff} √† r√©duire)`);
      
      // Stocker les √©tapes candidates pour passage (tri√©es par priorit√© basse)
      state._pendingNightsAdjustment = {
        diff,
        targetNights,
        allocated: steps.reduce((s, x) => s + x.nights, 0),
        candidates: adjustable.filter(s => s.nights === 1 && !s._isHub).map(s => s.name)
      };
    }
  }
  
  const finalTotal = steps.reduce((s, x) => s + x.nights, 0);
  console.log(`[NIGHTS] ‚úÖ Final: ${finalTotal} nuits pour ${steps.length} √©tapes (${steps.filter(s => s.nights > 0).length} avec nuit√©e)`);
  
  // Flag pour √©viter que autoGroupHotels √©crase les nuits
  state._nightsCalculatedByInit = true;
  
  // ‚ö†Ô∏è IMPORTANT: Assigner state.steps APR√àS calculateNightsV3
  // pour que les champs _satellites, _isHub, _isSatellite soient propag√©s
  state.steps = steps;
  
  // targetNights = choix utilisateur (PARAM_DAYS) > recommandation (estimated_days_base) > somme calcul√©e
  // IMPORTANT: nuits = jours - 1 (ex: 7 jours = 6 nuits)
  if(state.requestedDays > 0){
    state.targetNights = Math.max(1, state.requestedDays - 1);
    console.log(`[INIT] üõèÔ∏è Target nuits: ${state.targetNights} (${state.requestedDays} jours - 1)`);
  } else if(estimatedDaysBase > 0){
    const computedDays = Math.ceil(estimatedDaysBase * state.rythmeCoef);
    state.targetNights = Math.max(1, computedDays - 1);
    console.log(`[INIT] üõèÔ∏è Target nuits: ${state.targetNights} (${computedDays} jours estim√©s - 1)`);
  } else {
    state.targetNights = steps.reduce((s,x)=>s+x.nights,0);
  }
  
  state.title=it.title||it.name||'Roadtrip';
  
  // V√©rifier si des hubs ont √©t√© d√©tect√©s
  const hasHubs = steps.some(s => s._isHub);
  
  if(hasHubs){
    // Toujours grouper quand des hubs sont d√©tect√©s - SUPPRIM√â
    console.log(`[INIT] Hubs d√©tect√©s ‚Üí autoGroupHotels supprim√©`);
    // autoGroupHotels(null) supprim√©
  } else if(state.maxHotels && state.maxHotels < steps.length){
    // Regroupement automatique des h√¥tels si maxHotels d√©fini - SUPPRIM√â
    let effectiveMaxHotels = state.maxHotels;
    if(targetDays < totalSuggested){
      const hotelRatio = targetDays / totalSuggested;
      effectiveMaxHotels = Math.max(3, Math.ceil(state.maxHotels * hotelRatio));
      console.log(`[INIT] maxHotels ajust√©: ${state.maxHotels} ‚Üí ${effectiveMaxHotels} (ratio ${hotelRatio.toFixed(2)})`);
    }
    
    console.log('[INIT] autoGroupHotels supprim√©');
    // autoGroupHotels(effectiveMaxHotels) supprim√©
  }
  
  // V√©rifier coh√©rence jours demand√©s vs recommand√©s
  if(state.requestedDays > 0 && estimatedDaysBase > 0){
    const recommendedDays = Math.ceil(estimatedDaysBase * state.rythmeCoef);
    console.log('üîç [COHERENCE] recommendedDays:', recommendedDays);
    console.log('üîç [COHERENCE] seuil (0.7):', recommendedDays * 0.7);
    console.log('üîç [COHERENCE] condition:', state.requestedDays, '<', recommendedDays * 0.7, '=', state.requestedDays < recommendedDays * 0.7);
    if(state.requestedDays < recommendedDays * 0.7){
      console.log('üîç [COHERENCE] ‚ö†Ô∏è ALERTE D√âCLENCH√âE');
      setTimeout(()=> showCoherenceAlert(state.requestedDays, recommendedDays, state.rythme), 500);
    }
  } else {
    console.log('üîç [COHERENCE] Condition non remplie - requestedDays:', state.requestedDays, 'estimatedDaysBase:', estimatedDaysBase);
  }
  
  // V√©rifier si l'ajustement des nuits n'a pas pu √™tre complet
  if(state._pendingNightsAdjustment && state._pendingNightsAdjustment.diff > 0){
    setTimeout(() => showNightsAdjustmentAlert(state._pendingNightsAdjustment), 600);
  }
}

// === Alerte i18n : Nombre de nuits impossible √† atteindre ===
function showNightsAdjustmentAlert(adjustment){
  const { diff, targetNights, allocated, candidates } = adjustment;
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2).toLowerCase();
  
  const t = {
    title: {
      fr: '‚ö†Ô∏è Nombre de nuits difficile √† respecter',
      en: '‚ö†Ô∏è Difficult to meet nights target',
      it: '‚ö†Ô∏è Difficile rispettare il numero di notti',
      es: '‚ö†Ô∏è Dif√≠cil respetar el n√∫mero de noches',
      pt: '‚ö†Ô∏è Dif√≠cil respeitar o n√∫mero de noites',
      ar: '‚ö†Ô∏è ÿµÿπŸàÿ®ÿ© ŸÅŸä ÿßŸÑÿßŸÑÿ™ÿ≤ÿßŸÖ ÿ®ÿπÿØÿØ ÿßŸÑŸÑŸäÿßŸÑŸä'
    },
    message: {
      fr: `Le nombre de nuits impos√© (${targetNights}) est difficile √† respecter compte tenu des distances et temps de visites. Actuellement : ${allocated} nuits.`,
      en: `The requested nights (${targetNights}) is difficult to achieve given distances and visit times. Currently: ${allocated} nights.`,
      it: `Il numero di notti richiesto (${targetNights}) √® difficile da rispettare date le distanze e i tempi di visita. Attualmente: ${allocated} notti.`,
      es: `El n√∫mero de noches solicitado (${targetNights}) es dif√≠cil de respetar dadas las distancias y tiempos de visita. Actualmente: ${allocated} noches.`,
      pt: `O n√∫mero de noites solicitado (${targetNights}) √© dif√≠cil de respeitar dadas as dist√¢ncias e tempos de visita. Atualmente: ${allocated} noites.`,
      ar: `ÿπÿØÿØ ÿßŸÑŸÑŸäÿßŸÑŸä ÿßŸÑŸÖÿ∑ŸÑŸàÿ® (${targetNights}) ÿµÿπÿ® ÿßŸÑÿ™ÿ≠ŸÇŸäŸÇ ŸÜÿ∏ÿ±ÿßŸã ŸÑŸÑŸÖÿ≥ÿßŸÅÿßÿ™ Ÿàÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ≤Ÿäÿßÿ±ÿ©. ÿ≠ÿßŸÑŸäÿßŸã: ${allocated} ŸÑŸäÿßŸÑŸä.`
    },
    forceZero: {
      fr: `Forcer ${diff} passage(s) sans nuit`,
      en: `Force ${diff} stop(s) without overnight`,
      it: `Forzare ${diff} tappa/e senza pernottamento`,
      es: `Forzar ${diff} parada(s) sin noche`,
      pt: `For√ßar ${diff} paragem(ns) sem pernoite`,
      ar: `ŸÅÿ±ÿ∂ ${diff} ÿ™ŸàŸÇŸÅ ÿ®ÿØŸàŸÜ ŸÖÿ®Ÿäÿ™`
    },
    keepNights: {
      fr: `Garder ${allocated} nuits (recommand√©)`,
      en: `Keep ${allocated} nights (recommended)`,
      it: `Mantenere ${allocated} notti (consigliato)`,
      es: `Mantener ${allocated} noches (recomendado)`,
      pt: `Manter ${allocated} noites (recomendado)`,
      ar: `ÿßŸÑÿ•ÿ®ŸÇÿßÿ° ÿπŸÑŸâ ${allocated} ŸÑŸäÿßŸÑŸä (ŸÖŸàÿµŸâ ÿ®Ÿá)`
    },
    warning: {
      fr: `√âtapes concern√©es : ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      en: `Affected stops: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      it: `Tappe interessate: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      es: `Etapas afectadas: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      pt: `Etapas afetadas: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      ar: `ÿßŸÑŸÖÿ≠ÿ∑ÿßÿ™ ÿßŸÑŸÖÿ™ÿ£ÿ´ÿ±ÿ©: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`
    }
  };
  
  const overlay = document.createElement('div');
  overlay.id = 'nightsAlertOverlay';
  overlay.style.cssText = `
    position:fixed; inset:0; z-index:13000;
    background:rgba(0,0,0,.6); display:flex;
    align-items:center; justify-content:center;
    backdrop-filter:blur(4px);
  `;
  
  overlay.innerHTML = `
    <div style="background:#fff; color:#113f7a; border-radius:16px; padding:24px; max-width:420px; width:90%; box-shadow:0 12px 40px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 16px; font-size:1.2rem;">${t.title[lang] || t.title.fr}</h3>
      <p style="margin:0 0 12px; line-height:1.5;">${t.message[lang] || t.message.fr}</p>
      <p style="margin:0 0 20px; font-size:0.9rem; color:#64748b;">${t.warning[lang] || t.warning.fr}</p>
      <div style="display:flex; flex-direction:column; gap:10px;">
        <button id="alertForceZero" style="padding:12px; border-radius:10px; border:1px solid #dc2626; background:#fee2e2; color:#dc2626; font-weight:600; cursor:pointer;">
          ${t.forceZero[lang] || t.forceZero.fr}
        </button>
        <button id="alertKeepNights" style="padding:12px; border-radius:10px; border:none; background:#113f7a; color:#fff; font-weight:600; cursor:pointer;">
          ${t.keepNights[lang] || t.keepNights.fr}
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Forcer les passages (0 nuits)
  document.getElementById('alertForceZero').onclick = () => {
    let remaining = diff;
    // Trier par priorit√© (rating √ó days) croissante
    const sortedSteps = [...state.steps]
      .filter(s => s.nights === 1 && !s._isHub && !s._isSatellite)
      .sort((a, b) => {
        const pa = (a.rating || 1) * (a._suggestedDays || 1);
        const pb = (b.rating || 1) * (b._suggestedDays || 1);
        return pa - pb;
      });
    
    for(const step of sortedSteps){
      if(remaining <= 0) break;
      step.nights = 0;
      remaining--;
      console.log(`[NIGHTS] Forc√© passage: ${step.name} ‚Üí 0 nuit`);
    }
    
    delete state._pendingNightsAdjustment;
    renderRows();
    toast(`‚úÖ ${diff} passage(s) sans nuit`);
    overlay.remove();
  };
  
  // Garder les nuits calcul√©es
  document.getElementById('alertKeepNights').onclick = () => {
    delete state._pendingNightsAdjustment;
    toast(`‚úÖ ${allocated} nuits conserv√©es`);
    overlay.remove();
  };
}
// Strat√©gie 1 : √âquilibr√© (groupes de taille √©gale, base = meilleur rating)

// Strat√©gie 1 : Groupes √©quilibr√©s
function createBalancedGroups(maxHotels){
  const n = state.steps.length;
  const groups = [];
  const baseSize = Math.floor(n / maxHotels);
  const extra = n % maxHotels;
  
  let idx = 0;
  for(let g = 0; g < maxHotels && idx < n; g++){
    const size = baseSize + (g < extra ? 1 : 0);
    const stepIndices = [];
    for(let i = 0; i < size && idx < n; i++){
      stepIndices.push(idx++);
    }
    
    // Trouver la meilleure base (rating le plus √©lev√©)
    let bestIdx = stepIndices[0];
    let bestRating = state.steps[bestIdx]?.rating || 1;
    stepIndices.forEach(si => {
      const r = state.steps[si]?.rating || 1;
      if(r > bestRating){
        bestRating = r;
        bestIdx = si;
      }
    });
    
    groups.push({
      steps: stepIndices,
      base: state.steps[bestIdx]
    });
  }
  
  return groups;
}

// Strat√©gie 2 : Par r√©gion
function createRegionGroups(maxHotels){
  // Fallback vers √©quilibr√© si pas de region_code
  return createBalancedGroups(maxHotels);
}

// Strat√©gie 3 : Privil√©gier les meilleures notes
function createRatingGroups(maxHotels){
  // Trier les indices par rating d√©croissant pour choisir les bases
  const sortedByRating = state.steps
    .map((s, i) => ({ idx: i, rating: s.rating || 1 }))
    .sort((a, b) => b.rating - a.rating);
  
  // Prendre les maxHotels meilleures places comme bases
  const baseIndices = sortedByRating.slice(0, maxHotels).map(x => x.idx).sort((a,b) => a - b);
  
  // Assigner chaque √©tape au groupe de la base la plus proche
  const groups = baseIndices.map(bi => ({ steps: [], base: state.steps[bi], baseIdx: bi }));
  
  state.steps.forEach((s, i) => {
    // Trouver le groupe dont la base est la plus proche (en index)
    let bestGroup = 0;
    let minDist = Infinity;
    groups.forEach((g, gi) => {
      const dist = Math.abs(i - g.baseIdx);
      if(dist < minDist){
        minDist = dist;
        bestGroup = gi;
      }
    });
    groups[bestGroup].steps.push(i);
  });
  
  return groups;
}

// Strat√©gie 4 : Minimiser les distances
function createDistanceGroups(maxHotels){
  // Similaire √† √©quilibr√© mais en essayant de garder les √©tapes proches ensemble
  return createBalancedGroups(maxHotels);
}

// Strat√©gie 5 : Privil√©gier les grandes villes
function createCityGroups(maxHotels){
  const cityTypes = ['large_city', 'medium_city', 'small_city'];
  
  // Trouver les places de type ville
  const cities = state.steps
    .map((s, i) => ({ idx: i, type: s.place_type || '', rating: s.rating || 1 }))
    .filter(x => cityTypes.includes(x.type))
    .sort((a, b) => {
      const typeOrder = cityTypes.indexOf(a.type) - cityTypes.indexOf(b.type);
      return typeOrder !== 0 ? typeOrder : b.rating - a.rating;
    });
  
  if(cities.length < maxHotels){
    // Pas assez de villes, fallback
    return createBalancedGroups(maxHotels);
  }
  
  // Prendre les maxHotels meilleures villes comme bases
  const baseIndices = cities.slice(0, maxHotels).map(x => x.idx).sort((a,b) => a - b);
  
  // Assigner chaque √©tape au groupe de la base la plus proche
  const groups = baseIndices.map(bi => ({ steps: [], base: state.steps[bi], baseIdx: bi }));
  
  state.steps.forEach((s, i) => {
    let bestGroup = 0;
    let minDist = Infinity;
    groups.forEach((g, gi) => {
      const dist = Math.abs(i - g.baseIdx);
      if(dist < minDist){
        minDist = dist;
        bestGroup = gi;
      }
    });
    groups[bestGroup].steps.push(i);
  });
  
  return groups;
}

function refreshCounters(){
  const total = state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
  const delta = total - state.targetNights;

  const curEl = document.querySelector('#currentNights');
  const tarEl = document.querySelector('#targetNights');
  const delEl = document.querySelector('#deltaNights');

  if (curEl) { curEl.textContent = String(total); curEl.className = `counter ${delta===0?'ok':'bad'}`; }
  if (tarEl) { tarEl.textContent = String(state.targetNights); }
  if (delEl) { delEl.textContent = (delta>0?'+':'')+delta; delEl.className = `counter ${delta===0?'ok':'bad'}`; }

  // Toujours tenir √† jour le pav√© compact
  updateQuickStats();
}

async function recomputeTotals(){
  if (!Array.isArray(state.steps) || state.steps.length<2){ TOTALS={km:0,minutes:0,travelDays:0}; updateHelpPop(); return; }
  const pairs=[];
  for(let i=0;i<state.steps.length-1;i++){
    const a=state.steps[i], b=state.steps[i+1];
    if(Number.isFinite(a.lat)&&Number.isFinite(a.lon)&&Number.isFinite(b.lat)&&Number.isFinite(b.lon)){
      pairs.push(calculateDistance(a,b));
    }
  }
  try{
    const res=await Promise.all(pairs);
    const km = res.reduce((s,r)=> s+(r?.km||0), 0);
    const minutes = res.reduce((s,r)=> s+(r?.minutes||0), 0);
    
    // Calcul des jours de trajet par segment
    let travelDays = 0;
    for(const seg of res){
      const segKm = seg?.km || 0;
      const segMin = seg?.minutes || 0;
      if(segKm >= 600){
        travelDays += 1;        // Vol ou tr√®s longue distance ‚Üí +1 jour
      } else if(segMin >= 300){
        travelDays += 0.5;      // Route ‚â•5h ‚Üí +0.5 jour
      }
    }
    
    TOTALS = { km: Math.round(km), minutes: Math.round(minutes), travelDays: travelDays };
  }catch{
    TOTALS = { km: 0, minutes: 0, travelDays: 0 };
  }
  updateHelpPop();
  updateQuickStats();
}

function updateHelpPop(){
  // Fonction d√©sactiv√©e en mode simple
}

function updateQuickStats(){
  const targetN = Number(state.targetNights||0);
  const currN = state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
  const delta = currN - targetN;
  const qsN = document.getElementById('qsNights');
  const qsD = document.getElementById('qsDelta');
  const qsK = document.getElementById('qsKm');
  const qsT = document.getElementById('qsTime');
  const qsTD = document.getElementById('qsTravelDays');
  
  // I18N pour les stats
  const lang = (document.documentElement.lang || 'fr').slice(0,2);
  const I18N_STATS = {
    days: {fr:'jours',en:'days',it:'giorni',es:'d√≠as',pt:'dias',ar:'ÿ£ŸäÿßŸÖ'},
    day: {fr:'jour',en:'day',it:'giorno',es:'d√≠a',pt:'dia',ar:'ŸäŸàŸÖ'},
    h: {fr:'h',en:'h',it:'h',es:'h',pt:'h',ar:'ÿ≥'},
    min: {fr:'min',en:'min',it:'min',es:'min',pt:'min',ar:'ÿØ'},
    travel: {fr:'trajet',en:'travel',it:'viaggio',es:'viaje',pt:'viagem',ar:'ÿ≥ŸÅÿ±'}
  };
  const tDays = targetN > 1 ? (I18N_STATS.days[lang]||'days') : (I18N_STATS.day[lang]||'day');
  const tH = I18N_STATS.h[lang] || 'h';
  const tMin = I18N_STATS.min[lang] || 'min';
  const tTravel = I18N_STATS.travel[lang] || 'travel';
  
  // Afficher le nombre de jours cible (choisi ou recommand√©)
  if(qsN) {
    qsN.textContent = `${targetN} ${tDays}`;
  }
  if(qsD) {
    qsD.textContent = `Œî ${delta>0?'+':''}${delta}`;
    qsD.style.color = delta === 0 ? '#22c55e' : '#dc2626';
  }
  if(qsK) qsK.textContent = (state.distanceUnit==='mi')
    ? `${Math.round(TOTALS.km*0.621371)} mi`
    : `${TOTALS.km} km`;
  if(qsT) {
    const h = Math.floor(TOTALS.minutes/60), m = TOTALS.minutes%60;
    qsT.textContent = `${h} ${tH} ${m} ${tMin}`;
  }
  
  // Jours de trajet (masqu√© si 0)
  if(qsTD) {
    if(TOTALS.travelDays > 0) {
      const jLabel = TOTALS.travelDays === 1 ? (I18N_STATS.day[lang]||'d')[0] : (I18N_STATS.days[lang]||'d')[0];
      qsTD.textContent = ` ¬∑ +${TOTALS.travelDays}${jLabel} ${tTravel}`;
      qsTD.style.display = 'inline';
      qsTD.style.color = '#f59e0b'; // orange pour attirer l'attention
    } else {
      qsTD.style.display = 'none';
    }
  }
}



// === CONVERSION RATING EN √âTOILES ===
function ratingToStars(rating) {
  if (!rating || rating === 0) return { stars: 0, color: '#CFD8DC', textColor: '#fff', radius: 3, isStar: false };
  if (rating >= 8.8) return { stars: 5, color: '#1565C0', textColor: '#fff', radius: 8, isStar: true };  // √âtoile bleue
  if (rating >= 7.6) return { stars: 4, color: '#43A047', textColor: '#fff', radius: 6, isStar: false }; // Vert
  if (rating >= 6.1) return { stars: 3, color: '#7CB342', textColor: '#fff', radius: 5, isStar: false }; // Vert clair
  if (rating >= 3.1) return { stars: 2, color: '#78909C', textColor: '#fff', radius: 4, isStar: false }; // Gris-bleu
  return { stars: 1, color: '#B0BEC5', textColor: '#333', radius: 3, isStar: false }; // Gris clair (< 3.1)
}

// === CR√âATION IC√îNE √âTOILE (pour incontournables) ===
function createStarIcon(color, size, isSelected = false) {
  const finalColor = isSelected ? '#e11d48' : color;
  return L.divIcon({
    html: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${finalColor}" stroke="#fff" stroke-width="2">
      <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
    </svg>`,
    className: 'star-marker' + (isSelected ? ' selected' : ''),
    iconSize: [size, size],
    iconAnchor: [size/2, size/2]
  });
}

// Fonction de traduction des labels (d√©plac√©e ici pour √™tre accessible dans renderRow)
function trLabel(lang, key){
  lang = (lang||'fr').slice(0,2).toLowerCase();
  const MAP = {
    visits:     { fr:'Visites',    en:'Visits',     it:'Visite',    es:'Visitas',   pt:'Visitas',   ar:'ÿßŸÑÿ≤Ÿäÿßÿ±ÿßÿ™' },
    activities: { fr:'Activit√©s',  en:'Activities', it:'Attivit√†',  es:'Actividades', pt:'Atividades', ar:'ÿßŸÑÿ£ŸÜÿ¥ÿ∑ÿ©' },
    estimated_visit_time: { fr:'Temps de visite estim√©', en:'Estimated visit time', it:'Tempo di visita stimato', es:'Tiempo de visita estimado', pt:'Tempo de visita estimado', ar:'ŸàŸÇÿ™ ÿßŸÑÿ≤Ÿäÿßÿ±ÿ© ÿßŸÑŸÖŸÇÿØÿ±' },
    days: { fr:'jours', en:'days', it:'giorni', es:'d√≠as', pt:'dias', ar:'ÿ£ŸäÿßŸÖ' },
    day: { fr:'jour', en:'day', it:'giorno', es:'d√≠a', pt:'dia', ar:'ŸäŸàŸÖ' }
  };
  return (MAP[key] && MAP[key][lang]) ? MAP[key][lang] : (MAP[key]?.fr || key);
}

function renderRows(){
  const box=$('#rows');box.innerHTML='';
  state.steps.forEach((s,idx)=>box.appendChild(renderRow(s,idx)));
  enableDnD();
  drawMap();
  /* AJOUT */
  if (window.map && window.map.invalidateSize) {
    setTimeout(()=>map.invalidateSize(), 60);
  }
  refreshCounters();
  recomputeTotals();      // met √† jour km/temps
  updateQuickStats();     // met √† jour le pav√© compact
  
  // Afficher/masquer bouton r√©organiser h√¥tels
  const btnReorg = document.getElementById('btnReorganizeHotels');
  if(btnReorg){
    btnReorg.style.display = (state.maxHotels && state.maxHotels < state.steps.length) ? 'inline-block' : 'none';
  }
  
  // scheduleAutosave(); // SUPPRIM√â - ne pas sauvegarder au simple affichage, seulement sur modification utilisateur

}
window.renderRows = renderRows;
function renderRow(step,idx){
  const row=document.createElement('div');
  row.className='step-row';
  row.draggable=true;
  row.dataset.index=idx;

  // ‚öôÔ∏è SID unique garanti (ind√©pendant de l'index)
  const sid = ensureSid(step);
  row.dataset.stepId = sid;

  const handle=document.createElement('div');

  handle.className='cell';
  const tViewDetails = t('viewDetails') || 'Voir d√©tails';

handle.innerHTML=`
  <div style="display:flex;align-items:center;gap:8px">
    <span class="step-num">${idx+1}</span>
    <button class="eye-btn" type="button" title="${tViewDetails}" style="display:inline-flex !important;align-items:center;justify-content:center;width:32px;height:32px;background:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;cursor:pointer;font-size:16px;">üëÅ</button>
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" style="opacity:0.4;flex-shrink:0">
      <path d="M9 5h2v2H9V5zm0 4h2v2H9V9zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm4-12h2v2h-2V5zm0 4h2v2h-2V9zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2z" fill="#64748b"/>
    </svg>
  </div>`;

// Bouton ≈ìil pour afficher le popup
const eyeBtn = handle.querySelector('.eye-btn');
console.log(`[EYE-BTN] Step ${idx+1} (${step.name}): eyeBtn found =`, !!eyeBtn, '| handle HTML:', handle.innerHTML.substring(0, 200));
eyeBtn?.addEventListener('click', (e) => {
  console.log('[EYE-BTN] Click on', step.name);
  e.stopPropagation();
  window.popupLocked = true;
  showStepPreview(step);
  document.getElementById('mapPopup')?.classList.add('show');
  
  // Centrer la carte sur ce point
  if (step.lat && step.lon && window.map) {
    window.map.setView([step.lat, step.lon], Math.max(window.map.getZoom(), 10));
  }
});

row.appendChild(handle);
  
  const place=document.createElement('div');
place.className='cell';
const displayName = step.name || step.place_id.split('::')[1] || step.place_id;

// R√©cup√©rer le rating depuis step ou PLACES_INDEX
let stepRating = step.rating || 0;
if (!stepRating && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step.place_id]) {
  stepRating = PLACES_INDEX[step.place_id].rating || 0;
}

// √âtoiles color√©es
let starsHTML = '';
if (stepRating > 0) {
  const starInfo = ratingToStars(stepRating);
  const starsDisplay = '‚òÖ'.repeat(starInfo.stars);
  starsHTML = `<div style="font-size:0.85rem;color:${starInfo.color};margin-top:2px;font-weight:700">${starsDisplay}</div>`;
}

// Temps de visite estim√© PAR √âTAPE (ajust√© proportionnellement avec d√©cimales)
let visitTimeHTML = '';
const visitDays = step.adjustedDays || step._suggestedDays || step.suggested_days || 0;
if (visitDays > 0) {
  const lang = document.documentElement.lang || 'fr';
  const tooltip = trLabel(lang, 'estimated_visit_time');
  const dayLabel = visitDays > 1 ? trLabel(lang, 'days') : trLabel(lang, 'day');
  // Formater avec virgule pour 0.5 (ex: 2,5 au lieu de 2.5)
  const formattedDays = visitDays.toString().replace('.', ',');
  visitTimeHTML = `<div style="font-size:0.75rem;color:#64748b;margin-top:2px" title="${tooltip}">üïê ${formattedDays} ${dayLabel}</div>`;
}

place.innerHTML=`
  <div style="display:flex;flex-direction:column" class="step-name-hover">
    <span style="font-weight:600;color:#113f7a">${safe(displayName)}</span>
    ${starsHTML}
    ${visitTimeHTML}
  </div>`;

row.appendChild(place);

// Plus de popup automatique au survol ou clic sur la row
// Utiliser le bouton ≈ìil (üëÅ) pour afficher le popup

  
  // Distance vers prochaine √©tape
  const distCell=document.createElement('div');
  distCell.className='cell mut';
  distCell.innerHTML='<div data-dist="loading">' + t('calculating') + '</div>';
  row.appendChild(distCell);
  
  // Utiliser to_next_leg si disponible, sinon calculer
  if(idx<state.steps.length-1){
    const tMin = t('min') || 'min';
    if(step.to_next_leg && step.to_next_leg.distance_km && step.to_next_leg.drive_min){
      // Donn√©es pr√©-calcul√©es depuis l'itin√©raire
      const el=row.querySelector('[data-dist]');
      if(el){
        const isMi = state.distanceUnit==='mi';
        const val = isMi ? Math.round(step.to_next_leg.distance_km*0.621371) : step.to_next_leg.distance_km;
        const unit = isMi ? 'mi' : 'km';
        const h = Math.floor(step.to_next_leg.drive_min/60);
        const m = step.to_next_leg.drive_min % 60;
        const timeStr = h > 0 ? `${h}h${m>0?m:''}` : `${m} ${tMin}`;
        el.innerHTML=`<div style="font-weight:600">${val} ${unit}</div><div style="font-size:.8rem">${timeStr}</div>`;
      }
    } else {
      // Calcul dynamique en arri√®re-plan
      const nextStep=state.steps[idx+1];
      calculateDistance(step,nextStep).then(dist=>{
        const el=row.querySelector('[data-dist]');
        if(el&&dist){
          const isMi = state.distanceUnit==='mi';
          const val = isMi ? Math.round(dist.km*0.621371) : dist.km;
          const unit = isMi ? 'mi' : 'km';
          el.innerHTML=`<div style="font-weight:600">${val} ${unit}</div><div style="font-size:.8rem">${dist.minutes} ${tMin}</div>`;
        }else if(el){
          el.textContent='‚Äî';
        }
      });
    }
  }else{
    const el=row.querySelector('[data-dist]');
    if(el) el.textContent='‚Äî';
  }
  

// === COLONNE NUITS (modifiable) ===
(function(){
  // Calcul auto si pas d√©fini
  if (!step.nights && step.nights !== 0) {
    const visitTime = calculateVisitTime(step.place_id);
    step.nights = determineNights(visitTime.total);
    step._autoVisitTime = visitTime.total;
  }
  
  const nightsCell = document.createElement('div');
  nightsCell.className = 'cell';
  nightsCell.style.textAlign = 'center';
  nightsCell.style.lineHeight = '1.2';
  
  const nights = Number(step.nights || 0);
  
  // Input modifiable
  nightsCell.innerHTML = `
    <input type="number" min="0" max="30" value="${nights}" 
           style="width:50px;text-align:center;font-weight:600;font-size:1.1rem;color:#113f7a;border:1px solid #cbd5e1;border-radius:6px;padding:4px"
           data-nights-input>
    <div class="mut" style="font-size:0.75rem;margin-top:2px">nuit${nights > 1 ? 's' : ''}</div>`;
  
  const input = nightsCell.querySelector('[data-nights-input]');
  
  input.addEventListener('click', (e) => {
    e.stopPropagation(); // Ne pas d√©clencher le clic row
  });
  
  input.addEventListener('change', (e) => {
    const newNights = parseInt(e.target.value) || 0;
    step.nights = newNights;
    renderRows(); // Recalculer tout (h√¥tel, totaux)
  });
  
  row.appendChild(nightsCell);
})();

// === COLONNE DATES (Arriv√©e ‚Üí D√©part sur 2 lignes) ===
(function(){
  const dateCell = document.createElement('div');
  dateCell.className='cell';
  dateCell.style.textAlign='left';
  dateCell.style.lineHeight='1.2';

  // Tooltip i18n
  const lang = (document.documentElement.lang||'fr').slice(0,2);
  const TIP = {
    fr:'Arriv√©e ‚Üí D√©part',
    en:'Arrival ‚Üí Departure',
    it:'Arrivo ‚Üí Partenza',
    es:'Llegada ‚Üí Salida',
    pt:'Chegada ‚Üí Partida',
    ar:'ÿßŸÑŸàÿµŸàŸÑ ‚Üí ÿßŸÑŸÖÿ∫ÿßÿØÿ±ÿ©'
  };
  dateCell.title = TIP[lang] || TIP.fr;

  // Si pas de date globale d√©finie, on affiche un tiret
  const startStr = (state.startDateStr||'').trim();
  if(!startStr){
    dateCell.innerHTML = `<div class="mut">‚Äî</div>`;
    row.appendChild(dateCell);
    return;
  }

  // Calcule la date d'arriv√©e en cumulant les nuits pr√©c√©dentes
  const base = new Date(startStr+'T00:00:00');
  let offset = 0;
  for(let i=0;i<idx;i++){
    offset += Number(state.steps[i]?.nights||0);
  }

  const arrivalDate = new Date(base);
  arrivalDate.setDate(arrivalDate.getDate()+offset);
  
  const nights = Number(step.nights || 0);
  const departureDate = new Date(arrivalDate);
  departureDate.setDate(departureDate.getDate() + nights);

  // Format compact par langue (JJ MMM)
  const fmt = (d)=>{
    try {
      const l = (document.documentElement.lang||'fr');
      return d.toLocaleDateString(l, { day:'2-digit', month:'short' });
    } catch(_){
      const dd = String(d.getDate()).padStart(2,'0');
      const mm = String(d.getMonth()+1).padStart(2,'0');
      return `${dd}/${mm}`;
    }
  };

  if (nights > 0) {
    dateCell.innerHTML = `
      <div style="font-size:0.9rem">${fmt(arrivalDate)}</div>
      <div style="font-size:0.9rem;color:#64748b">‚Üì ${fmt(departureDate)}</div>`;
  } else {
    dateCell.innerHTML = `<div style="font-size:0.9rem">${fmt(arrivalDate)}</div>`;
  }
  
  row.appendChild(dateCell);
})();

// === COLONNE H√îTEL (Stay22 uniquement) ===
(function(){
  const hotelCell = document.createElement('div');
  hotelCell.className = 'cell hotel-cell';
  hotelCell.style.textAlign = 'center';
  
  const nights = Number(step.nights || 0);
  
  // Si l'√©tape fait partie d'un groupe, utiliser la base du groupe
  let hotelStep = step;
  if(step.groupName && step.groupColor){
    const groupSteps = state.steps.filter(s => s.groupName === step.groupName);
    if(groupSteps.length > 0){
      hotelStep = groupSteps.reduce((best, s) => (s.rating || 0) > (best.rating || 0) ? s : best, groupSteps[0]);
    }
  }
  
  const cityName = hotelStep.name || hotelStep.place_id?.split('::')[1] || 'H√¥tel';
  const stay22Url = getStay22MapUrl(hotelStep, idx);
  
  // I18N
  const tNight = nights > 1 ? t('nights') : t('night');
  const tChoose = t('choose') || 'Choisir';
  const tPassage = t('passage') || '(passage)';
  const tSearchHotel = t('searchHotelAt') || 'Chercher un h√©bergement √†';
  
  if (nights > 0 && stay22Url) {
    hotelCell.innerHTML = `
      <a href="${stay22Url}" target="_blank" rel="noopener" 
         class="btn" style="display:inline-flex;align-items:center;gap:4px;font-size:0.8rem;padding:8px 12px;background:#113f7a;border-color:#113f7a;text-decoration:none;border-radius:8px;color:#fff"
         title="${tSearchHotel} ${cityName}">
        üè® ${tChoose}
      </a>`;
  } else if (nights > 0) {
    // Pas de coords ‚Üí ne rien afficher
    hotelCell.innerHTML = ``;
  } else {
    // √âtape sans nuit (passage)
    hotelCell.innerHTML = `<div class="mut" style="font-size:0.8rem;color:#94a3b8;font-style:italic">${tPassage}</div>`;
  }
  
  row.appendChild(hotelCell);
})();





  
  const del=document.createElement('div');
  del.className='cell';
  del.innerHTML=`<button class="iconbtn btn danger" data-delete="${idx}">‚úï</button>`;
  // ... cr√©ation bouton supprimer (del)

  row.appendChild(del);
  del.querySelector('button').addEventListener('click', () => {
    if(confirm('Supprimer cette √©tape ?')) {
      state.steps.splice(idx, 1);
      autoRecenter = true; // Recentrer apr√®s suppression
      
      // Recalculer les groupes/nuits sauf si mode manuel
      if(!state._manualMode) {
        autoCalculateNights(state.targetNights);
      }
      
      renderRows(); // recalcul complet (km, nuits, totaux)
    }
  });

  
// [Y.2] Rouge + grossi sans casser le translate Leaflet
row.addEventListener('mouseenter', ()=>{
  const sid = row.dataset.stepId;
  const mm = (markers||[]).find(m=>m.stepId===sid);
  const el = mm?.getElement();
  el?.querySelector('.marker-num')?.classList.add('num-boost'); // grossit le chiffre
  el?.classList.add('marker-red');                               // cercle rouge
});
row.addEventListener('mouseleave', ()=>{
  const sid = row.dataset.stepId;
  const mm = (markers||[]).find(m=>m.stepId===sid);
  const el = mm?.getElement();
  el?.querySelector('.marker-num')?.classList.remove('num-boost');
  el?.classList.remove('marker-red');
});

  return row;
}

// Calcul distance via OSRM ou Netlify (avec logique local/prod)
async function calculateDistance(fromStep, toStep) {
  const fallback = () => {
    const R=6371, toRad=d=>d*Math.PI/180;
    const dLat=toRad(toStep.lat-fromStep.lat), dLon=toRad(toStep.lon-fromStep.lon);
    const a=Math.sin(dLat/2)**2+Math.cos(toRad(fromStep.lat))*Math.cos(toRad(toStep.lat))*Math.sin(dLon/2)**2;
    const km=Math.round(R*(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))));
    const minutes=Math.round((km/65)*60);
    return { km, minutes };
  };

  try {
    if (!Number.isFinite(fromStep?.lat) || !Number.isFinite(fromStep?.lon) ||
        !Number.isFinite(toStep?.lat)   || !Number.isFinite(toStep?.lon)) {
      return { km: 0, minutes: 0 };
    }
    if (fromStep.lat === toStep.lat && fromStep.lon === toStep.lon) {
      return { km: 0, minutes: 0 };
    }

    const mode = getTransportMode();
    const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';

    // === LOCAL: OSRM DIRECT ===
    if (isLocal) {
      try {
        const osrmProfile = mode === 'driving' ? 'car' : mode === 'cycling' ? 'bike' : mode === 'walking' ? 'foot' : 'car';
        const osrmUrl = `https://router.project-osrm.org/route/v1/${osrmProfile}/${fromStep.lon},${fromStep.lat};${toStep.lon},${toStep.lat}`;
        const ctl = new AbortController();
        const timer = setTimeout(()=>ctl.abort(), 1200);
        const r = await fetch(osrmUrl, { cache:'no-store', signal: ctl.signal }).catch(()=>null);
        clearTimeout(timer);

        if(r && r.ok) {
          const d = await r.json().catch(()=>null);
          if(d?.code === 'Ok' && d.routes?.[0]) {
            const route = d.routes[0];
            return { km: Math.round(route.distance / 1000), minutes: Math.round(route.duration / 60) };
          }
        }
      } catch (e) {
        // Fallback
      }
      return fallback();
    }

    // === PROD: NETLIFY ‚Üí OSRM ===
    try {
      const apiUrl = `/.netlify/functions/route?mode=${mode}&start=${fromStep.lon},${fromStep.lat}&end=${toStep.lon},${toStep.lat}`;
      const ctl = new AbortController();
      const timer = setTimeout(()=>ctl.abort(), 1200);
      const r = await fetch(apiUrl, { cache:'no-store', signal: ctl.signal }).catch(()=>null);
      clearTimeout(timer);

      if(r && r.ok) {
        const d = await r.json().catch(()=>null);
        if(d?.ok) return { km: Math.round(d.km), minutes: Math.round(d.minutes) };
      }
    } catch (e) {
      // Fallback
    }

    return fallback();
  } catch {
    return fallback();
  }
}

function showStepPreview(step){
  const popup = $('#mapPopup');

  // R√©cup√©rer le rating
  let stepRating = step?.rating || 0;
  if (!stepRating && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step?.place_id]) {
    stepRating = PLACES_INDEX[step.place_id].rating || 0;
  }

  // Badge rating avec √©toiles
  let ratingHTML = '';
  if (stepRating > 0) {
    const starInfo = ratingToStars(stepRating);
    const starsDisplay = '‚òÖ'.repeat(starInfo.stars);
    ratingHTML = ` <span style="color:${starInfo.color};font-size:0.9rem;font-weight:700">${starsDisplay}</span>`;
  }
  
  // Temps de visite estim√© PAR √âTAPE (ajust√© proportionnellement avec d√©cimales)
  let suggestedDays = step?.adjustedDays || step?._suggestedDays || step?.suggested_days || 0;
  
  // Si pas trouv√©, chercher dans state.steps par place_id
  if (!suggestedDays && step?.place_id && window.state?.steps) {
    const stateStep = window.state.steps.find(s => s.place_id === step.place_id);
    suggestedDays = stateStep?.adjustedDays || stateStep?._suggestedDays || stateStep?.suggested_days || 0;
  }
  
  console.log(`[DEBUG-VISIT-TIME] step.name=${step?.name}, adjustedDays=${step?.adjustedDays}, _suggestedDays=${step?._suggestedDays}, final=${suggestedDays}`);
  let visitTimeHTML = '';
  if (suggestedDays > 0) {
    const lang = document.documentElement.lang || 'fr';
    const tooltip = trLabel(lang, 'estimated_visit_time');
    const dayLabel = suggestedDays > 1 ? trLabel(lang, 'days') : trLabel(lang, 'day');
    // Formater avec virgule pour 0.5 (ex: 2,5 au lieu de 2.5)
    const formattedDays = suggestedDays.toString().replace('.', ',');
    visitTimeHTML = ` <span style="color:#64748b;font-size:0.85rem;margin-left:8px" title="${tooltip}">üïê ${formattedDays} ${dayLabel}</span>`;
  }

  // Titre avec rating et temps de visite
  $('#popupTitle').innerHTML = (step?.name || step?.place_id || '') + ratingHTML + visitTimeHTML;

  // Photos - Carrousel
  const photos = $('#popupPhotos');
  photos.innerHTML = '';
  const imgs = Array.isArray(step?.images) ? step.images.slice(0,6) : [];
  if (imgs.length){
    // Cr√©er le carrousel
    const container = document.createElement('div');
    container.className = 'carousel-container';
    
    // Image principale (premi√®re charg√©e imm√©diatement)
    const mainImg = document.createElement('img');
    mainImg.className = 'carousel-img';
    mainImg.src = imgs[0];
    mainImg.alt = step?.name || '';
    mainImg.onerror = () => mainImg.style.display = 'none';
    container.appendChild(mainImg);
    
    // Stocker les URLs pour navigation lazy
    container.dataset.images = JSON.stringify(imgs);
    container.dataset.current = '0';
    
    // Fl√®ches (seulement si > 1 image)
    if (imgs.length > 1) {
      const prevBtn = document.createElement('button');
      prevBtn.className = 'carousel-nav prev';
      prevBtn.innerHTML = '‚Äπ';
      prevBtn.type = 'button';
      prevBtn.onclick = () => navigateCarousel(container, -1);
      
      const nextBtn = document.createElement('button');
      nextBtn.className = 'carousel-nav next';
      nextBtn.innerHTML = '‚Ä∫';
      nextBtn.type = 'button';
      nextBtn.onclick = () => navigateCarousel(container, 1);
      
      container.appendChild(prevBtn);
      container.appendChild(nextBtn);
      
      // Dots
      const dots = document.createElement('div');
      dots.className = 'carousel-dots';
      imgs.forEach((_, i) => {
        const dot = document.createElement('button');
        dot.className = 'carousel-dot' + (i === 0 ? ' active' : '');
        dot.type = 'button';
        dot.onclick = () => goToSlide(container, i);
        dots.appendChild(dot);
      });
      photos.appendChild(container);
      photos.appendChild(dots);
    } else {
      photos.appendChild(container);
    }
  } else {
    photos.innerHTML = '<div style="text-align:center;color:#94a3b8;font-size:.85rem;padding:20px">' + t('noPhoto') + '</div>';
  }

  // Fonctions carrousel (d√©finies localement pour √©viter les conflits)
  function navigateCarousel(container, dir) {
    const imgs = JSON.parse(container.dataset.images || '[]');
    let current = parseInt(container.dataset.current || '0');
    current = (current + dir + imgs.length) % imgs.length;
    goToSlide(container, current);
  }
  
  function goToSlide(container, index) {
    const imgs = JSON.parse(container.dataset.images || '[]');
    if (!imgs[index]) return;
    
    const mainImg = container.querySelector('.carousel-img');
    if (mainImg) {
      mainImg.src = imgs[index];
    }
    container.dataset.current = index.toString();
    
    // Mettre √† jour les dots
    const dotsContainer = container.parentElement.querySelector('.carousel-dots');
    if (dotsContainer) {
      dotsContainer.querySelectorAll('.carousel-dot').forEach((dot, i) => {
        dot.classList.toggle('active', i === index);
      });
    }
  }

  // Libell√©s I18N
  const visitsLbl = trLabel(document.documentElement.lang, 'visits');
  const actsLbl   = trLabel(document.documentElement.lang, 'activities');

  // === Normalisation VISITES / ACTIVIT√âS ===
  // 1) supporte: tableau d'objets {text:...}, tableau de strings, objet unique, ou fallback description
  function normList(raw, fallbackFromDesc=false){
    if (Array.isArray(raw)) {
      return raw.map(v => (v && typeof v==='object' && 'text' in v) ? v.text : v)
                .map(v => String(v||'').trim())
                .filter(Boolean);
    }
    if (raw && typeof raw==='object' && 'text' in raw) {
      return [String(raw.text||'').trim()].filter(Boolean);
    }
    if (fallbackFromDesc && step?.description) {
      return String(step.description).split(/[\n\.]+/).map(s=>s.trim()).filter(Boolean);
    }
    return [];
  }

  // ‚Üí certaines sources peuvent d√©poser visites/activities dans le cache "places master"
  //    on merge prudemment si vide.
  const fromMaster = (function(){
    const pid = step?.place_id;
    try{
      // PLACES_INDEX peut ne pas exister ‚Üí try/catch
      return (pid && window.PLACES_INDEX && window.PLACES_INDEX[pid]) ? window.PLACES_INDEX[pid] : null;
    }catch(_){ return null; }
  })();

  let visitsArray = normList(step?.visits, true);
  if (!visitsArray.length && fromMaster) {
    visitsArray = normList(fromMaster.visits, true);
  }

  let actsArray = normList(step?.activities, false);
  if (!actsArray.length && fromMaster) {
    actsArray = normList(fromMaster.activities, false);
  }

  // Debug minimal (pour comprendre les cas o√π "visits" √©tait l√† mais non rendue)
  try{
    console.debug('[POPUP] step=', step?.name || step?.place_id, 'visits.len=', visitsArray.length, 'acts.len=', actsArray.length);
  }catch(_){}

// === VISITES ===
  let visitsHTML = '';
  if (visitsArray.length) {
    const v = visitsArray.slice(0,8).map(t=>`‚Ä¢ ${safe(t)}`).join('<br>');
    visitsHTML = `<p><strong>üèõÔ∏è ${visitsLbl}:</strong><br>${v}</p>`;
  } else {
    visitsHTML = `<p><strong>üèõÔ∏è ${visitsLbl}:</strong><br>‚Äî</p>`;
  }
  
// === ACTIVIT√âS ===
  let actsHTML = '';
  if (actsArray.length) {
    const a = actsArray.slice(0,8).map(t=>`‚Ä¢ ${safe(t)}`).join('<br>');
    actsHTML = `<p><strong>üéØ ${actsLbl}:</strong><br>${a}</p>`;
  } else {
    actsHTML = `<p><strong>üéØ ${actsLbl}:</strong><br>‚Äî</p>`;
  }

  // Stocker le step courant pour les modals
  window._currentPopupStep = step;
  window._currentPopupStepIdx = window.state?.steps?.findIndex(s => s.place_id === step?.place_id) ?? -1;

  // === BOUTONS SPONSORIS√âS (en haut) ===
  const targetLang = (document.documentElement.lang || 'fr').slice(0,2);
  const I18N_BOOKING = {
    bookActivity: {fr:'üé´ Activit√©s',en:'üé´ Activities',es:'üé´ Actividades',it:'üé´ Attivit√†',pt:'üé´ Atividades',ar:'üé´ ÿ£ŸÜÿ¥ÿ∑ÿ©'},
    bookTickets: {fr:'üéüÔ∏è Billets',en:'üéüÔ∏è Tickets',es:'üéüÔ∏è Entradas',it:'üéüÔ∏è Biglietti',pt:'üéüÔ∏è Bilhetes',ar:'üéüÔ∏è ÿ™ÿ∞ÿßŸÉÿ±'},
    bookShows: {fr:'üé≠ Spectacles',en:'üé≠ Shows',es:'üé≠ Espect√°culos',it:'üé≠ Spettacoli',pt:'üé≠ Espet√°culos',ar:'üé≠ ÿπÿ±Ÿàÿ∂'}
  };
  const tBook = (k) => I18N_BOOKING[k]?.[targetLang] || I18N_BOOKING[k]?.fr || k;

  const bookingCTA = `
    <div class="step-booking-cta" style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:14px;padding:12px;background:linear-gradient(135deg,#f0f7ff 0%,#e8f4f8 100%);border-radius:12px;border:1px solid #113f7a;">
      <button onclick="openGygModal(window._currentPopupStep, window._currentPopupStepIdx)" style="
        flex:1;min-width:90px;display:flex;align-items:center;justify-content:center;gap:4px;
        padding:10px 8px;background:linear-gradient(135deg,#ff5533 0%,#ff7744 100%);
        color:#fff;border:none;border-radius:10px;font-size:0.85rem;font-weight:700;cursor:pointer;
        box-shadow:0 3px 10px rgba(255,85,51,0.3);transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">${tBook('bookActivity')}</button>
      <button onclick="openTiqetsModal(window._currentPopupStep, window._currentPopupStepIdx)" style="
        flex:1;min-width:90px;display:flex;align-items:center;justify-content:center;gap:4px;
        padding:10px 8px;background:linear-gradient(135deg,#00a0e3 0%,#0077b6 100%);
        color:#fff;border:none;border-radius:10px;font-size:0.85rem;font-weight:700;cursor:pointer;
        box-shadow:0 3px 10px rgba(0,119,182,0.3);transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">${tBook('bookTickets')}</button>
      <button onclick="openTicketmasterModal(window._currentPopupStep, window._currentPopupStepIdx)" style="
        flex:1;min-width:90px;display:flex;align-items:center;justify-content:center;gap:4px;
        padding:10px 8px;background:linear-gradient(135deg,#026cdf 0%,#0653b6 100%);
        color:#fff;border:none;border-radius:10px;font-size:0.85rem;font-weight:700;cursor:pointer;
        box-shadow:0 3px 10px rgba(2,108,223,0.3);transition:transform 0.2s;
      " onmouseover="this.style.transform='scale(1.03)'" onmouseout="this.style.transform='scale(1)'">${tBook('bookShows')}</button>
    </div>
  `;

  // Injecter le HTML avec boutons EN HAUT
  const base = `
    ${bookingCTA}
    <div id="descVisits">${visitsHTML}</div>
    <div id="descActivities">${actsHTML}</div>
  `;
  
 $('#popupDesc').innerHTML = base;
  
  popup.classList.add('show');
}

let map,layer,markers=[],groupLabels=[],mapClickMode=false,popupLocked=false,autoRecenter=true,popupCloseTimer=null;

// Expose un getter stable vers "markers" sans changer sa gestion interne
window.ORT = window.ORT || {};
Object.defineProperty(window.ORT, 'markers', {
  get(){ return markers; },
  configurable: true
});
Object.defineProperty(window.ORT, 'groupLabels', {
  get(){ return groupLabels; },
  configurable: true
});

// Helper: notifier quand la liste est pr√™te/mise √† jour
function __notifyMarkersReady(){
  try{ window.dispatchEvent(new CustomEvent('ort:markers-ready')); }catch(_){}
}

// + autres lieux (hors itin√©raire)
let L_OTHER=null, OTHER_MARKERS=[];

function highlightMarker(idx){
  /* ... */
  const rows=$$('.step-row');   // liste de lignes
  if(rows[idx])rows[idx].classList.add('highlight');
}
function unhighlightMarker(idx){
  /* ... */
  const rows=$$('.step-row');   // liste de lignes
  if(rows[idx])rows[idx].classList.remove('highlight');
}

function drawMap(){
  if(!map){
    if(typeof L==='undefined'){console.error('Leaflet non charg√©');return}
  try{
map=L.map('map', {
    center: [0, 0],
    zoom: 2,
    zoomControl: false,
    attributionControl: true
  });
  // === DEBUG/FIX: exposer l'instance Leaflet de fa√ßon globale ===
  window.map = map;
  console.log('[MAP] Leaflet pr√™t ‚Üí window.map fix√©, getCenter? ', typeof window.map?.getCenter);

  // Recalcule automatique si le conteneur change de taille
  const _mapEl = document.getElementById('map');

  if (window.ResizeObserver && _mapEl) {
    const ro = new ResizeObserver(()=> map && map.invalidateSize());
    ro.observe(_mapEl);
  }

  // D√©tection langue navigateur
  const userLang=(navigator.language||'en').split('-')[0];

      console.log('Langue carte:',userLang);
      
         // Cartodb Voyager : meilleur multilingue gratuit avec noms en anglais
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',{
        maxZoom:20,
        attribution:'¬© CARTO ¬© OpenStreetMap'
      }).addTo(map);
      
      map.on('click',async e=>{
        if(!mapClickMode)return;
        const{lat,lng}=e.latlng;
        toast(t('identifying'));
        const place=await reverseGeocode(lat,lng);
        if(place){
          const newStep = {
            place_id: place.place_id,
            name: place.name,
            lat: place.lat,
            lon: place.lon,
            nights: 1,
            visits: [],
            activities: [],
            images: getPhotosForPlace(place.place_id)
          };
          // __sid unique d√®s la cr√©ation (√©vite fusion/s√©lection double)
          newStep.__sid = (typeof ensureSid === 'function')
            ? ensureSid(newStep)
            : (crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2)));

          state.steps.push(newStep);
          autoRecenter = true; // Recentrer apr√®s ajout
          
          // Recalculer les groupes/nuits sauf si mode manuel
          if(!state._manualMode) {
            autoCalculateNights(state.targetNights);
          }
          
          renderRows();
          toast(`‚úÖ ${place.name}`);
          mapClickMode=false;
        }
      });
      console.log('‚úÖ Carte initialis√©e');


// [J.3] Centrage global (une seule fois)
document.getElementById('centerRouteBtn')?.addEventListener('click', ()=>{
  const latlngs=[];
  (markers||[]).forEach(m=>{ const ll=m.getLatLng?.(); if(ll) latlngs.push([ll.lat,ll.lng]); });
  if(!latlngs.length){
    (state.steps||[]).forEach(s=>{
      if(Number.isFinite(s.lat)&&Number.isFinite(s.lon)) latlngs.push([s.lat,s.lon]);
    });
  }
  if(!latlngs.length) return;

  const bounds = L.latLngBounds(latlngs);
  const popupShown = document.getElementById('mapPopup')?.classList.contains('show');

  const padRight = popupShown ? 440 : 60; // 420px + marges pour √©viter que l‚Äôiti passe sous le popup
  map.fitBounds(bounds, {
    paddingTopLeft: [40,40],
    paddingBottomRight: [padRight,40]
  });

  // petite s√©curit√© pour les tuiles ‚Üí recalcule apr√®s animation
  setTimeout(()=>{ if (map?.invalidateSize) map.invalidateSize(); }, 80);
});
window.addEventListener('resize', ()=> {
  if (window.map?.invalidateSize) {
    window.map.invalidateSize();
  }
});      



/* === [OTHER-PLACES] Calque + bouton √† cocher (unique) === */
if(!L_OTHER) L_OTHER = L.layerGroup().addTo(map);

// ‚á¶ Passe en haut-GAUCHE pour ne plus recouvrir le layers-control
const OtherCtl = L.control({position:'topleft'});
OtherCtl.onAdd = function(){
  const div = L.DomUtil.create('div','leaflet-control');
  div.style.cssText = 'background:transparent;border:none;box-shadow:none';
  div.innerHTML = `
    <label style="display:flex;align-items:center;gap:6px;padding:8px 10px;font:600 13px/1 system-ui;background:#fff;border:2px solid #cfd6e4;border-radius:8px;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,.1)">
      <input id="toggleOtherPlaces" type="checkbox" style="margin:0;cursor:pointer;width:16px;height:16px">
      <span data-i18n="otherPlaces">Autres lieux</span>
    </label>`;
  L.DomEvent.disableClickPropagation(div);
  return div;
};

OtherCtl.addTo(map);

// Appliquer les traductions aux nouveaux √©l√©ments
if(typeof applyI18N === 'function') applyI18N();

// Charge le master si n√©cessaire AVANT d'afficher les points
const $togOther = document.getElementById('toggleOtherPlaces');
$togOther?.addEventListener('change', async (e) => {
  if (e.target.checked) {
    if (!PLACES_INDEX || !Object.keys(PLACES_INDEX).length) {
      await ensurePlacesIndex(); // ‚Üê garantit le chargement de CC.places.master.json
    }
    console.log('[OTHER] places dans master =', Object.keys(PLACES_INDEX || {}).length);
    renderOtherPlaces();
  } else {
    clearOtherPlaces();
  }
});


/* === [OTHER-PLACES] Rendu / hover / click === */
function clearOtherPlaces(){
  try{ L_OTHER?.clearLayers(); }catch(_){}	
  OTHER_MARKERS = [];
}

// Popup HTML au survol d‚Äôun ‚Äúautre lieu‚Äù
function otherHoverHTML(p){
  // On NE fait pas d‚Äôappel r√©seau ici (hover doit √™tre instantan√©).
  const photos = getPhotosForPlace(p.pid) || [];
  const img = photos[0] || null;
  const safe = (v)=>String(v||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  return `
    <div style="font:600 13px/1.2 system-ui;color:#0b3b6f">${safe(p.name||p.pid)}</div>
    ${img ? `<img src="${safe(img)}" alt="" style="display:block;width:220px;height:140px;object-fit:cover;border-radius:6px;margin-top:6px;border:1px solid #e5e7eb">` : ``}
    <div style="margin-top:6px;color:#475569;font:12px system-ui">
      <em>Place master (hors itin√©raire)</em>
    </div>
  `;
}

// ouverture du panneau lat√©ral existant avec bouton "Ajouter √† l'itin√©raire"
function openOtherPlaceDetails(p){
  const popup  = document.getElementById('mapPopup');
  const photos = document.getElementById('popupPhotos');
  const title  = document.getElementById('popupTitle');
  const desc   = document.getElementById('popupDesc');

  // 1) Titre / Photos carrousel
  if (title)  title.textContent = p.name || p.pid || '';
  if (photos) {
    photos.innerHTML = '';
    const imgs = (getPhotosForPlace(p.pid)||[]).slice(0,6);
    if (imgs.length) {
      const container = document.createElement('div');
      container.className = 'carousel-container';
      
      const mainImg = document.createElement('img');
      mainImg.className = 'carousel-img';
      mainImg.src = imgs[0];
      mainImg.alt = p.name || '';
      mainImg.onerror = () => mainImg.style.display = 'none';
      container.appendChild(mainImg);
      
      container.dataset.images = JSON.stringify(imgs);
      container.dataset.current = '0';
      
      if (imgs.length > 1) {
        const prevBtn = document.createElement('button');
        prevBtn.className = 'carousel-nav prev';
        prevBtn.innerHTML = '‚Äπ';
        prevBtn.type = 'button';
        prevBtn.onclick = () => { 
          let cur = parseInt(container.dataset.current || '0');
          cur = (cur - 1 + imgs.length) % imgs.length;
          container.querySelector('.carousel-img').src = imgs[cur];
          container.dataset.current = cur.toString();
          photos.querySelectorAll('.carousel-dot').forEach((d,i) => d.classList.toggle('active', i === cur));
        };
        
        const nextBtn = document.createElement('button');
        nextBtn.className = 'carousel-nav next';
        nextBtn.innerHTML = '‚Ä∫';
        nextBtn.type = 'button';
        nextBtn.onclick = () => {
          let cur = parseInt(container.dataset.current || '0');
          cur = (cur + 1) % imgs.length;
          container.querySelector('.carousel-img').src = imgs[cur];
          container.dataset.current = cur.toString();
          photos.querySelectorAll('.carousel-dot').forEach((d,i) => d.classList.toggle('active', i === cur));
        };
        
        container.appendChild(prevBtn);
        container.appendChild(nextBtn);
        
        const dots = document.createElement('div');
        dots.className = 'carousel-dots';
        imgs.forEach((_, i) => {
          const dot = document.createElement('button');
          dot.className = 'carousel-dot' + (i === 0 ? ' active' : '');
          dot.type = 'button';
          dot.onclick = () => {
            container.querySelector('.carousel-img').src = imgs[i];
            container.dataset.current = i.toString();
            photos.querySelectorAll('.carousel-dot').forEach((d,j) => d.classList.toggle('active', j === i));
          };
          dots.appendChild(dot);
        });
        photos.appendChild(container);
        photos.appendChild(dots);
      } else {
        photos.appendChild(container);
      }
    }
  }

  // 2) Contenus + bouton
  const visitsLbl = trLabel(document.documentElement.lang,'visits');
  const actsLbl   = trLabel(document.documentElement.lang,'activities');
  const v = (p.visits||[]).map(x=>safe(x.text||x)).slice(0,8).map(t=>'‚Ä¢ '+t).join('<br>') || '‚Äî';
  const a = (p.activities||[]).map(x=>safe(x.text||x)).slice(0,8).map(t=>'‚Ä¢ '+t).join('<br>') || '‚Äî';

  if (desc) {
    // vider puis injecter ‚Üí √©vite les handlers ‚Äúfant√¥mes‚Äù
    desc.textContent = '';
    desc.insertAdjacentHTML('afterbegin', `
      <p class="mut" style="margin:6px 0 10px">Lieu hors trajet (places master)</p>
      <p><strong>üèõÔ∏è ${visitsLbl}:</strong><br>${v}</p>
      <p><strong>üéØ ${actsLbl}:</strong><br>${a}</p>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
        <button id="btnAddOther" class="btn" type="button">+ Ajouter √† l‚Äôitin√©raire</button>
      </div>
    `);

    const addBtn = desc.querySelector('#btnAddOther');
    if (addBtn) {
      addBtn.addEventListener('click', ()=>{
        state.steps.push({
          place_id: p.pid,
          name: p.name,
          lat: p.lat,
          lon: p.lon,
          nights: 1,
          visits: Array.isArray(p.visits)? p.visits : [],
          activities: Array.isArray(p.activities)? p.activities : [],
          images: getPhotosForPlace(p.pid),
          description: (p.visits||[]).map(v=>v.text||v).join('. ')
        });
        autoRecenter = true; // Recentrer apr√®s ajout
        
        // Recalculer les groupes/nuits sauf si mode manuel
        if(!state._manualMode) {
          autoCalculateNights(state.targetNights);
        }
        
        renderRows();
        popup?.classList.remove('show');
        toast(`‚úÖ ${p.name} ajout√©`);
      }, { once: true }); // √©vite les doublons au re-clic
    }
  }

  // 3) Ouvrir le panneau
  if (popup) popup.classList.add('show');
}

// [OTHER] R√©solution robuste du code pays courant + cache process
function getCurrentCC(){
  // 0) cache process-wide
  if (typeof window.__CC_CACHE === 'string') return window.__CC_CACHE;

  // 1) depuis l'√©tat courant (ordre: state.cc > state.country > CC global)
  const fromState = (window.state?.cc || window.state?.country || window.CC || '').toString().trim().toUpperCase();
  if (/^[A-Z]{2}$/.test(fromState)) return (window.__CC_CACHE = fromState);

  // 2) depuis le voyage sauvegard√© (ex: savedTrip.country = 'FR')
  const fromSaved = (window.savedTrip?.country || '').toString().trim().toUpperCase();
  if (/^[A-Z]{2}$/.test(fromSaved)) return (window.__CC_CACHE = fromSaved);

  // 3) depuis la premi√®re √©tape du trip (prefixe "CC::slug")
  const pid = window.state?.steps?.find(s => typeof s?.place_id === 'string')?.place_id || '';
  const ccFromPid = (pid.split('::')[0] || '').toUpperCase();
  if (/^[A-Z]{2}$/.test(ccFromPid)) return (window.__CC_CACHE = ccFromPid);

  // 4) fallback: tenter une √©tape pr√©sente dans le master (si le pid existe)
  if (Array.isArray(window.state?.steps) && window.PLACES_INDEX) {
    for (const s of window.state.steps) {
      const pid2 = s?.place_id || '';
      if (pid2 && window.PLACES_INDEX[pid2]) {
        const cc2 = (pid2.split('::')[0] || '').toUpperCase();
        if (/^[A-Z]{2}$/.test(cc2)) return (window.__CC_CACHE = cc2);
      }
    }
  }

  // 5) √©chec ‚Üí valeur neutre
  return (window.__CC_CACHE = 'XX');
}

function renderOtherPlaces(){
  clearOtherPlaces();
  
  // Utiliser MarkerClusterGroup pour le clustering
  if(!L_OTHER) {
    L_OTHER = L.markerClusterGroup({
      maxClusterRadius: 50,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true,
      disableClusteringAtZoom: 10,
      iconCreateFunction: function(cluster) {
        const count = cluster.getChildCount();
        let size = 'small';
        if (count > 50) size = 'large';
        else if (count > 20) size = 'medium';
        
        return L.divIcon({
          html: '<div>' + count + '</div>',
          className: 'marker-cluster marker-cluster-' + size,
          iconSize: L.point(40, 40)
        });
      }
    }).addTo(map);
  }
  
  if(typeof PLACES_INDEX === 'undefined' || !PLACES_INDEX || !Object.keys(PLACES_INDEX).length){
    console.warn('[OTHER] PLACES_INDEX vide ‚Äì rien √† afficher');
    return;
  }

// set des place_id d√©j√† dans l'itin√©raire
  const inTrip = new Set((state.steps||[]).map(s=>s.place_id));

  // on limite au pays courant + hors itin (r√©solution robuste)
  const ccFilter = getCurrentCC();

  // si la restauration d'√©tat n'a pas fini et qu'on n'a pas encore pu d√©duire le pays,
  // on retente UNE fois dans la prochaine t√¢che (√©vite un appel trop t√¥t).
  if (ccFilter === 'XX' && !window.__OTHER_RETRY_LOCK__) {
    window.__OTHER_RETRY_LOCK__ = true;
    setTimeout(() => { window.__CC_CACHE = undefined; renderOtherPlaces(); }, 0);
    console.warn('[OTHER] ccFilter=XX ‚Üí retry deferred');
    return;
  }
  // reset du lock si on a un vrai CC
  if (ccFilter !== 'XX') window.__OTHER_RETRY_LOCK__ = false;

  const list = [];
  for(const pid in PLACES_INDEX){
    if(!pid.startsWith(ccFilter+'::')) continue;
    if(inTrip.has(pid)) continue;
    const m = PLACES_INDEX[pid];
    if(!Number.isFinite(m.lat)||!Number.isFinite(m.lon)) continue;
    list.push({
      pid, lat:m.lat, lon:m.lon,
      name:m.name||pid.split('::')[1],
      visits: m.visits || [],
      activities: m.activities || []
    });
  }

  console.log('[OTHER] ccFilter=', ccFilter, '| Lieux filtr√©s:', list.length);


  // (optionnel) limiter l‚Äôaffichage brut
  const MAX = 1500;
  const items = list.slice(0, MAX);

   items.forEach(p=>{
    // R√©cup√©rer rating pour couleur
    const rating = PLACES_INDEX[p.pid]?.rating || 0;
    const starInfo = ratingToStars(rating);
    
    let ico;
    
    if (starInfo.isStar) {
      // √âtoile pour les incontournables (5‚òÖ)
      ico = L.marker([p.lat, p.lon], {
        icon: createStarIcon(starInfo.color, 20)
      });
    } else {
      // Cercle pour les autres
      ico = L.circleMarker([p.lat, p.lon], {
        radius: starInfo.radius,
        fillColor: starInfo.color,
        color: '#fff',
        weight: 1.5,
        opacity: 1,
        fillOpacity: 0.8
      });
    }
    
    // Stocker starInfo pour le setStyle conditionnel
    ico.starInfo = starInfo;
    
    ico.addTo(L_OTHER);

    // Survol: tooltip sticky
    ico.bindTooltip(otherHoverHTML(p), {
      sticky: true, direction: 'top', opacity: 1, className: 'ort-hover'
    });
    ico.on('mouseover', ()=> ico.openTooltip());
    ico.on('mouseout',  ()=> ico.closeTooltip());

    // Clic: ouvre le panneau
    ico.on('click', ()=> openOtherPlaceDetails(p));
    OTHER_MARKERS.push(ico);
  });

}
    }catch(e){ console.error('Carte:', e); return; }
  }
  
  // Curseur pointeur en mode ajout
  if(mapClickMode){
    $('#map').classList.add('pointer-mode');
  }else{
    $('#map').classList.remove('pointer-mode');
  }
  markers.forEach(m=>m.remove());

  const pts=state.steps.filter(s=>s.lat!=null&&s.lon!=null);
  if(!pts.length){map.setView([48.8566,2.3522],5);return}
// [PATCH-GROUP-LABELS] START
// === Regrouper les √©tapes tr√®s proches (grille ~100‚Äì150 m) & labels communs ===
const grouped = {};
pts.forEach((p, idx) => {
  const key = `${p.lat.toFixed(3)},${p.lon.toFixed(3)}`; // tol√©rance ~100-150 m
  if (!grouped[key]) grouped[key] = [];
  grouped[key].push(idx);
});

Object.entries(grouped).forEach(([key, indices]) => {
  const [gLat, gLon] = key.split(',').map(Number);

  // 1) Marqueurs pile sur leur coord (aucun offset)
  indices.forEach((i) => {
    const step = pts[i];
    
    // R√©cup√©rer rating pour couleur
    let stepRating = step.rating || 0;
    if (!stepRating && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step.place_id]) {
      stepRating = PLACES_INDEX[step.place_id].rating || 0;
    }
    const starInfo = ratingToStars(stepRating);
    
    // Drapeau pour les hubs (√©tapes avec nuits)
    const isHub = step._isHub || (step.nights && step.nights > 0);
    const flagHtml = isHub ? '<span class="hub-flag">üö©</span>' : '';
    
    const iconHtml = `<div class="marker-num">${(i + 1)}${flagHtml}</div>`;
    const icon = L.divIcon({ html: iconHtml, className: 'step-marker', iconSize: [24, 24] });
        const m = L.marker([step.lat, step.lon], {
      draggable: true,
      icon,
      riseOnHover: true,
      riseOffset: 1000
    }).addTo(map);
    
    // Appliquer couleur avec !important
    setTimeout(() => {
      const el = m.getElement();
      if (el) {
        el.style.setProperty('background', starInfo.color, 'important');
        if (starInfo.textColor === '#333') {
          el.style.setProperty('color', '#333', 'important');
        }
      }
    }, 10);

    // ID stable et unique (pas bas√© sur l'index courant)
    m.stepId = (typeof ensureSid === 'function') ? ensureSid(step) : (step.__sid || (step.__sid = crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2))));
    markers.push(m);


    // hover
  // üéØ HOVER pour desktop - highlight la ligne mais PAS de popup auto
    m.on('mouseover', () => {
      const row = document.querySelector(`.step-row[data-step-id="${m.stepId}"]`);
      if(row){ row.classList.add('highlight'); row.scrollIntoView({block:'nearest', behavior: 'smooth'}); }
      m.getElement()?.querySelector('.marker-num')?.classList.add('num-boost');
      m.setZIndexOffset?.(1500);
      // Plus de popup automatique au survol
    });
    
    m.on('mouseout', () => {
      const row = document.querySelector(`.step-row[data-step-id="${m.stepId}"]`);
      if(row) row.classList.remove('highlight');
      m.getElement()?.querySelector('.marker-num')?.classList.remove('num-boost');
      m.setZIndexOffset?.(0);
      // Plus de masquage auto - le popup reste jusqu'au clic ailleurs
    });

    // CLIC: figer la popup avec bouton supprimer
    m.on('click', (e) => {
      const panelShown = document.getElementById('reorgPanel')?.classList.contains('show');
      const reorgMode  = document.body.classList.contains('reorg-active') || panelShown;
      if (reorgMode) return;
      
      e.originalEvent?.stopPropagation();
      
      window.popupLocked = true;
      showStepPreview(step);
      const popup = document.getElementById('mapPopup');
      popup?.classList.add('show');
      
      // Injecter bouton supprimer
      if (popup) {
        let deleteBtn = popup.querySelector('#deleteStepBtn');
        if (!deleteBtn) {
          deleteBtn = document.createElement('button');
          deleteBtn.id = 'deleteStepBtn';
          deleteBtn.className = 'btn danger';
          deleteBtn.textContent = t('deleteThisStep');
          deleteBtn.style.cssText = 'margin-top:16px;width:100%';
          document.getElementById('popupDesc')?.appendChild(deleteBtn);
        }
        
        deleteBtn.onclick = () => {
          if (confirm(`Supprimer "${step.name || step.place_id}" ?`)) {
            const idx = state.steps.indexOf(step);
            if (idx > -1) {
              state.steps.splice(idx, 1);
              autoRecenter = true; // Recentrer apr√®s suppression
              
              // Recalculer les groupes/nuits sauf si mode manuel
              if(!state._manualMode) {
                autoCalculateNights(state.targetNights);
              }
              
              renderRows();
              popup.classList.remove('show');
              window.popupLocked = false;
            }
          }
        };
      }
    });

    // üì± TAP LONG pour mobile/tablette (afficher preview en mode plein √©cran)
    let tapTimer = null;
    let touchMoved = false;
    
    m.on('touchstart', (e) => {
      touchMoved = false;
      const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
      
      // En mode plein √©cran : tap long = preview
      if(document.body.classList.contains('view-map-only') && !reorgActive){
        tapTimer = setTimeout(() => {
          if(!touchMoved){
            window.popupLocked = true; // Verrouiller pour √©viter la fermeture
            showStepPreview(step);
            m.getElement()?.querySelector('.marker-num')?.classList.add('num-boost');
          }
        }, 500); // 500ms = tap long
      }
    });
    
    m.on('touchmove', () => {
      touchMoved = true;
      if(tapTimer){ clearTimeout(tapTimer); tapTimer = null; }
    });
    
    m.on('touchend', () => {
      if(tapTimer){ clearTimeout(tapTimer); tapTimer = null; }
    });

       // dragend (MAJ imm√©diate des coords, reverse en arri√®re-plan)
    m.on('dragend', async e => {
      const ll = e.target.getLatLng();

      // 1) MAJ imm√©diate ‚Üí recalcul instantan√© des segments/compteurs
      step.lat = ll.lat;
      step.lon = ll.lng;
      renderRows(); // redessine markers, polyline, distances, totaux

      // 2) R√©solution place_id/name sans bloquer l'UI
      try{
        const place = await reverseGeocode(ll.lat, ll.lng);
        if(place){
          Object.assign(step, {
            lat: place.lat,
            lon: place.lon,
            place_id: place.place_id,
            name: place.name,
            images: getPhotosForPlace(place.place_id)
          });
          renderRows();
          toast(`‚úÖ ${place.name}`);
        }else{
          toast(t('positionUpdated'));
        }
      }catch(_){
        toast(t('positionUpdated'));
      }
    });

  });


  /// 2) Ajoute des mini-marqueurs individuels pour chaque sous-√©tape
  if (indices.length > 1) {
    indices.forEach((stepIndex, subIndex) => {
      const step = state.steps[stepIndex];
      const sid  = (typeof ensureSid === 'function') ? ensureSid(step) : (step.__sid || (step.__sid = crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2))));
      const stepNumber = stepIndex + 1;

      const angle = (subIndex / (indices.length - 1)) * Math.PI - Math.PI / 2;
      const radius = 0.0015;
      const offsetLat = step.lat + (Math.sin(angle) * radius);
      const offsetLon = step.lon + (Math.cos(angle) * radius);

      const miniMarker = L.marker([offsetLat, offsetLon], {
        icon: L.divIcon({
          html: `<div class="mini-step-marker" data-step-id="${sid}">
                   <div class="mini-step-num">${stepNumber}</div>
                 </div>`,
          className: '',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        }),
        interactive: true,
        zIndexOffset: 100 + subIndex
      }).addTo(map);

      // Stocker le stepId sur le marqueur
      miniMarker.stepId = sid;
      miniMarker.isMiniMarker = true;
      
      // √âv√©nements hover pour agrandir
      // √âv√©nements hover pour agrandir (mais PAS de popup auto)
      miniMarker.on('mouseover', function() {
        const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
        if (el) {
          el.classList.add('mini-step-marker-hover');
        }
        // Plus de popup automatique
      });
      
      miniMarker.on('mouseout', function() {
        const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
        if (el) {
          el.classList.remove('mini-step-marker-hover');
        }
        // Plus de masquage auto
      });
      
      // Stocker dans groupLabels pour pouvoir les g√©rer en mode r√©org
      groupLabels.push(miniMarker);
    });
  }
});
// [PATCH-GROUP-LABELS] END

// ===== FONCTIONS DE CALCUL D'ITIN√âRAIRE =====

/**
 * Calcule un itin√©raire selon le mode de transport
 */
async function calculateRoute(waypoints, mode = 'driving') {
  console.log('[ROUTE] üó∫Ô∏è Calcul itin√©raire:', mode, waypoints.length, 'points');
  
  const modeConfig = TRANSPORT_MODES[mode];
  if (!modeConfig) {
    console.error('[ROUTE] Mode inconnu:', mode);
    return { type: 'fallback', coordinates: waypoints };
  }
  
  if (modeConfig.api === 'osrm') {
    return calculateOSRMRoute(waypoints, mode);
  }
  
  if (modeConfig.api === 'mapbox') {
    return calculateMapboxRoute(waypoints, mode);
  }
  
  return { type: 'fallback', coordinates: waypoints };
}

/**
 * Calcul route OSRM (voiture, v√©lo, pieds)
 */
async function calculateOSRMRoute(waypoints, mode) {
  try {
    // Profils OSRM : car (driving), bike (cycling), foot (walking)
    const osrmProfile = mode === 'driving' ? 'car' : mode === 'cycling' ? 'bike' : 'foot';
    
    // Format OSRM : lon,lat;lon,lat;...
    const coordsStr = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
    
    // URL OSRM public - avec annotations pour avoir les distances par segment
    const osrmUrl = `https://router.project-osrm.org/route/v1/${osrmProfile}/${coordsStr}?overview=full&geometries=geojson&steps=false&annotations=distance,duration`;
    
    console.log('[OSRM] üöó Requ√™te:', osrmUrl.substring(0, 100) + '...');
    
    const response = await fetch(osrmUrl).catch(err => {
      console.warn('[OSRM] ‚ö†Ô∏è Erreur fetch:', err.message);
      return null;
    });
    if (!response) return { type: 'fallback', coordinates: waypoints };
    const data = await response.json().catch(err => {
      console.warn('[OSRM] ‚ö†Ô∏è Erreur JSON:', err.message);
      return null;
    });
    if (!data) return { type: 'fallback', coordinates: waypoints };
    
    if (data.code === 'Ok' && data.routes && data.routes[0]) {
      const route = data.routes[0];
      const coordinates = route.geometry.coordinates.map(c => [c[1], c[0]]);
      
      // Extraire les distances par leg (segment entre 2 waypoints)
      const legs = route.legs || [];
      const legDistances = legs.map(leg => ({
        distance_km: Math.round(leg.distance / 1000 * 10) / 10,
        duration_min: Math.round(leg.duration / 60)
      }));
      
      console.log('[OSRM] ‚úÖ Route calcul√©e:', {
        distance: (route.distance / 1000).toFixed(1) + ' km',
        duration: (route.duration / 3600).toFixed(1) + ' h',
        points: coordinates.length,
        legs: legDistances.length
      });
      
      // Stocker les distances dans state.steps si disponible
      if (window.state?.steps && legDistances.length > 0) {
        legDistances.forEach((leg, i) => {
          if (state.steps[i]) {
            state.steps[i]._osrmDistanceKm = leg.distance_km;
            state.steps[i]._osrmDurationMin = leg.duration_min;
          }
        });
        console.log('[OSRM] ‚úÖ Distances inject√©es dans', legDistances.length, '√©tapes');
      }
      
      return {
        type: 'osrm',
        mode: mode,
        coordinates: coordinates,
        distance: route.distance,
        duration: route.duration,
        legs: legDistances,
        color: mode === 'cycling' ? '#00bcd4' : mode === 'walking' ? '#4caf50' : '#113f7a'
      };
    }
    
    throw new Error('OSRM: Pas de route trouv√©e');
    
  } catch (error) {
    console.warn('[OSRM] ‚ö†Ô∏è Erreur:', error.message);
    return { type: 'fallback', coordinates: waypoints };
  }
}

/**
/**
 * Calcul route Mapbox (train, m√©tro, bus, voiture)
 */
async function calculateMapboxRoute(waypoints, mode) {
  try {
    const accessToken = window.ORT_CONFIG?.MAPBOX_ACCESS_TOKEN;
    const baseUrl = window.ORT_CONFIG?.MAPBOX_BASE_URL || 'https://api.mapbox.com/directions/v5/mapbox';
    
    if (!accessToken) {
      console.warn('[MAPBOX] ‚ö†Ô∏è Token manquant');
      toast('‚ö†Ô∏è Mapbox : token requis (voir ort-config.js)', 4000);
      return { type: 'fallback', coordinates: waypoints, color: '#ff5722', dashArray: '10, 5' };
    }
    
    // Mode Mapbox : driving-traffic / walking / cycling / driving
    // Pour transit, on utilise un profil sp√©cial ou on combine
    const mapboxProfile = mode === 'transit' ? 'driving' : mode;
    
    console.log('[MAPBOX] üó∫Ô∏è Profil:', mapboxProfile);
    
    // Mapbox limite √† 25 waypoints par requ√™te
    if (waypoints.length > 25) {
      console.warn('[MAPBOX] ‚ö†Ô∏è Trop de waypoints (', waypoints.length, '), simplification...');
      // Garder seulement les points importants (d√©but, fin, et quelques interm√©diaires)
      const step = Math.ceil(waypoints.length / 24);
      const simplified = waypoints.filter((_, i) => i === 0 || i === waypoints.length - 1 || i % step === 0);
      waypoints = simplified;
      console.log('[MAPBOX] ‚úÖ Simplifi√© √†', waypoints.length, 'waypoints');
    }
    
    // Format Mapbox : lon,lat;lon,lat;...
    const coordsStr = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
    
    // URL Mapbox Directions
    const mapboxUrl = `${baseUrl}/${mapboxProfile}/${coordsStr}?geometries=geojson&overview=full&access_token=${accessToken}`;
    
    console.log('[MAPBOX] üöÄ Requ√™te:', mapboxUrl.substring(0, 120) + '...');
    
    const response = await fetch(mapboxUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
      throw new Error('Aucune route trouv√©e');
    }
    
    const route = data.routes[0];
    const coordinates = route.geometry.coordinates.map(c => [c[1], c[0]]); // [lon,lat] ‚Üí [lat,lon]
    
    console.log('[MAPBOX] ‚úÖ Route calcul√©e:', {
      distance: (route.distance / 1000).toFixed(1) + ' km',
      duration: (route.duration / 3600).toFixed(1) + ' h',
      points: coordinates.length
    });
    
    // Couleur selon le mode
    let color = '#113f7a'; // Bleu par d√©faut (voiture)
    let dashArray = null;
    
    if (mode === 'transit') {
      color = '#ff5722'; // Rouge pour train
      dashArray = '10, 5'; // Pointill√©s
    } else if (mode === 'cycling') {
      color = '#00bcd4'; // Cyan pour v√©lo
    } else if (mode === 'walking') {
      color = '#4caf50'; // Vert pour pieds
    }
    
    return {
      type: 'mapbox',
      mode: mode,
      coordinates: coordinates,
      distance: route.distance, // m√®tres
      duration: route.duration, // secondes
      color: color,
      weight: 3,
      dashArray: dashArray
    };
    
  } catch (error) {
    console.error('[MAPBOX] ‚ùå Erreur:', error);
    toast('‚ùå Erreur Mapbox : ' + error.message, 3000);
    return { 
      type: 'fallback', 
      coordinates: waypoints, 
      color: '#ff5722', 
      dashArray: '10, 5' 
    };
  }
}
// ===== FIN FONCTIONS DE CALCUL =====

  // supprimer l'ancienne polyline si pr√©sente
  if (layer) { try { map.removeLayer(layer); } catch(_) {} layer = null; }

  const latlngs = pts.map(p => [p.lat, p.lon]);
  
  // ===== CALCUL DE ROUTE SELON LE MODE =====
  const transportMode = getTransportMode();
  console.log('[MAP] üó∫Ô∏è Mode de transport actif:', transportMode);
  
  // Afficher ligne temporaire pendant calcul
  const tempLayer = L.polyline(latlngs, { 
    color: '#113f7a', 
    weight: 2, 
    opacity: 0.3, 
    dashArray: '5, 10' 
  }).addTo(map);
  
  // Calculer la route
  calculateRoute(latlngs, transportMode).then(result => {
    // Supprimer ligne temporaire
    try { map.removeLayer(tempLayer); } catch(_) {}
    
    if (result.type === 'fallback') {
      // Fallback : ligne droite
      console.log('[MAP] ‚ö†Ô∏è Fallback: ligne droite');
      layer = L.polyline(result.coordinates, { 
        color: result.color || '#113f7a', 
        weight: 3, 
        opacity: 0.8,
        dashArray: result.dashArray || null
      }).addTo(map);
    } else {
      // Route calcul√©e
      console.log('[MAP] ‚úÖ Route affich√©e:', result.type);
      layer = L.polyline(result.coordinates, { 
        color: result.color || '#113f7a', 
        weight: result.weight || 3, 
        opacity: 0.8,
        dashArray: result.dashArray || null
      }).addTo(map);
      
      // Afficher les infos dans un toast
      if (result.distance && result.duration) {
        const distKm = (result.distance / 1000).toFixed(1);
        const durationH = (result.duration / 3600).toFixed(1);
        toast(`üìç ${distKm} km ‚Ä¢ üïê ${durationH}h`, 3000);
      }
    }
  }).catch(error => {
    console.error('[MAP] ‚ùå Erreur calcul route:', error);
    try { map.removeLayer(tempLayer); } catch(_) {}
    layer = L.polyline(latlngs, { color: '#113f7a', weight: 3, opacity: 0.8 }).addTo(map);
  });
  
  // ===== FIN CALCUL DE ROUTE =====


// Centrage adaptatif selon le popup - SEULEMENT si autoRecenter
  if (autoRecenter) {
    const popupVisible = document.getElementById('mapPopup')?.classList.contains('show');
    
    // Si popup visible : r√©server de l'espace √† droite, sinon padding sym√©trique
    const fitOptions = popupVisible 
      ? { paddingTopLeft: [60, 40], paddingBottomRight: [440, 40] }
      : { paddingTopLeft: [60, 40], paddingBottomRight: [60, 40] };
    
    map.fitBounds(L.latLngBounds(latlngs), fitOptions);
    
    // Force le recalcul de la taille du conteneur APR√àS fitBounds
    setTimeout(() => {
      if (map && map.invalidateSize) {
        map.invalidateSize();
        // Re-fit apr√®s recalcul avec les m√™mes options
        map.fitBounds(L.latLngBounds(latlngs), fitOptions);
      }
    }, 150);
    
    // D√©sactiver le recentrage automatique apr√®s le premier rendu
    autoRecenter = false;
  }  
  // Notifier que les marqueurs sont pr√™ts  // Notifier que les marqueurs sont pr√™ts
  __notifyMarkersReady();
}

async function reverseGeocode(lat,lon){
  try{
    // IMPORTANT : forcer la langue anglaise pour Nominatim
    const nomUrl=`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en&zoom=10`;
    const nomRes=await fetch(nomUrl,{headers:{'User-Agent':'OneRoadTrip/1.0'}});
    const nomData=await nomRes.json();
    
    if(!nomData||!nomData.address){
      toast(t('placeNotFound'));
      return null;
    }
    
    console.log('Nominatim data:',nomData);
    
    const addr=nomData.address;
    // Essayer plusieurs champs pour trouver le nom de la ville
    const cityRaw=addr.city||addr.town||addr.village||addr.municipality||addr.county||addr.state;
    const country=addr.country_code?.toUpperCase()||'XX';
    
    if(!cityRaw){
      toast(t('cityNotFound'));
      return null;
    }
    
    console.log('Nominatim city (EN):',cityRaw,country);
    
    // Le nom anglais de Nominatim devrait correspondre √† ce qu'on voit sur la carte CARTO
    // Pas besoin de recherche suppl√©mentaire si on a un bon r√©sultat
    const slug=cityRaw.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
    
    // V√©rifier avec l'API Search pour avoir des coordonn√©es pr√©cises
try{
  const searchUrl = `http://localhost:3031/citysearch?q=${encodeURIComponent(cityRaw)}&country=${country}&lang=en&limit=10`;
  console.log('API Search:',searchUrl);
  const searchRes=await fetch(searchUrl);

      
      if(searchRes.ok){
        const searchData=await searchRes.json();
        const items=searchData.items||[];
        console.log('API Results:',items.length,'items');
        
        if(items.length>0){
          // Prendre le premier r√©sultat qui correspond au nom
          const exactMatch=items.find(item=>item.name.toLowerCase()===cityRaw.toLowerCase());
          if(exactMatch&&exactMatch.lat&&exactMatch.lon){
            const slug2=exactMatch.name.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
            console.log('Exact match:',exactMatch.name);
            return{place_id:`${exactMatch.countryCode}::${slug2}`,name:exactMatch.name,lat:exactMatch.lat,lon:exactMatch.lon};
          }
          
          // Sinon chercher le plus proche g√©ographiquement
          let best=null,minDist=Infinity;
          for(const item of items){
            if(!item.lat||!item.lon)continue;
            const dist=Math.sqrt(Math.pow(item.lat-lat,2)+Math.pow(item.lon-lon,2));
            if(dist<minDist){minDist=dist;best=item}
          }
          
          if(best&&minDist<0.5){
            const slug3=best.name.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
            console.log('Best match:',best.name,'distance:',minDist);
            return{place_id:`${best.countryCode}::${slug3}`,name:best.name,lat:best.lat,lon:best.lon};
          }
        }
      }
    }catch(e){
      console.error('API Search error:',e);
    }
    
    // Fallback: nom anglais de Nominatim (devrait correspondre √† la carte)
    console.log('Using Nominatim result:',cityRaw);
    return{place_id:`${country}::${slug}`,name:cityRaw,lat:lat,lon:lon};
    
  }catch(err){
    console.error('Geocode error:',err);
    toast(t('identificationError'));
    return null;
  }
}

function enableDnD(){
  $$('.step-row').forEach(r=>{
    r.addEventListener('dragstart',e=>{r.classList.add('dragging');e.dataTransfer.setData('text/plain',r.dataset.index)});
    r.addEventListener('dragend',()=>r.classList.remove('dragging'));
  });
  const box=$('#rows');
  box.addEventListener('dragover',e=>{
    e.preventDefault();
    const after=getDragAfterElement(box,e.clientY);
    const dragging=$('.step-row.dragging');
    if(!dragging)return;
    if(after==null)box.appendChild(dragging);else box.insertBefore(dragging,after);
  });
  box.addEventListener('drop',()=>{
    const newOrder=$$('.step-row').map(x=>Number(x.dataset.index));
    state.steps=newOrder.map(i=>state.steps[i]);
    renderRows();
  });
}

function getDragAfterElement(container,y){
  const els=[...container.querySelectorAll('.step-row:not(.dragging)')];
  return els.reduce((closest,child)=>{
    const box=child.getBoundingClientRect();
    const offset=y-box.top-box.height/2;
    if(offset<0&&offset>closest.offset)return{offset,element:child};
    return closest;
  },{offset:Number.NEGATIVE_INFINITY}).element;
}


document.addEventListener('change',e=>{
  if(e.target.matches('input[type="number"]')&&e.target.dataset.idx!==undefined){
    const idx=Number(e.target.dataset.idx);
    state.steps[idx].nights=Math.max(0,Math.min(30,Number(e.target.value||0)));
    renderRows(); // <-- re-render pour injecter/retirer la colonne H√¥tel
  }
});



// ===== TRANSPORT MODE MULTI-MODAL =====
const getTransportMode = ()=> localStorage.getItem('ort.transportMode') || 'driving';
const setTransportMode = (m)=> localStorage.setItem('ort.transportMode', m);

// Configuration des modes disponibles par pays
const TRANSPORT_MODES = {
  // Modes OSRM (disponibles partout)
  driving: { 
    label: 'üöó Voiture', 
    api: 'osrm', 
    countries: '*' 
  },
  cycling: { 
    label: 'üö¥ V√©lo', 
    api: 'osrm', 
    countries: '*' 
  },
  walking: { 
    label: 'üö∂ Pieds', 
    api: 'osrm', 
    countries: '*' 
  },
  
  // Modes Navitia (France + Europe uniquement)
  transit: { 
    label: 'üöÜ Train/M√©tro', 
    api: 'navitia', 
    countries: ['FR', 'DE', 'BE', 'CH', 'LU', 'NL', 'ES', 'IT', 'GB'] 
  }
};

// D√©terminer quels modes sont disponibles selon le pays
function getAvailableModes() {
  const currentCountry = window.state?.cc || state?.country || 'FR';
  console.log('[TRANSPORT] Pays actuel:', currentCountry);
  
  return Object.entries(TRANSPORT_MODES).filter(([key, config]) => {
    if (config.countries === '*') return true;
    return config.countries.includes(currentCountry);
  });
}

// Construire le menu des modes

$('#btnSave').onclick = async ()=>{
  const u = currentUser();
  if(!u){ toast(t('loginToSave')); return; }

  // == reconstitue le r√©sum√© comme dans scheduleAutosave() ==
  const rid = ensureRid();
  const nights = (state.steps||[]).reduce((s,x)=> s + Number(x.nights||0), 0);
  const exportedTitle = state.title || 'Voyage';

  // coords moyennes + chemin
  const stepsCoords = (state.steps||[])
    .map(s => (Number.isFinite(s.lat) && Number.isFinite(s.lon)) ? [s.lat, s.lon] : null)
    .filter(Boolean);
  const coords = stepsCoords.length ? [
    +(stepsCoords.reduce((a,p)=>a+p[0],0)/stepsCoords.length).toFixed(5),
    +(stepsCoords.reduce((a,p)=>a+p[1],0)/stepsCoords.length).toFixed(5)
  ] : null;
  const coordsPath = stepsCoords.length >= 2 ? stepsCoords : null;

  // cover si dispo
  let coverUrl = document.querySelector('#rtCover img, .hero img, .cover img')?.src || null;

  const summary = {
    id: rid,
    tripId: rid,
    title: exportedTitle,
    country: state.country || 'XX',
    nights,
    kms: Number((typeof TOTALS!=='undefined' && TOTALS.km) || 0),
    steps: (state.steps||[]).length,
    pace: (typeof getTransportMode==='function' ? (getTransportMode()==='car'?'auto':'train') : 'auto'),
    tags: Array.from(new Set((state.steps||[]).flatMap(s => s.tags || []))).slice(0, 6),
    detailUrl: location.href,
    coords,
    coordsPath,
    coverUrl
  };
// ‚Äî Sauvegarde "plein" pour ouverture/partage par rid ‚Äî
// cl√©: ort.rt::<uid>::<rid>
try{
  const full = {
    ts: Date.now(),
    rid,
    uid: u.uid,
    state,           // √©tapes, nuits, etc. (objet complet)
    totals: TOTALS   // km/min recalcul√©s
  };
  localStorage.setItem(`ort.rt::${u.uid}::${rid}`, JSON.stringify(full));
}catch(_){}

// Sauvegarde via State Manager avec flag saved=true
  if (window.ORT_DETAIL_ADAPTER && typeof window.ORT_DETAIL_ADAPTER.saveCurrent === 'function') {
    console.log('[SAVE] Sauvegarde via State Manager');
    await window.ORT_DETAIL_ADAPTER.saveCurrent(true);
  }
  
  ORTSaves.upsert(u, summary);
  toast(t('saved'));
  
  // R√©initialiser le flag de modifications non sauvegard√©es
  if (typeof clearUnsavedChanges === 'function') clearUnsavedChanges();
};

$('#btnExport').onclick=()=>{
  downloadJSON(`roadtrip_${state.country}_${Date.now()}.json`,{title:state.title,country:state.country,steps:state.steps});
  toast(t('exported'));
};

// Bouton r√©organiser h√¥tels (cycle entre 5 strat√©gies)
$('#btnReorganizeHotels').onclick=()=>{
  if(!state.maxHotels || state.maxHotels >= state.steps.length){
    toast('‚ö†Ô∏è Regroupement non applicable (maxHotels non d√©fini)');
    return;
  }
  
  const currentStrategy = state._currentGroupStrategy || 1;
  const nextStrategy = (currentStrategy % 5) + 1;
  
  const strategyNames = {
    1: '√âquilibr√©',
    2: 'Par r√©gion',
    3: 'Meilleures notes',
    4: 'Moins de trajets',
    5: 'Grandes villes'
  };
  
  // autoGroupHotels supprim√©
  renderRows();
  toast(`üè® Strat√©gie: ${strategyNames[nextStrategy]} (${nextStrategy}/5)`);
};

// Bouton Annuler les groupes - r√©initialiser pour d√©cision manuelle
$('#btnResetGroups').onclick=()=>{
  const lang = document.documentElement.lang || 'fr';
  const confirmMsg = {
    fr: 'Annuler tous les groupements automatiques et h√¥tels ?\n\nChaque √©tape aura 0 nuit et vous pourrez configurer manuellement.',
    en: 'Cancel all automatic groupings and hotels?\n\nEach step will have 0 nights and you can configure manually.',
    it: 'Annullare tutti i raggruppamenti automatici e gli hotel?\n\nOgni tappa avr√† 0 notti e potrai configurare manualmente.',
    es: '¬øCancelar todas las agrupaciones autom√°ticas y hoteles?\n\nCada etapa tendr√° 0 noches y podr√°s configurar manualmente.',
    pt: 'Cancelar todos os agrupamentos autom√°ticos e hot√©is?\n\nCada etapa ter√° 0 noites e voc√™ poder√° configurar manualmente.',
    ar: 'ÿ•ŸÑÿ∫ÿßÿ° ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ¨ŸÖŸäÿπÿßÿ™ ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿäÿ© ŸàÿßŸÑŸÅŸÜÿßÿØŸÇÿü\n\nŸÉŸÑ ŸÖÿ≠ÿ∑ÿ© ÿ≥ÿ™ÿ≠ÿµŸÑ ÿπŸÑŸâ 0 ŸÑŸäŸÑÿ© ŸàŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ™ŸáŸäÿ¶ÿ© ŸäÿØŸàŸäÿßŸã.'
  };
  
  if(!confirm(confirmMsg[lang] || confirmMsg.fr)) return;
  
  // R√©initialiser toutes les √©tapes
  state.steps.forEach((step, idx) => {
    // Supprimer les propri√©t√©s de groupement
    delete step.groupName;
    delete step.groupColor;
    delete step._isHub;
    delete step._isSatellite;
    delete step._hubGroup;
    delete step._satellites;
    delete step._mergedInto;
    
    // R√©initialiser les nuits √† 0 pour forcer d√©cision manuelle
    step.nights = 0;
    
    // Supprimer l'h√¥tel s√©lectionn√©
    delete step.hotel;
    delete step.hotelName;
    delete step.hotelPrice;
    delete step.hotelRating;
    delete step.hotelUrl;
    delete step.hotelPhoto;
  });
  
  // Supprimer le flag de strat√©gie
  delete state._currentGroupStrategy;
  
  // Activer le mode manuel (ne pas recalculer auto apr√®s suppression)
  state._manualMode = true;
  
  // Re-render
  renderRows();
  
  const successMsg = {
    fr: '‚úÖ Groupes et h√¥tels r√©initialis√©s. Ajoutez des nuits manuellement.',
    en: '‚úÖ Groups and hotels reset. Add nights manually.',
    it: '‚úÖ Gruppi e hotel reimpostati. Aggiungi notti manualmente.',
    es: '‚úÖ Grupos y hoteles reiniciados. A√±ade noches manualmente.',
    pt: '‚úÖ Grupos e hot√©is redefinidos. Adicione noites manualmente.',
    ar: '‚úÖ ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÖÿ¨ŸÖŸàÿπÿßÿ™ ŸàÿßŸÑŸÅŸÜÿßÿØŸÇ. ÿ£ÿ∂ŸÅ ÿßŸÑŸÑŸäÿßŸÑŸä ŸäÿØŸàŸäÿßŸã.'
  };
  toast(successMsg[lang] || successMsg.fr);
};

function downloadJSON(filename,obj){
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function toast(msg){
  const t=document.createElement('div');
  t.textContent=msg;
  t.style.cssText='position:fixed;left:50%;transform:translateX(-50%);bottom:20px;z-index:9999;background:#113f7a;color:#fff;border:1px solid #ffffff55;border-radius:10px;padding:10px 14px;box-shadow:0 4px 14px rgba(0,0,0,.2)';
  document.body.appendChild(t);
  setTimeout(()=>t.remove(),3000);
}

// === Alerte de coh√©rence jours demand√©s vs recommand√©s ===
function showCoherenceAlert(userDays, recommendedDays, rythme){
  const lang = document.documentElement.lang || 'fr';
  
  const i18n = {
    fr: {
      title: '‚ö†Ô∏è Dur√©e potentiellement insuffisante',
      message: (u, r, ry) => `Vous avez choisi <strong>${u} jours</strong> avec un rythme <strong>${ry}</strong>.<br>Pour cet itin√©raire, nous recommandons au minimum <strong>${r} jours</strong>.`,
      warning: 'Un voyage trop court pourrait rendre l\'exp√©rience moins agr√©able avec des journ√©es trop charg√©es.',
      keep: (d) => `Garder ${d} jours`,
      adjust: (d) => `${d} jours (recommand√©)`,
      custom: 'Personnaliser',
      customPrompt: 'Entrez le nombre de jours souhait√© :',
      rythme: { slow: 'lent', normal: 'normal', fast: 'rapide' }
    },
    en: {
      title: '‚ö†Ô∏è Duration potentially insufficient',
      message: (u, r, ry) => `You chose <strong>${u} days</strong> with a <strong>${ry}</strong> pace.<br>For this itinerary, we recommend at least <strong>${r} days</strong>.`,
      warning: 'A trip that\'s too short could make the experience less enjoyable with overly busy days.',
      keep: (d) => `Keep ${d} days`,
      adjust: (d) => `${d} days (recommended)`,
      custom: 'Customize',
      customPrompt: 'Enter the desired number of days:',
      rythme: { slow: 'slow', normal: 'normal', fast: 'fast' }
    },
    it: {
      title: '‚ö†Ô∏è Durata potenzialmente insufficiente',
      message: (u, r, ry) => `Hai scelto <strong>${u} giorni</strong> con un ritmo <strong>${ry}</strong>.<br>Per questo itinerario, raccomandiamo almeno <strong>${r} giorni</strong>.`,
      warning: 'Un viaggio troppo breve potrebbe rendere l\'esperienza meno piacevole con giornate troppo intense.',
      keep: (d) => `Mantieni ${d} giorni`,
      adjust: (d) => `${d} giorni (consigliato)`,
      custom: 'Personalizza',
      customPrompt: 'Inserisci il numero di giorni desiderato:',
      rythme: { slow: 'lento', normal: 'normale', fast: 'veloce' }
    },
    es: {
      title: '‚ö†Ô∏è Duraci√≥n potencialmente insuficiente',
      message: (u, r, ry) => `Has elegido <strong>${u} d√≠as</strong> con un ritmo <strong>${ry}</strong>.<br>Para este itinerario, recomendamos al menos <strong>${r} d√≠as</strong>.`,
      warning: 'Un viaje demasiado corto podr√≠a hacer la experiencia menos agradable con d√≠as muy cargados.',
      keep: (d) => `Mantener ${d} d√≠as`,
      adjust: (d) => `${d} d√≠as (recomendado)`,
      custom: 'Personalizar',
      customPrompt: 'Introduce el n√∫mero de d√≠as deseado:',
      rythme: { slow: 'lento', normal: 'normal', fast: 'r√°pido' }
    },
    pt: {
      title: '‚ö†Ô∏è Dura√ß√£o potencialmente insuficiente',
      message: (u, r, ry) => `Voc√™ escolheu <strong>${u} dias</strong> com um ritmo <strong>${ry}</strong>.<br>Para este itiner√°rio, recomendamos pelo menos <strong>${r} dias</strong>.`,
      warning: 'Uma viagem muito curta pode tornar a experi√™ncia menos agrad√°vel com dias muito cheios.',
      keep: (d) => `Manter ${d} dias`,
      adjust: (d) => `${d} dias (recomendado)`,
      custom: 'Personalizar',
      customPrompt: 'Digite o n√∫mero de dias desejado:',
      rythme: { slow: 'lento', normal: 'normal', fast: 'r√°pido' }
    },
    ar: {
      title: '‚ö†Ô∏è ÿßŸÑŸÖÿØÿ© ŸÇÿØ ÿ™ŸÉŸàŸÜ ÿ∫Ÿäÿ± ŸÉÿßŸÅŸäÿ©',
      message: (u, r, ry) => `ÿßÿÆÿ™ÿ±ÿ™ <strong>${u} ÿ£ŸäÿßŸÖ</strong> ÿ®Ÿàÿ™Ÿäÿ±ÿ© <strong>${ry}</strong>.<br>ŸÑŸáÿ∞ÿß ÿßŸÑŸÖÿ≥ÿßÿ±ÿå ŸÜŸàÿµŸä ÿ®ŸÄ <strong>${r} ÿ£ŸäÿßŸÖ</strong> ÿπŸÑŸâ ÿßŸÑÿ£ŸÇŸÑ.`,
      warning: 'ŸÇÿØ ÿ™ÿ¨ÿπŸÑ ÿßŸÑÿ±ÿ≠ŸÑÿ© ÿßŸÑŸÇÿµŸäÿ±ÿ© ÿ¨ÿØÿßŸã ÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿ£ŸÇŸÑ ŸÖÿ™ÿπÿ© ŸÖÿπ ÿ£ŸäÿßŸÖ ŸÖÿ≤ÿØÿ≠ŸÖÿ© ŸÑŸÑÿ∫ÿßŸäÿ©.',
      keep: (d) => `ÿßŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏ ÿ®ŸÄ ${d} ÿ£ŸäÿßŸÖ`,
      adjust: (d) => `${d} ÿ£ŸäÿßŸÖ (ŸÖŸàÿµŸâ ÿ®Ÿá)`,
      custom: 'ÿ™ÿÆÿµŸäÿµ',
      customPrompt: 'ÿ£ÿØÿÆŸÑ ÿπÿØÿØ ÿßŸÑÿ£ŸäÿßŸÖ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®:',
      rythme: { slow: 'ÿ®ÿ∑Ÿäÿ°', normal: 'ÿπÿßÿØŸä', fast: 'ÿ≥ÿ±Ÿäÿπ' }
    }
  };
  
  const t = i18n[lang] || i18n.fr;
  const rythmeLabel = t.rythme[rythme] || rythme;
  
  const overlay = document.createElement('div');
  overlay.id = 'coherenceAlert';
  overlay.style.cssText = 'position:fixed;inset:0;z-index:99999;background:rgba(0,0,0,.7);display:flex;align-items:center;justify-content:center';
  
  overlay.innerHTML = `
    <div style="background:#fff;border-radius:14px;max-width:500px;width:90%;padding:24px;box-shadow:0 20px 60px rgba(0,0,0,.3)">
      <h3 style="margin:0 0 16px;color:#dc2626;font-size:20px">${t.title}</h3>
      <p style="color:#334155;line-height:1.6;margin-bottom:20px">
        ${t.message(userDays, recommendedDays, rythmeLabel)}
      </p>
      <p style="color:#64748b;font-size:14px;margin-bottom:20px">
        ${t.warning}
      </p>
      <div style="display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap">
        <button id="alertKeep" style="padding:10px 16px;border-radius:8px;border:1px solid #e2e8f0;background:#fff;color:#334155;cursor:pointer;font-weight:600">
          ${t.keep(userDays)}
        </button>
        <button id="alertCustom" style="padding:10px 16px;border-radius:8px;border:1px solid #113f7a;background:#fff;color:#113f7a;cursor:pointer;font-weight:600">
          ${t.custom}
        </button>
        <button id="alertAdjust" style="padding:10px 16px;border-radius:8px;border:none;background:#22c55e;color:#fff;cursor:pointer;font-weight:700">
          ${t.adjust(recommendedDays)}
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Garder le choix utilisateur
  document.getElementById('alertKeep').onclick = () => {
    state.targetNights = userDays;
    updateQuickStats();
    overlay.remove();
  };
  
  // Ajuster au recommand√©
  document.getElementById('alertAdjust').onclick = () => {
    state.targetNights = recommendedDays;
    updateQuickStats();
    toast(`‚úÖ ${t.adjust(recommendedDays)}`);
    overlay.remove();
  };
  
  // Personnaliser
  document.getElementById('alertCustom').onclick = () => {
    const custom = prompt(t.customPrompt, userDays);
    if(custom !== null){
      const days = parseInt(custom);
      if(days > 0){
        state.targetNights = days;
        updateQuickStats();
        toast(`‚úÖ ${days} jours`);
      }
    }
    overlay.remove();
  };
}



(async function(){
  if(window.__ORT_INIT) { console.log('‚ö†Ô∏è Double init bloqu√©'); return; }
  window.__ORT_INIT = true;
  console.log('=== Init OneRoadTrip ===');
  console.log('Leaflet:',typeof L!=='undefined'?'‚úÖ':'‚ùå');
{ const el=document.getElementById('ccLabel'); if(el) el.textContent=CC||'‚Äî'; }

  await loadPhotosJSON();
  
  if(TEMP_MODE&&RT_KEY){
const rawItins = localStorage.getItem(`ORT_TEMP_TRIP_${RT_KEY}_itins`);
const rawPlaces = localStorage.getItem(`ORT_TEMP_TRIP_${RT_KEY}_places`);
console.log('üîç [1] RT_KEY:', RT_KEY);
console.log('üîç [2] rawItins exists:', !!rawItins);
console.log('üîç [3] rawItins length:', rawItins?.length);
console.log('üîç [4] rawItins first 200 chars:', rawItins?.substring(0, 200));
console.log('üîç [5] rawPlaces exists:', !!rawPlaces);

const itinsObj=safeJSONParse(rawItins);
const placesObj=safeJSONParse(rawPlaces);

console.log('üîç [6] itinsObj parsed:', !!itinsObj);
console.log('üîç [7] itinsObj.itins[0]:', !!itinsObj?.itins?.[0]);

console.log('üîç [15] placesObj parsed:', !!placesObj);
console.log('üîç [16] itinsObj keys:', Object.keys(itinsObj || {}));
console.log('üîç [17] itinsObj.itins exists:', 'itins' in (itinsObj || {}));
console.log('üîç [18] itinsObj.itins[0]:', !!itinsObj?.itins?.[0]);
if(itinsObj){
  state._rawItinsObj=itinsObj;
  state._rawPlacesObj=placesObj;
  let toUse=null;
  if(Array.isArray(itinsObj.days_plan)||Array.isArray(itinsObj.places))toUse=itinsObj;
  else if(itinsObj.itineraries&&itinsObj.itineraries[0])toUse=itinsObj.itineraries[0];
  else if(itinsObj.itins&&itinsObj.itins[0])toUse=itinsObj.itins[0];
  
  console.log('üîç [8] toUse exists:', !!toUse);
  console.log('üîç [19] toUse selected:', !!toUse);
  if(toUse){
     console.log('üîç [20] Entering initFromItin');
        const cc=toUse.itin_id?toUse.itin_id.split('::')[0].toUpperCase():(itinsObj.country||'XX');
        state.country=cc;
{ const el=document.getElementById('ccLabel'); if(el) el.textContent=cc; }
        
await initFromItin(toUse);

// Afficher le titre (d√©j√† multilingue)
$('#rtTitle').textContent = state.title || '';

renderRows();
// Charger l‚Äôindex (pays ou import) avant d‚Äôafficher ‚ÄúAutres lieux‚Äù
await ensurePlacesIndex().catch(()=>{});

        return;
      }
    }
  }
  
  if(!CC||!ITIN_ID){
state.title='Aucun roadtrip s√©lectionn√©';
setTitleTranslated(state.title);
return;
  }
  
  const it=await loadItin();
  if(!it){
    state.title='Roadtrip introuvable';
setTitleTranslated(state.title);
alert('Itin√©raire introuvable');
return;

  }
  
state.country=CC;
   state.cc = CC; // ‚Üê AJOUT : pour collectCurrentData()
   state.tripId = ensureRid(); // ‚Üê AJOUT : pour ORT_DETAIL_ADAPTER
   
   // ‚Üê AJOUT : Stocker la r√©f√©rence √† l'itin√©raire de base
   if (CC && ITIN_ID) {
     state._itinRef = {
       country: CC,
       itin: ITIN_ID
     };
     console.log('[INIT] R√©f√©rence itin√©raire de base stock√©e:', state._itinRef);
   }
   
   // Initialiser l'adaptateur State Manager avec le tripId
   if (window.ORT_DETAIL_ADAPTER && typeof window.ORT_DETAIL_ADAPTER.init === 'function') {
     window.ORT_DETAIL_ADAPTER.init(state.tripId, state);
     console.log('[INIT] ‚úÖ ORT_DETAIL_ADAPTER initialis√© avec tripId:', state.tripId);
   }
   
   await initFromItin(it);

// Fusionne les √©ditions utilisateur (visites/activit√©s) si dispo
if (window.ORT_STEP_COMMON && typeof window.ORT_STEP_COMMON.loadStepData === 'function') {
  const tripId = (function(){
    const u = new URLSearchParams(location.search);
    const itin = u.get('itin') || '';
 const uid  = localStorage.getItem('ORT_USER_ID') || 'user';
    return `${uid}::${itin}`.replace(/\s/g,'_');
  })();
  if (Array.isArray(state.steps)) {
    for (let i = 0; i < state.steps.length; i++) {
      const d = await window.ORT_STEP_COMMON.loadStepData(tripId, `day_${i+1}`);
      if (d) {
        // ‚ö†Ô∏è Ne pas √©craser par des tableaux vides
        if (Array.isArray(d.visits)     && d.visits.length)     state.steps[i].visits     = d.visits;
        if (Array.isArray(d.activities) && d.activities.length) state.steps[i].activities = d.activities;
      }
    }
  }
}

setTitleTranslated(state.title);
renderRows();
// S√©curit√© : master pays pr√™t pour "Autres lieux"
ensurePlacesIndex().catch(()=>{});




})();

}
</script>




<div id="mapPopup" class="map-popup">
  <button class="popup-close" onclick="window.closeMapPopup()">‚úï</button>
  <div class="popup-content">
    <div class="popup-title" id="popupTitle"></div>
    <div class="popup-photos" id="popupPhotos"></div>
    <div class="popup-desc" id="popupDesc"></div>
  </div>
</div>

<script>
// === Fiche pays (d√©pend seulement de CC et de la langue) ===
(function(){
  console.log('[COUNTRY] Initialisation fiche pays');
  const btn   = document.getElementById('countryTab');
  const wrap  = document.getElementById('countryDrawer');
  const close = document.getElementById('cdClose');
  const tabs  = document.getElementById('cdTabs');
  const panes = document.getElementById('cdPanes');
  const title = document.getElementById('cdTitle');
  console.log('[COUNTRY] btn:', !!btn, 'wrap:', !!wrap, 'close:', !!close, 'tabs:', !!tabs, 'panes:', !!panes);
  if(!btn || !wrap || !tabs || !panes) {
    console.log('[COUNTRY] ‚ùå Manque un √©l√©ment, retour');
    return;
  }

  const qs  = new URLSearchParams(location.search);
  const CC  = (qs.get('cc')||'XX').toUpperCase();
  
  // Fonction pour obtenir la langue actuelle (dynamiquement)
  function getUILang() {
    return (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  }
  
  let ui  = getUILang();
  console.log('[COUNTRY] CC:', CC, 'ui:', ui);
  const I18N_DICT = {
    fr:{
      "Safety Warning":"Avertissements de s√©curit√©",
      "Best Time to Visit":"Meilleure p√©riode",
      "Iconic Places to Visit":"Lieux embl√©matiques",
      "Best Transportation":"Transports",
      "Daily Budget for Two People":"Budget (2 pers.)",
      "Essential Tips":"Conseils essentiels",
      "Unique Experiences":"Exp√©riences uniques",
      unavailable:"Guide indisponible."
    },
    en:{unavailable:"Guide unavailable."}
  };
  
  function I18N_fallback(){return {unavailable:"Guide unavailable."};}
  
  // Obtenir les labels I18N pour la langue actuelle
  function getCountryI18N() {
    const currentLang = getUILang();
    return I18N_DICT[currentLang] || I18N_fallback();
  }
  function boldOnly(s){
    const safe = String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    return safe.replace(/\*\*([\s\S]*?)\*\*/g,'<strong>$1</strong>');
  }
  function parseSections(raw){
    const order = ['Safety Warning','Best Time to Visit','Iconic Places to Visit','Best Transportation','Daily Budget for Two People','Essential Tips','Unique Experiences'];
    const map = new Map(); const t = String(raw||'').replace(/\r\n?/g,'\n');
  const re = /^##\s*(.*?)\s*\n([\s\S]*?)(?=^##\s|(?![\s\S]))/gmi;
    while((m=re.exec(t))){ map.set((m[1]||'').trim(), (m[2]||'').trim()); }
    return {order, map};
  }
  function localizedCountryName(iso2){
    const currentLang = getUILang();
    try{ const dn=new Intl.DisplayNames([currentLang],{type:'region'}); const n=dn.of(iso2); return n||iso2; }catch(_){ return iso2; }
  }

  async function loadGuide(cc, lang){
    // Chemin: ./data/country-guides/{lang}/{CC}.txt
    // Exemple: ./data/country-guides/fr/FR.txt
    const url = `./data/country-guides/${lang}/${cc.toUpperCase()}.txt`;
    try{ const r=await fetch(url,{cache:'no-store'}); return r.ok ? await r.text() : ''; }
    catch{ return ''; }
  }

  function render(raw){
    tabs.innerHTML=''; panes.innerHTML='';
    const I18N = getCountryI18N();
    if(!raw){ panes.innerHTML = `<div class="pane active">${I18N.unavailable}</div>`; return; }
    const {order, map} = parseSections(raw);
    order.forEach((k,i)=>{
      const b=document.createElement('button');
      b.className='tab'+(i===0?' active':''); b.dataset.k=k; b.textContent=I18N[k]||k;
      b.addEventListener('click', ()=>{
        tabs.querySelectorAll('.tab').forEach(x=>x.classList.toggle('active', x===b));
        panes.querySelectorAll('.pane').forEach(p=>p.classList.toggle('active', p.dataset.k===k));
      });
      tabs.appendChild(b);
      const p=document.createElement('div'); p.className='pane'+(i===0?' active':''); p.dataset.k=k;
      p.innerHTML=boldOnly(map.get(k)||'‚Äî'); panes.appendChild(p);
    });
  }

  async function openDrawer(){
    title.textContent = localizedCountryName(CC);
    wrap.classList.add('show');
    if(!wrap.dataset.loaded){
      const currentLang = getUILang();
      const raw = await loadGuide(CC, currentLang);
      render(raw);
      wrap.dataset.loaded='1';
    }
  }
  function closeDrawer(){ wrap.classList.remove('show'); }

  btn.addEventListener('click', openDrawer);
  console.log('[COUNTRY] ‚úÖ Listener attach√© √† countryTab');
  close.addEventListener('click', closeDrawer);
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDrawer(); });
  
  // Recharger le guide quand la langue change
  window.addEventListener('storage', (e) => {
    if (e.key === 'lang') {
      // Invalider le cache pour forcer le rechargement
      wrap.dataset.loaded = '';
    }
  });
  
  // Observer pour d√©tecter les changements d'attribut lang
  const countryLangObserver = new MutationObserver(() => {
    wrap.dataset.loaded = '';
  });
  countryLangObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ['lang']
  });
  
  console.log('[COUNTRY] ‚úÖ Fiche pays initialis√©e');
})();
</script>




  <div id="reorgInfoModal" role="dialog" aria-modal="true" aria-labelledby="reorgInfoTitle">
  <div class="reorg-info-box">

    <h2 id="reorgInfoTitle">‚áÑ <span data-i18n="reorg.info.title">R√©organiser l'itin√©raire</span></h2>
    <p data-i18n="reorg.info.line1">
      <strong>1er clic simple</strong> sur une √©tape : d√©marrage de l'itin√©raire
    </p>
    <p data-i18n="reorg.info.line2">
      <strong>2√®me clic simple</strong> : seconde √©tape de votre itin√©raire
    </p>
    <p data-i18n="reorg.info.line3">
      <strong>Double-clic</strong> : suppression de l'√©tape
    </p>
    <p data-i18n="reorg.info.line4">
      <strong>Nouveau double-clic</strong> : r√©int√©gration de l'√©tape
    </p>
    <p data-i18n="reorg.info.line5" style="margin-top:16px;font-style:italic;color:#64748b;">
      ‚ö†Ô∏è Validation n√©cessaire en fin de r√©organisation pour sauvegarder vos changements.
    </p>
    <button class="btn-close-info" data-i18n="reorg.info.close">J'ai compris</button>
  </div>
</div>

<!-- ========================================= -->
<!-- GROUPES V7 FINAL - PARTIE 1/2 -->
<!-- Nom d√©faut + Sticky + I18N + Coloration -->
<!-- Remplacer tout le code V6 par V7 (parties 1 et 2) -->
<!-- ========================================= -->

<!-- IMPORTANT : T√©l√©charger aussi la partie 2 ! -->

<style>
/* Couleurs des groupes */
.step-name-link {
  position: relative;
  display: inline-block;
}

.step-name-link:hover {
  color: #2563eb !important;
  text-decoration: underline !important;
}

/* Tooltip */
.step-tooltip {
  position: fixed;
  background: #1f2937;
  color: #fff;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 500;
  white-space: normal;        /* ‚Üê autorise le retour √† la ligne */
  max-width: 420px;           /* ‚Üê √©vite d‚Äô√™tre trop large */
  z-index: 10000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* Ligne de titre (nom complet) */
.step-tooltip .tt-fullname{
  font-weight: 800;
  margin-bottom: 4px;
  line-height: 1.25;
}


.step-tooltip.show {
  opacity: 1;
}

.step-tooltip::before {
  content: '';
  position: absolute;
  left: -6px;
  top: 50%;
  transform: translateY(-50%);
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 6px 6px 6px 0;
  border-color: transparent #1f2937 transparent transparent;
}
</style>




<script>
(function initGroups() {

console.log('üîç [STATE-CHECK] window.state exists:', !!window.state);
console.log('üîç [STATE-CHECK] window.state.steps:', window.state?.steps?.length);
console.log('üîç [STATE-CHECK] window.state.title:', window.state?.title);
console.log('[GROUPS V7] Attente de state...');
  
  let attempts = 0;
  const checkState = setInterval(() => {
    attempts++;
    
    const stateExists = typeof window.state !== 'undefined';
    const stepsExists = stateExists && window.state.steps;
    const stepsIsArray = stepsExists && Array.isArray(window.state.steps);
    const stepsHasLength = stepsIsArray && window.state.steps.length > 0;
    
    if (stateExists && stepsIsArray && stepsHasLength) {
      clearInterval(checkState);
      console.log('[GROUPS V7] ‚ö†Ô∏è startGroupSystem supprim√©');
      // startGroupSystem() supprim√©
 } else if (attempts % 10 === 0) {
  console.log('[GROUPS V7] Tentative', attempts, '- steps:', window.state?.steps?.length, 'title:', window.state?.title);
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(checkState);
    if (typeof window.state !== 'undefined' && window.state.steps?.length > 0) {
      console.log('[GROUPS V7] ‚ö†Ô∏è Timeout mais state OK');
      // startGroupSystem() supprim√©
    }
  }, 30000);
})();

</script>
<div id="stepTooltip" class="step-tooltip"></div>

<script src="ort-ratings.js"></script>
<script src="/js/ort-pdf-export-v6.js"></script>

<!-- === GETYOURGUIDE WIDGET === -->
<style>
#gygModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 15000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#gygModal.show { display: flex; }
.gyg-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 900px;
  width: 95%;
  max-height: 85vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.gyg-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #113f7a 0%, #1a5298 100%);
  color: #fff;
}
.gyg-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.gyg-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.gyg-modal-close:hover { background: rgba(255,255,255,0.3); }
.gyg-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 300px;
}
.gyg-step-info {
  text-align: center;
  padding: 12px;
  background: #f8fafc;
  border-radius: 10px;
  margin-bottom: 16px;
}
.gyg-step-info strong { color: #113f7a; font-size: 1.1rem; }
</style>

<div id="gygModal">
  <div class="gyg-modal-content">
    <div class="gyg-modal-header">
      <h3>üé´ Activit√©s & Exp√©riences</h3>
      <button class="gyg-modal-close" onclick="closeGygModal()">‚úï</button>
    </div>
    <div class="gyg-modal-body">
      <div class="gyg-step-info">
        <span id="gygStepName"></span>
      </div>
      <div id="gygWidgetContainer"></div>
      <div id="gygMoreLink" style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid #e2e8f0;"></div>
    </div>
  </div>
</div>

<script>
// === GETYOURGUIDE WIDGET CONTROLLER ===
function getGygLocale() {
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  return { fr:'fr-FR', en:'en-US', es:'es-ES', it:'it-IT', pt:'pt-PT', ar:'en-US' }[lang] || 'en-US';
}

function getGygDomain() {
  const lang = (localStorage.getItem('lang') || 'fr').slice(0,2);
  return { fr:'fr', en:'com', es:'es', it:'it', pt:'pt', ar:'com' }[lang] || 'com';
}

function openGygModal(step, idx) {
  const modal = document.getElementById('gygModal');
  const container = document.getElementById('gygWidgetContainer');
  const stepNameEl = document.getElementById('gygStepName');
  const moreLinkEl = document.getElementById('gygMoreLink');
  if (!modal || !container) return;
  
  const placeName = step?.name || 'cette destination';
  const locale = getGygLocale();
  const lang = locale.split('-')[0];
  const gygDomain = getGygDomain();
  
  // Textes I18N
  const i18n = {
    activitiesNear: { fr:'Activit√©s √† proximit√© de', en:'Activities near', es:'Actividades cerca de', it:'Attivit√† vicino a', pt:'Atividades perto de' },
    loading: { fr:'Chargement des activit√©s...', en:'Loading activities...', es:'Cargando actividades...', it:'Caricamento attivit√†...', pt:'Carregando atividades...' },
    seeMore: { fr:'Voir toutes les activit√©s √†', en:'See all activities in', es:'Ver todas las actividades en', it:'Vedi tutte le attivit√† a', pt:'Ver todas as atividades em' }
  };
  const t = (k) => i18n[k]?.[lang] || i18n[k]?.fr || k;
  
  // R√©cup√©rer la date de l'√©tape (format YYYY-MM-DD) pour affichage
  const stepDate = (typeof getStay22CheckinDate === 'function') ? getStay22CheckinDate(idx) : null;
  
  if (stepNameEl) {
    const dateDisplay = stepDate ? ` <span style="color:#64748b;font-size:0.9em;">(${new Date(stepDate).toLocaleDateString(locale)})</span>` : '';
    stepNameEl.innerHTML = `${t('activitiesNear')} <strong>${placeName}</strong>${dateDisplay}`;
  }
  
  // Lien "Voir plus" vers GetYourGuide
  const moreUrl = `https://www.getyourguide.${gygDomain}/s/?q=${encodeURIComponent(placeName)}&partner_id=YQ9RFXj5`;
  if (moreLinkEl) {
    moreLinkEl.innerHTML = `
      <a href="${moreUrl}" target="_blank" rel="noopener" 
         style="display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:#113f7a;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;transition:background 0.2s;"
         onmouseover="this.style.background='#0d2f5c'" onmouseout="this.style.background='#113f7a'">
        üîç ${t('seeMore')} ${placeName}
      </a>
    `;
  }
  
  // URL du widget avec 6 items
  const widgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&place=${encodeURIComponent(placeName)}&items=6&locale=${locale}&powered_by=true&campaign_id=108&promo_id=4039`;
  
  // Afficher loader puis charger le widget
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${t('loading')}</div>`;
  
  // Cr√©er et injecter le script
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  console.log('[GYG] Modal ouverte pour:', placeName, '| locale:', locale);
}

function closeGygModal() {
  const modal = document.getElementById('gygModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    const container = document.getElementById('gygWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeGygModal(); });
document.getElementById('gygModal')?.addEventListener('click', function(e) { if (e.target === this) closeGygModal(); });
console.log('[GYG] ‚úÖ GetYourGuide widget ready');
</script>

<!-- === TIQETS WIDGET (Billets & Visites) === -->
<style>
#tiqetsModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#tiqetsModal.show { display: flex; }
.tiq-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 900px;
  width: 95%;
  max-height: 85vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.tiq-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #00a0e3 0%, #0077b6 100%);
  color: #fff;
}
.tiq-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.tiq-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.tiq-modal-close:hover { background: rgba(255,255,255,0.3); }
.tiq-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 300px;
}
.tiq-step-info {
  text-align: center;
  padding: 12px;
  background: #f8fafc;
  border-radius: 10px;
  margin-bottom: 16px;
}
.tiq-step-info strong { color: #0077b6; font-size: 1.1rem; }
</style>

<div id="tiqetsModal">
  <div class="tiq-modal-content">
    <div class="tiq-modal-header">
      <h3>üéüÔ∏è Billets & Visites</h3>
      <button class="tiq-modal-close" onclick="closeTiqetsModal()">‚úï</button>
    </div>
    <div class="tiq-modal-body">
      <div class="tiq-step-info">
        <span id="tiqStepName"></span>
      </div>
      <div id="tiqWidgetContainer"></div>
      <div id="tiqMoreLink" style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid #e2e8f0;"></div>
    </div>
  </div>
</div>

<script>
// === TIQETS WIDGET CONTROLLER ===
function getTiqetsLocale() {
  return (localStorage.getItem('lang') || document.documentElement.lang || 'en').slice(0,2);
}

function getTiqetsCurrency() {
  const lang = getTiqetsLocale();
  return { fr:'EUR', en:'USD', es:'EUR', it:'EUR', pt:'EUR', ar:'USD' }[lang] || 'EUR';
}

function openTiqetsModal(step, idx) {
  const modal = document.getElementById('tiqetsModal');
  const container = document.getElementById('tiqWidgetContainer');
  const stepNameEl = document.getElementById('tiqStepName');
  const moreLinkEl = document.getElementById('tiqMoreLink');
  if (!modal || !container) return;
  
  const placeName = step?.name || 'cette destination';
  const lang = getTiqetsLocale();
  const currency = getTiqetsCurrency();
  
  const i18n = {
    ticketsNear: {fr:'Billets & visites √†',en:'Tickets & visits in',es:'Entradas y visitas en',it:'Biglietti e visite a',pt:'Bilhetes e visitas em',ar:'ÿ™ÿ∞ÿßŸÉÿ± Ÿàÿ≤Ÿäÿßÿ±ÿßÿ™ ŸÅŸä'},
    loading: {fr:'Chargement des billets...',en:'Loading tickets...',es:'Cargando entradas...',it:'Caricamento biglietti...',pt:'Carregando bilhetes...',ar:'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...'},
    seeMore: {fr:'Voir tous les billets',en:'See all tickets',es:'Ver todas las entradas',it:'Vedi tutti i biglietti',pt:'Ver todos os bilhetes',ar:'ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ™ÿ∞ÿßŸÉÿ±'},
    errorLoad: {fr:'Impossible de charger. Cliquez ci-dessous.',en:'Unable to load. Click below.',es:'No se puede cargar.',it:'Impossibile caricare.',pt:'N√£o foi poss√≠vel carregar.',ar:'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ.'}
  };
  const tiq = (k) => i18n[k]?.[lang] || i18n[k]?.en || k;
  
  // Date de l'√©tape
  let dateParam = '';
  let stepDate = null;
  if (typeof getStay22CheckinDate === 'function') {
    stepDate = getStay22CheckinDate(idx);
    if (stepDate) dateParam = `&date=${stepDate}`;
  }
  
  if (stepNameEl) {
    const dateDisplay = stepDate ? ` <span style="color:#64748b;font-size:0.9em;">(${new Date(stepDate).toLocaleDateString()})</span>` : '';
    stepNameEl.innerHTML = `${tiq('ticketsNear')} <strong>${placeName}</strong>${dateDisplay}`;
  }
  
  const moreUrl = `https://tiqets.tpo.li/L1uxd085?q=${encodeURIComponent(placeName)}${dateParam}&lang=${lang}`;
  if (moreLinkEl) {
    moreLinkEl.innerHTML = `
      <a href="${moreUrl}" target="_blank" rel="noopener" 
         style="display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:#0077b6;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
        üîç ${tiq('seeMore')}
      </a>
    `;
  }
  
  const widgetUrl = `https://trpwdg.com/content?currency=${currency}&trs=478677&shmarker=688844&language=${lang}&layout=horizontal&powered_by=true&campaign_id=89&promo_id=3948`;
  
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${tiq('loading')}</div>`;
  
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  const loadTimeout = setTimeout(() => {
    if (!container.querySelector('[class*="trp"]')) {
      container.innerHTML = `
        <div style="text-align:center;padding:30px;color:#64748b;">
          <div style="font-size:2rem;margin-bottom:10px;">üéüÔ∏è</div>
          <p>${tiq('errorLoad')}</p>
          <a href="${moreUrl}" target="_blank" rel="noopener" 
             style="display:inline-block;margin-top:12px;padding:12px 24px;background:#0077b6;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
            üîç ${tiq('seeMore')}
          </a>
        </div>
      `;
    }
  }, 5000);
  
  script.onload = () => clearTimeout(loadTimeout);
  script.onerror = () => {
    clearTimeout(loadTimeout);
    container.innerHTML = `
      <div style="text-align:center;padding:30px;color:#64748b;">
        <div style="font-size:2rem;margin-bottom:10px;">üéüÔ∏è</div>
        <p>${tiq('errorLoad')}</p>
        <a href="${moreUrl}" target="_blank" rel="noopener" 
           style="display:inline-block;margin-top:12px;padding:12px 24px;background:#0077b6;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
          üîç ${tiq('seeMore')}
        </a>
      </div>
    `;
  };
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeTiqetsModal() {
  const modal = document.getElementById('tiqetsModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    const container = document.getElementById('tiqWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeTiqetsModal(); });
document.getElementById('tiqetsModal')?.addEventListener('click', function(e) { if (e.target === this) closeTiqetsModal(); });
console.log('[TIQETS] ‚úÖ Tiqets widget ready');
</script>

<!-- === TICKETMASTER WIDGET (Spectacles) === -->
<style>
#ticketmasterModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#ticketmasterModal.show { display: flex; }
.tm-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 900px;
  width: 95%;
  max-height: 85vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.tm-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #026cdf 0%, #0653b6 100%);
  color: #fff;
}
.tm-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.tm-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.tm-modal-close:hover { background: rgba(255,255,255,0.3); }
.tm-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 300px;
}
.tm-step-info {
  text-align: center;
  padding: 12px;
  background: #f8fafc;
  border-radius: 10px;
  margin-bottom: 16px;
}
.tm-step-info strong { color: #026cdf; font-size: 1.1rem; }
</style>

<div id="ticketmasterModal">
  <div class="tm-modal-content">
    <div class="tm-modal-header">
      <h3>üé≠ Spectacles</h3>
      <button class="tm-modal-close" onclick="closeTicketmasterModal()">‚úï</button>
    </div>
    <div class="tm-modal-body">
      <div class="tm-step-info">
        <span id="tmStepName"></span>
      </div>
      <div id="tmWidgetContainer"></div>
      <div id="tmMoreLink" style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid #e2e8f0;"></div>
    </div>
  </div>
</div>

<script>
// === TICKETMASTER WIDGET CONTROLLER ===
function getTicketmasterLocale() {
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'en').slice(0,2);
  return { fr:'fr-FR', en:'en-US', es:'es-ES', it:'it-IT', pt:'pt-PT', ar:'en-US' }[lang] || 'en-US';
}

function getCountryFromCC() {
  const cc = (window.CC || window.state?.cc || window.state?.country || '').toUpperCase();
  const supported = ['US','CA','MX','AU','NZ','GB','IE','DE','FR','ES','IT','NL','BE','AT','CH','PL','SE','NO','DK','FI'];
  return supported.includes(cc) ? cc : 'FR';
}

function openTicketmasterModal(step, idx) {
  const modal = document.getElementById('ticketmasterModal');
  const container = document.getElementById('tmWidgetContainer');
  const stepNameEl = document.getElementById('tmStepName');
  const moreLinkEl = document.getElementById('tmMoreLink');
  if (!modal || !container) return;
  
  const placeName = step?.name || 'cette destination';
  const locale = getTicketmasterLocale();
  const lang = locale.split('-')[0];
  const country = getCountryFromCC();
  
  const i18n = {
    showsNear: {fr:'Spectacles √†',en:'Shows in',es:'Espect√°culos en',it:'Spettacoli a',pt:'Espet√°culos em',ar:'ÿπÿ±Ÿàÿ∂ ŸÅŸä'},
    loading: {fr:'Chargement des spectacles...',en:'Loading shows...',es:'Cargando espect√°culos...',it:'Caricamento spettacoli...',pt:'Carregando espet√°culos...',ar:'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...'},
    seeMore: {fr:'Voir tous les spectacles',en:'See all shows',es:'Ver todos los espect√°culos',it:'Vedi tutti gli spettacoli',pt:'Ver todos os espet√°culos',ar:'ÿπÿ±ÿ∂ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπÿ±Ÿàÿ∂'},
    errorLoad: {fr:'Impossible de charger. Cliquez ci-dessous.',en:'Unable to load. Click below.',es:'No se puede cargar.',it:'Impossibile caricare.',pt:'N√£o foi poss√≠vel carregar.',ar:'ÿ™ÿπÿ∞ÿ± ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ.'}
  };
  const tm = (k) => i18n[k]?.[lang] || i18n[k]?.fr || k;
  
  // Date de l'√©tape
  let startDate = '';
  if (typeof getStay22CheckinDate === 'function') {
    startDate = getStay22CheckinDate(idx) || '';
  }
  if (!startDate) {
    startDate = new Date().toISOString().split('T')[0];
  }
  
  if (stepNameEl) {
    const dateDisplay = ` <span style="color:#64748b;font-size:0.9em;">(${new Date(startDate).toLocaleDateString(locale)})</span>`;
    stepNameEl.innerHTML = `${tm('showsNear')} <strong>${placeName}</strong>${dateDisplay}`;
  }
  
  const moreUrl = `https://www.ticketmaster.com/search?q=${encodeURIComponent(placeName)}&startDate=${startDate}`;
  if (moreLinkEl) {
    moreLinkEl.innerHTML = `
      <a href="${moreUrl}" target="_blank" rel="noopener" 
         style="display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
        üîç ${tm('seeMore')}
      </a>
    `;
  }
  
  const widgetUrl = `https://trpwdg.com/content?trs=478677&start_date=${startDate}&country=${country}&sort=relevance%2Cdesc&powered_by=true&min_lines=5&promo_id=5431&shmarker=688844&campaign_id=183`;
  
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${tm('loading')}</div>`;
  
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  const loadTimeout = setTimeout(() => {
    if (!container.querySelector('[class*="trp"]')) {
      container.innerHTML = `
        <div style="text-align:center;padding:30px;color:#64748b;">
          <div style="font-size:2rem;margin-bottom:10px;">üé≠</div>
          <p>${tm('errorLoad')}</p>
          <a href="${moreUrl}" target="_blank" rel="noopener" 
             style="display:inline-block;margin-top:12px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
            üîç ${tm('seeMore')}
          </a>
        </div>
      `;
    }
  }, 5000);
  
  script.onload = () => clearTimeout(loadTimeout);
  script.onerror = () => {
    clearTimeout(loadTimeout);
    container.innerHTML = `
      <div style="text-align:center;padding:30px;color:#64748b;">
        <div style="font-size:2rem;margin-bottom:10px;">üé≠</div>
        <p>${tm('errorLoad')}</p>
        <a href="${moreUrl}" target="_blank" rel="noopener" 
           style="display:inline-block;margin-top:12px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
          üîç ${tm('seeMore')}
        </a>
      </div>
    `;
  };
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
}

function closeTicketmasterModal() {
  const modal = document.getElementById('ticketmasterModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    const container = document.getElementById('tmWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeTicketmasterModal(); });
document.getElementById('ticketmasterModal')?.addEventListener('click', function(e) { if (e.target === this) closeTicketmasterModal(); });
console.log('[TICKETMASTER] ‚úÖ Ticketmaster widget ready');
</script>

<!-- ORT Header/Footer/Auth modules -->
<script src="/js/ort-i18n-auth.js"></script>
<script src="/js/ort-header.js"></script>
<script src="/js/ort-footer.js"></script>

<!-- Fallback auth si ort-header.js pas encore d√©ploy√© -->
<script>
(function(){
  // Skip si ORT_HEADER d√©j√† initialis√©
  setTimeout(function() {
    if (window.ORT_HEADER) return;
    
    // Charger Firebase si pas d√©j√† charg√©
    function loadScript(src) {
      return new Promise(function(ok, ko) {
        if (document.querySelector('script[src="'+src+'"]')) return ok();
        var s = document.createElement('script');
        s.src = src;
        s.onload = ok;
        s.onerror = ko;
        document.head.appendChild(s);
      });
    }
    
    async function ensureFb() {
      if (window.firebase?.apps?.length) return window.firebase;
      await loadScript('https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js');
      if (!window.firebase.apps?.length && window.__FIREBASE_CONFIG__) {
        window.firebase.initializeApp(window.__FIREBASE_CONFIG__);
      }
      return window.firebase;
    }
    
    ensureFb().then(async function(fb) {
      const btn = document.getElementById('openAuth');
      const btnLogout = document.getElementById('btnLogout');
      const btnGoogle = document.getElementById('btnGoogle');
      const btnEmail = document.getElementById('btnEmail');
      if (!btn) return;
      
      fb.auth().onAuthStateChanged(async function(user) {
        // Initialiser ORT_STATE avec l'utilisateur
        if (window.ORT_STATE) {
          if (typeof window.ORT_STATE.init === 'function') {
            await window.ORT_STATE.init({ user: user, premium: false });
          }
          if (user && typeof window.ORT_STATE.updateUser === 'function') {
            await window.ORT_STATE.updateUser(user);
            console.log('[AUTH-FALLBACK] ORT_STATE.updateUser appel√©:', user.uid);
          }
        }
        
        if (user) {
          const name = user.displayName || (user.email || '').split('@')[0] || 'Mon compte';
          btn.innerHTML = '<span>üë§ ' + name.slice(0, 12) + '</span>';
          if (btnLogout) btnLogout.style.display = '';
          if (btnGoogle) btnGoogle.style.display = 'none';
          if (btnEmail) btnEmail.style.display = 'none';
        } else {
          const lang = document.documentElement.lang || 'fr';
          const labels = {fr:'Se connecter',en:'Sign in',it:'Accedi',es:'Iniciar sesi√≥n',pt:'Entrar',ar:'ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ'};
          btn.textContent = labels[lang] || labels.fr;
          if (btnLogout) btnLogout.style.display = 'none';
          if (btnGoogle) btnGoogle.style.display = '';
          if (btnEmail) btnEmail.style.display = '';
        }
      });
      
      console.log('[AUTH-FALLBACK] ‚úÖ Auth listener actif');
    }).catch(function(e) {
      console.warn('[AUTH-FALLBACK] Firebase init failed:', e);
    });
  }, 500);
})();
</script>

<!-- ===== INITIALISATION STATE MANAGER (SYNC) ===== -->
<script>
(async function initStateManager() {
  console.log('[INIT] Initialisation State Manager...');
  
  // Charger Firebase si pas d√©j√† charg√©
  if (!window.firebase?.apps?.length) {
    console.log('[INIT] üîÑ Chargement Firebase...');
    const load = (src) => new Promise((ok, ko) => {
      const s = document.createElement('script');
      s.src = src;
      s.onload = ok;
      s.onerror = () => ko(new Error('load ' + src));
      document.head.appendChild(s);
    });
    
    try {
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js");
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js");
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js");
      
      // Attendre que firebase.auth soit vraiment disponible
      let authReady = false;
      for (let i = 0; i < 50 && !authReady; i++) {
        if (typeof window.firebase?.auth === 'function') {
          authReady = true;
        } else {
          await new Promise(r => setTimeout(r, 50));
        }
      }
      
      if (!authReady) {
        throw new Error('firebase.auth not available after loading');
      }
      
      // Initialiser Firebase seulement si pas d√©j√† fait
      if (!window.firebase.apps.length) {
        window.firebase.initializeApp(window.__FIREBASE_CONFIG__);
      }
      await window.firebase.auth().setPersistence(window.firebase.auth.Auth.Persistence.LOCAL);
      console.log('[INIT] ‚úÖ Firebase charg√©');
    } catch (e) {
      console.warn('[INIT] ‚ö†Ô∏è Erreur chargement Firebase:', e);
    }
  }
  
  // Attend que Firebase Auth soit pr√™t
  console.log('[INIT] üîç Firebase disponible?', !!window.firebase);
  console.log('[INIT] üîç Firebase.auth disponible?', !!window.firebase?.auth);
  
  const user = await new Promise(resolve => {
    if (window.firebase?.auth) {
      console.log('[INIT] ‚è≥ Attente onAuthStateChanged...');
      const unsubscribe = firebase.auth().onAuthStateChanged(user => {
        console.log('[INIT] ‚úÖ Auth state:', user ? user.uid : 'null', 'email:', user?.email);
        unsubscribe();
        resolve(user);
      });
    } else {
      console.log('[INIT] ‚ùå Firebase.auth non disponible');
      resolve(null);
    }
  });

  // Initialiser ORT_STATE de fa√ßon synchrone
  if (window.ORT_STATE && typeof window.ORT_STATE.init === 'function') {
    await window.ORT_STATE.init({
      user: user,
      premium: false
    });
    
    // Mettre √† jour le user pour activer Firestore
    if (user && typeof window.ORT_STATE.updateUser === 'function') {
      console.log('[INIT] üîÑ Mise √† jour user dans State Manager...');
      await window.ORT_STATE.updateUser(user);
    }
    
    console.log('[INIT] ‚úÖ State Manager initialis√© avec user:', user?.uid || 'non connect√©');
  } else {
    console.warn('[INIT] ‚ö†Ô∏è ORT_STATE non disponible');
  }

  const urlParams = new URLSearchParams(window.location.search);
  const fromTemp = urlParams.get('from') === 'temp';
  const rtKey = urlParams.get('rtKey');
  
  // MODE IMPORT : Ne pas utiliser le State Manager
  if (fromTemp && rtKey) {
    console.log('[INIT] Mode IMPORT detecte - rtKey:', rtKey);
    const ccFromRtKey = rtKey.split('_')[0]?.toUpperCase() || 'XX';
    state._itinRef = { country: ccFromRtKey, itin: `${ccFromRtKey}::temp_${Date.now()}` };
    state.country = ccFromRtKey;
    state.cc = ccFromRtKey;
    
    const waitForImport = setInterval(() => {
      if (window.state && window.state.steps && window.state.steps.length > 0) {
        clearInterval(waitForImport);
        const tempTripId = `temp_${Date.now()}`;
        if (window.ORT_DETAIL_ADAPTER) window.ORT_DETAIL_ADAPTER.init(tempTripId, window.state);
        localStorage.setItem('ORT_CURRENT_TRIP_ID', tempTripId);
        localStorage.setItem(`ORT_TEMP_STATE_${tempTripId}`, JSON.stringify(window.state));
        console.log('[INIT] Import initialis√© avec tripId temp:', tempTripId);
      }
    }, 100);
    setTimeout(() => clearInterval(waitForImport), 5000);
    return;
  }

  // MODE DASHBOARD : tripId dans l'URL SANS cc/itin
  const tripIdFromUrl = urlParams.get('tripId');
  const ccParam = urlParams.get('cc');
  const itinParam = urlParams.get('itin');

  if (tripIdFromUrl && !ccParam && !itinParam) {
    console.log('[INIT] üìå Mode DASHBOARD d√©tect√© - tripId:', tripIdFromUrl);
    
    const waitForDeps = setInterval(async () => {
      if (window.ORT_STATE && typeof window.ORT_STATE.getTrip === 'function' && typeof window.renderRows === 'function') {
        clearInterval(waitForDeps);
        console.log('[INIT] ‚úÖ D√©pendances pr√™tes');
        
        try {
          let savedTrip = null;
          
          if (tripIdFromUrl.startsWith('temp_')) {
            const savedStateStr = localStorage.getItem(`ORT_TEMP_STATE_${tripIdFromUrl}`);
            if (savedStateStr) savedTrip = JSON.parse(savedStateStr);
          }
          
          if (!savedTrip) {
            savedTrip = await window.ORT_STATE.getTrip(tripIdFromUrl);
          }
          
          if (savedTrip && savedTrip.steps && savedTrip.steps.length > 0) {
            console.log('[INIT] ‚úÖ Voyage trouv√©:', savedTrip.title || tripIdFromUrl);
            
            window.state = window.state || {};
            window.state.steps = savedTrip.steps;
            window.state.title = savedTrip.title || 'Roadtrip';
            window.state.cc = savedTrip.country || 'XX';
            window.state.country = savedTrip.country || 'XX';
            window.state.tripId = tripIdFromUrl;
            
            if (savedTrip.nights) {
              window.state.targetNights = savedTrip.nights;
              window.state.initialNights = savedTrip.initialNights || savedTrip.nights;
            }
            
            Object.assign(state, window.state);
            
            if (window.ORT_DETAIL_ADAPTER) window.ORT_DETAIL_ADAPTER.init(tripIdFromUrl, window.state);
            localStorage.setItem('ORT_CURRENT_TRIP_ID', tripIdFromUrl);
            
            window.renderRows();
            if (typeof setTitleTranslated === 'function') setTitleTranslated(window.state.title);
            
            console.log('[INIT] ‚úÖ Mode DASHBOARD - Affichage termin√©');
          }
        } catch (e) {
          console.error('[INIT] ‚ùå Erreur chargement:', e);
        }
      }
    }, 100);
    
    setTimeout(() => clearInterval(waitForDeps), 10000);
    return;
  }

  // MODE NORMAL : Attendre que window.state soit pr√™t
  const waitForState = setInterval(async () => {
    if (window.state && window.state.steps) {
      clearInterval(waitForState);
      console.log('[INIT] window.state pr√™t');
      
      let tripId = urlParams.get('tripId');
      
      if (!tripId) {
        const cc = urlParams.get('cc');
        const itin = urlParams.get('itin');
        
        if (cc && itin) {
          tripId = `user::${cc}::${itin}`.replace(/[^a-zA-Z0-9:_-]/g, '_');
          console.log('[INIT] ‚úÖ TripId stable g√©n√©r√©:', tripId);
        } else if (window.ORT_STATE && typeof window.ORT_STATE.generateTripId === 'function') {
          tripId = window.ORT_STATE.generateTripId();
          console.log('[INIT] ‚ö†Ô∏è TripId temporaire g√©n√©r√©:', tripId);
        } else {
          tripId = `trip_${Date.now()}`;
        }
      }
      
      // Chercher modifications sauvegard√©es
      if (tripId && window.ORT_STATE && typeof window.ORT_STATE.getTrip === 'function') {
        try {
          const savedTrip = await window.ORT_STATE.getTrip(tripId);
          
          if (savedTrip && savedTrip.steps && savedTrip.steps.length > 0) {
            console.log('[INIT] ‚úÖ Modifications trouv√©es, application...');
            
            window.state.steps = savedTrip.steps;
            if (savedTrip.title) window.state.title = savedTrip.title;
            if (savedTrip.country) window.state.cc = savedTrip.country;
            if (savedTrip.nights) {
              window.state.targetNights = savedTrip.nights;
              window.state.initialNights = savedTrip.initialNights || savedTrip.nights;
            }
            
            if (typeof window.renderRows === 'function') window.renderRows();
            if (typeof window.renderMap === 'function') window.renderMap();
            if (typeof setTitleTranslated === 'function') setTitleTranslated(window.state.title);
            
            console.log('[INIT] ‚úÖ Modifications appliqu√©es');
          }
        } catch (error) {
          console.error('[INIT] ‚ùå Erreur chargement modifications:', error);
        }
      }
      
      // Initialiser l'adaptateur
      if (window.ORT_DETAIL_ADAPTER) {
        window.ORT_DETAIL_ADAPTER.init(tripId, window.state);
      }
      
      localStorage.setItem('ORT_CURRENT_TRIP_ID', tripId);
      console.log('[INIT] ‚úÖ State Manager initialis√© pour trip:', tripId);
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(waitForState);
    console.warn('[INIT] ‚ö†Ô∏è Timeout atteint');
  }, 5000);
})();
</script>

<!-- === PARTNER REDIRECT MODAL === -->
<style>
#partnerModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10001;
  background: rgba(17,63,122,0.9);
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: partnerFadeIn 0.3s ease;
}
#partnerModal.show { display: flex; }
#partnerModal.top-aligned { align-items: flex-start; padding-top: 40px; }
@keyframes partnerFadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes partnerSlideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
.partner-modal-content {
  background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
  border-radius: 20px;
  max-width: 750px;
  width: 95%;
  max-height: 90vh;
  overflow: hidden;
  box-shadow: 0 25px 80px rgba(0,0,0,0.4);
  animation: partnerSlideUp 0.4s ease;
}
.partner-modal-content.with-widget {
  max-width: 900px;
}
.partner-modal-header {
  padding: 24px 24px 16px;
  text-align: center;
  background: linear-gradient(135deg, #113f7a 0%, #1a5298 100%);
  color: #fff;
  position: relative;
}
.partner-modal-header.compact {
  padding: 12px 24px;
}
.partner-modal-header.compact .partner-icon,
.partner-modal-header.compact h3 {
  display: none;
}
.partner-modal-header h3 {
  margin: 0;
  font-size: 1.4rem;
  font-weight: 700;
}
.partner-modal-header .partner-icon {
  font-size: 3rem;
  margin-bottom: 8px;
  display: block;
}
.partner-modal-body {
  padding: 24px;
  text-align: center;
  color: #334155;
  font-size: 1rem;
  line-height: 1.6;
  overflow-y: auto;
  max-height: 60vh;
}
.partner-modal-body.widget-mode {
  padding: 16px;
  min-height: 350px;
}
.partner-modal-body strong {
  color: #113f7a;
}
.partner-modal-features {
  text-align: left;
  margin-top: 16px;
  padding: 16px;
  background: #f0f7ff;
  border-radius: 12px;
  font-size: 0.95rem;
}
.partner-modal-footer {
  padding: 16px 24px 24px;
  display: flex;
  gap: 12px;
  justify-content: center;
}
.partner-btn {
  padding: 14px 28px;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: none;
}
.partner-btn-primary {
  background: linear-gradient(135deg, #0f9d58 0%, #0b7a45 100%);
  color: #fff;
  box-shadow: 0 4px 15px rgba(15,157,88,0.4);
}
.partner-btn-primary:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(15,157,88,0.5);
}
.partner-btn-secondary {
  background: #e2e8f0;
  color: #64748b;
}
.partner-btn-secondary:hover {
  background: #cbd5e1;
}
.partner-countdown {
  margin-top: 12px;
  font-size: 0.85rem;
  color: #94a3b8;
  text-align: center;
}
.partner-choice-container {
  display: flex;
  gap: 16px;
  margin-top: 16px;
}
.partner-choice-btn {
  flex: 1;
  padding: 20px 16px;
  border-radius: 14px;
  border: 2px solid #e2e8f0;
  background: #fff;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}
.partner-choice-btn:hover {
  border-color: #113f7a;
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(17,63,122,0.15);
}
.partner-choice-btn .choice-icon {
  font-size: 2.5rem;
  display: block;
  margin-bottom: 10px;
}
.partner-choice-btn .choice-title {
  font-weight: 700;
  color: #113f7a;
  font-size: 1rem;
  margin-bottom: 6px;
}
.partner-choice-btn .choice-desc {
  font-size: 0.8rem;
  color: #64748b;
  line-height: 1.4;
}
.partner-choice-btn.car { border-color: #0f9d58; background: linear-gradient(135deg, #f0fdf4 0%, #fff 100%); }
.partner-choice-btn.car:hover { border-color: #0f9d58; box-shadow: 0 8px 20px rgba(15,157,88,0.2); }
.partner-choice-btn.transfer { border-color: #3b82f6; background: linear-gradient(135deg, #eff6ff 0%, #fff 100%); }
.partner-choice-btn.transfer:hover { border-color: #3b82f6; box-shadow: 0 8px 20px rgba(59,130,246,0.2); }
</style>

<div id="partnerModal">
  <div class="partner-modal-content" id="partnerModalContent">
    <div class="partner-modal-header">
      <span class="partner-icon" id="partnerIcon">üöó</span>
      <h3 id="partnerTitle">Redirection</h3>
      <button style="position:absolute;top:16px;right:16px;background:rgba(255,255,255,0.2);border:none;color:#fff;width:32px;height:32px;border-radius:8px;cursor:pointer;font-size:18px;" onclick="closePartnerModal()">‚úï</button>
    </div>
    <div class="partner-modal-body" id="partnerModalBody">
      <div id="partnerText"></div>
      <div id="partnerChoices" class="partner-choice-container" style="display:none;"></div>
      <div id="partnerWidgetContainer" style="display:none;"></div>
    </div>
    <div class="partner-modal-footer" id="partnerFooter">
      <button class="partner-btn partner-btn-secondary" onclick="closePartnerModal()" id="partnerCancelBtn">Annuler</button>
      <button class="partner-btn partner-btn-primary" onclick="confirmPartnerRedirect()" id="partnerContinueBtn">Continuer</button>
    </div>
    <div class="partner-countdown" id="partnerCountdown"></div>
  </div>
</div>

<script>
// === PARTNER MODAL CONTROLLER ===
let partnerTarget = null;
let partnerCountdownTimer = null;

function getPartnerLang() {
  return (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
}

// I18N inline pour la modal partenaire
const PARTNER_I18N = {
  vehicleTitle: {
    fr: 'üöï V√©hicules & Transferts',
    en: 'üöï Vehicles & Transfers',
    es: 'üöï Veh√≠culos y Traslados',
    it: 'üöï Veicoli e Trasferimenti',
    pt: 'üöï Ve√≠culos e Transfers',
    ar: 'üöï ÿßŸÑŸÖÿ±ŸÉÿ®ÿßÿ™ ŸàÿßŸÑŸÜŸÇŸÑ'
  },
  vehicleText: {
    fr: 'Que recherchez-vous pour votre voyage ?',
    en: 'What are you looking for?',
    es: '¬øQu√© necesitas para tu viaje?',
    it: 'Di cosa hai bisogno per il tuo viaggio?',
    pt: 'O que voc√™ precisa para sua viagem?',
    ar: 'ŸÖÿßÿ∞ÿß ÿ™ÿ≠ÿ™ÿßÿ¨ ŸÑÿ±ÿ≠ŸÑÿ™ŸÉÿü'
  },
  carTitle: { fr: 'Location de voiture', en: 'Car Rental', es: 'Alquiler de coches', it: 'Noleggio auto', pt: 'Aluguel de carros', ar: 'ÿ™ÿ£ÿ¨Ÿäÿ± ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™' },
  carDesc: { fr: 'Louez un v√©hicule et explorez en libert√©', en: 'Rent a car and explore freely', es: 'Alquila un coche y explora libremente', it: 'Noleggia un\'auto ed esplora liberamente', pt: 'Alugue um carro e explore livremente', ar: 'ÿßÿ≥ÿ™ÿ£ÿ¨ÿ± ÿ≥Ÿäÿßÿ±ÿ© Ÿàÿßÿ≥ÿ™ŸÉÿ¥ŸÅ ÿ®ÿ≠ÿ±Ÿäÿ©' },
  transferTitle: { fr: 'Transfert a√©roport', en: 'Airport Transfer', es: 'Traslado aeropuerto', it: 'Trasferimento aeroporto', pt: 'Transfer aeroporto', ar: 'ÿßŸÑŸÜŸÇŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿßÿ±' },
  transferDesc: { fr: 'Chauffeur priv√©, prix fixe garanti', en: 'Private driver, fixed price', es: 'Conductor privado, precio fijo', it: 'Autista privato, prezzo fisso', pt: 'Motorista particular, pre√ßo fixo', ar: 'ÿ≥ÿßÿ¶ŸÇ ÿÆÿßÿµÿå ÿ≥ÿπÿ± ÿ´ÿßÿ®ÿ™' },
  carRedirectTitle: { fr: 'üöó Location de voiture', en: 'üöó Car Rental', es: 'üöó Alquiler de coches', it: 'üöó Noleggio auto', pt: 'üöó Aluguel de carros', ar: 'üöó ÿ™ÿ£ÿ¨Ÿäÿ± ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™' },
  carRedirectText: {
    fr: 'Nous travaillons avec <strong>QEEQ.com</strong>, leader mondial de la location de v√©hicules.<br><br>üèÜ <strong>Meilleurs prix garantis</strong> ‚Äî Comparaison de +500 loueurs<br>üîÑ <strong>Annulation gratuite</strong> ‚Äî Flexibilit√© totale<br>üöó <strong>+7 millions de v√©hicules</strong> ‚Äî Du compact au SUV<br>üåç <strong>Pr√©sent dans 170+ pays</strong>',
    en: 'We partner with <strong>QEEQ.com</strong>, the world leader in car rental.<br><br>üèÜ <strong>Best prices guaranteed</strong> ‚Äî Comparing 500+ suppliers<br>üîÑ <strong>Free cancellation</strong> ‚Äî Total flexibility<br>üöó <strong>+7 million vehicles</strong> ‚Äî From compact to SUV<br>üåç <strong>Available in 170+ countries</strong>',
    es: 'Trabajamos con <strong>QEEQ.com</strong>, l√≠der mundial en alquiler de veh√≠culos.<br><br>üèÜ <strong>Mejores precios garantizados</strong> ‚Äî Comparaci√≥n de +500 proveedores<br>üîÑ <strong>Cancelaci√≥n gratuita</strong> ‚Äî Flexibilidad total<br>üöó <strong>+7 millones de veh√≠culos</strong> ‚Äî Del compacto al SUV<br>üåç <strong>Presente en 170+ pa√≠ses</strong>',
    it: 'Collaboriamo con <strong>QEEQ.com</strong>, leader mondiale nel noleggio veicoli.<br><br>üèÜ <strong>Miglior prezzo garantito</strong> ‚Äî Confronto di +500 fornitori<br>üîÑ <strong>Cancellazione gratuita</strong> ‚Äî Flessibilit√† totale<br>üöó <strong>+7 milioni di veicoli</strong> ‚Äî Dalla compatta al SUV<br>üåç <strong>Presente in 170+ paesi</strong>',
    pt: 'Trabalhamos com <strong>QEEQ.com</strong>, l√≠der mundial em aluguel de ve√≠culos.<br><br>üèÜ <strong>Melhores pre√ßos garantidos</strong> ‚Äî Compara√ß√£o de +500 fornecedores<br>üîÑ <strong>Cancelamento gratuito</strong> ‚Äî Flexibilidade total<br>üöó <strong>+7 milh√µes de ve√≠culos</strong> ‚Äî Do compacto ao SUV<br>üåç <strong>Presente em 170+ pa√≠ses</strong>',
    ar: 'ŸÜÿ™ÿπÿßŸàŸÜ ŸÖÿπ <strong>QEEQ.com</strong>ÿå ÿßŸÑÿ±ÿßÿ¶ÿØ ÿßŸÑÿπÿßŸÑŸÖŸä ŸÅŸä ÿ™ÿ£ÿ¨Ÿäÿ± ÿßŸÑÿ≥Ÿäÿßÿ±ÿßÿ™.<br><br>üèÜ <strong>ÿ£ŸÅÿ∂ŸÑ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ŸÖÿ∂ŸÖŸàŸÜÿ©</strong> ‚Äî ŸÖŸÇÿßÿ±ŸÜÿ© +500 ŸÖŸàÿ±ÿØ<br>üîÑ <strong>ÿ•ŸÑÿ∫ÿßÿ° ŸÖÿ¨ÿßŸÜŸä</strong> ‚Äî ŸÖÿ±ŸàŸÜÿ© ŸÉÿßŸÖŸÑÿ©<br>üöó <strong>+7 ŸÖŸÑŸäŸàŸÜ ŸÖÿ±ŸÉÿ®ÿ©</strong> ‚Äî ŸÖŸÜ ÿßŸÑŸÖÿØŸÖÿ¨ÿ© ÿ•ŸÑŸâ SUV<br>üåç <strong>ŸÖÿ™ŸàŸÅÿ± ŸÅŸä 170+ ÿØŸàŸÑÿ©</strong>'
  },
  transferRedirectTitle: { fr: 'üöê Transfert a√©roport', en: 'üöê Airport Transfer', es: 'üöê Traslado aeropuerto', it: 'üöê Trasferimento aeroporto', pt: 'üöê Transfer aeroporto', ar: 'üöê ÿßŸÑŸÜŸÇŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ∑ÿßÿ±' },
  transferRedirectText: {
    fr: 'Nous travaillons avec <strong>GetTransfer</strong>, sp√©cialiste des transferts priv√©s.<br><br>üöò <strong>Chauffeur professionnel</strong> ‚Äî Accueil personnalis√© √† l\'arriv√©e<br>üí∞ <strong>Prix fixe garanti</strong> ‚Äî Pas de surprise, pas de compteur<br>‚è∞ <strong>Disponible 24h/24</strong> ‚Äî M√™me pour les vols tardifs<br>üì± <strong>Suivi en temps r√©el</strong> ‚Äî Localisation du chauffeur',
    en: 'We partner with <strong>GetTransfer</strong>, the private transfer specialist.<br><br>üöò <strong>Professional driver</strong> ‚Äî Personalized welcome on arrival<br>üí∞ <strong>Fixed price guaranteed</strong> ‚Äî No surprises, no meter<br>‚è∞ <strong>Available 24/7</strong> ‚Äî Even for late flights<br>üì± <strong>Real-time tracking</strong> ‚Äî Driver location',
    es: 'Trabajamos con <strong>GetTransfer</strong>, especialista en traslados privados.<br><br>üöò <strong>Conductor profesional</strong> ‚Äî Bienvenida personalizada a la llegada<br>üí∞ <strong>Precio fijo garantizado</strong> ‚Äî Sin sorpresas, sin tax√≠metro<br>‚è∞ <strong>Disponible 24/7</strong> ‚Äî Incluso para vuelos tard√≠os<br>üì± <strong>Seguimiento en tiempo real</strong> ‚Äî Ubicaci√≥n del conductor',
    it: 'Collaboriamo con <strong>GetTransfer</strong>, specialista nei trasferimenti privati.<br><br>üöò <strong>Autista professionale</strong> ‚Äî Accoglienza personalizzata all\'arrivo<br>üí∞ <strong>Prezzo fisso garantito</strong> ‚Äî Nessuna sorpresa, nessun tassametro<br>‚è∞ <strong>Disponibile 24/7</strong> ‚Äî Anche per voli in ritardo<br>üì± <strong>Tracciamento in tempo reale</strong> ‚Äî Posizione dell\'autista',
    pt: 'Trabalhamos com <strong>GetTransfer</strong>, especialista em transfers privados.<br><br>üöò <strong>Motorista profissional</strong> ‚Äî Recep√ß√£o personalizada na chegada<br>üí∞ <strong>Pre√ßo fixo garantido</strong> ‚Äî Sem surpresas, sem tax√≠metro<br>‚è∞ <strong>Dispon√≠vel 24h</strong> ‚Äî Mesmo para voos atrasados<br>üì± <strong>Rastreamento em tempo real</strong> ‚Äî Localiza√ß√£o do motorista',
    ar: 'ŸÜÿ™ÿπÿßŸàŸÜ ŸÖÿπ <strong>GetTransfer</strong>ÿå ÿßŸÑŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿßŸÑŸÜŸÇŸÑ ÿßŸÑÿÆÿßÿµ.<br><br>üöò <strong>ÿ≥ÿßÿ¶ŸÇ ŸÖÿ≠ÿ™ÿ±ŸÅ</strong> ‚Äî ÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿ¥ÿÆÿµŸä ÿπŸÜÿØ ÿßŸÑŸàÿµŸàŸÑ<br>üí∞ <strong>ÿ≥ÿπÿ± ÿ´ÿßÿ®ÿ™ ŸÖÿ∂ŸÖŸàŸÜ</strong> ‚Äî ÿ®ÿØŸàŸÜ ŸÖŸÅÿßÿ¨ÿ¢ÿ™ÿå ÿ®ÿØŸàŸÜ ÿπÿØÿßÿØ<br>‚è∞ <strong>ŸÖÿ™ÿßÿ≠ 24/7</strong> ‚Äî ÿ≠ÿ™Ÿâ ŸÑŸÑÿ±ÿ≠ŸÑÿßÿ™ ÿßŸÑŸÖÿ™ÿ£ÿÆÿ±ÿ©<br>üì± <strong>ÿ™ÿ™ÿ®ÿπ ŸÅŸä ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ≠ŸÇŸäŸÇŸä</strong> ‚Äî ŸÖŸàŸÇÿπ ÿßŸÑÿ≥ÿßÿ¶ŸÇ'
  },
  insuranceTitle: { fr: 'üõ° Assurance voyage', en: 'üõ° Travel Insurance', es: 'üõ° Seguro de viaje', it: 'üõ° Assicurazione viaggio', pt: 'üõ° Seguro viagem', ar: 'üõ° ÿ™ÿ£ŸÖŸäŸÜ ÿßŸÑÿ≥ŸÅÿ±' },
  insuranceText: {
    fr: 'Nous vous dirigeons vers <strong>Ekta Traveling</strong>.<br><br>‚úÖ Couverture m√©dicale mondiale<br>‚úÖ Annulation & bagages<br>‚úÖ Assistance 24h/24',
    en: 'Redirecting to <strong>Ekta Traveling</strong>.<br><br>‚úÖ Worldwide medical coverage<br>‚úÖ Cancellation & baggage<br>‚úÖ 24/7 assistance',
    es: 'Te redirigimos a <strong>Ekta Traveling</strong>.<br><br>‚úÖ Cobertura m√©dica mundial<br>‚úÖ Cancelaci√≥n y equipaje<br>‚úÖ Asistencia 24/7',
    it: 'Ti reindirizziamo a <strong>Ekta Traveling</strong>.<br><br>‚úÖ Copertura medica mondiale<br>‚úÖ Cancellazione e bagagli<br>‚úÖ Assistenza 24/7',
    pt: 'Redirecionando para <strong>Ekta Traveling</strong>.<br><br>‚úÖ Cobertura m√©dica mundial<br>‚úÖ Cancelamento e bagagem<br>‚úÖ Assist√™ncia 24h',
    ar: 'ŸÜŸàÿ¨ŸáŸÉ ÿ•ŸÑŸâ <strong>Ekta Traveling</strong>.<br><br>‚úÖ ÿ™ÿ∫ÿ∑Ÿäÿ© ÿ∑ÿ®Ÿäÿ© ÿπÿßŸÑŸÖŸäÿ©<br>‚úÖ ÿßŸÑÿ•ŸÑÿ∫ÿßÿ° ŸàÿßŸÑÿ£ŸÖÿ™ÿπÿ©<br>‚úÖ ŸÖÿ≥ÿßÿπÿØÿ© 24/7'
  },
  cancel: { fr: 'Annuler', en: 'Cancel', es: 'Cancelar', it: 'Annulla', pt: 'Cancelar', ar: 'ÿ•ŸÑÿ∫ÿßÿ°' },
  continue: { fr: 'Continuer', en: 'Continue', es: 'Continuar', it: 'Continua', pt: 'Continuar', ar: 'ŸÖÿ™ÿßÿ®ÿπÿ©' },
  redirecting: { fr: 'Redirection dans', en: 'Redirecting in', es: 'Redirigiendo en', it: 'Reindirizzamento tra', pt: 'Redirecionando em', ar: 'ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™Ÿàÿ¨ŸäŸá ŸÅŸä' },
  loading: { fr: 'Chargement...', en: 'Loading...', es: 'Cargando...', it: 'Caricamento...', pt: 'Carregando...', ar: 'ÿ¨ÿßÿ± ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...' },
  flightTabSearch: { fr: 'üîç Rechercher un vol', en: 'üîç Search flights', es: 'üîç Buscar vuelos', it: 'üîç Cerca voli', pt: 'üîç Pesquisar voos', ar: 'üîç ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ±ÿ≠ŸÑÿßÿ™' },
  flightTabCompensation: { fr: 'üí∞ Compensation retard', en: 'üí∞ Delay compensation', es: 'üí∞ Compensaci√≥n retraso', it: 'üí∞ Rimborso ritardo', pt: 'üí∞ Compensa√ß√£o atraso', ar: 'üí∞ ÿ™ÿπŸàŸäÿ∂ ÿßŸÑÿ™ÿ£ÿÆŸäÿ±' }
};

function pt(key) {
  const lang = getPartnerLang();
  return PARTNER_I18N[key]?.[lang] || PARTNER_I18N[key]?.fr || key;
}

function showPartnerModal(type) {
  const modal = document.getElementById('partnerModal');
  const modalContent = document.getElementById('partnerModalContent');
  const modalBody = document.getElementById('partnerModalBody');
  const icon = document.getElementById('partnerIcon');
  const title = document.getElementById('partnerTitle');
  const text = document.getElementById('partnerText');
  const choices = document.getElementById('partnerChoices');
  const widgetContainer = document.getElementById('partnerWidgetContainer');
  const footer = document.getElementById('partnerFooter');
  const cancelBtn = document.getElementById('partnerCancelBtn');
  const continueBtn = document.getElementById('partnerContinueBtn');
  const countdown = document.getElementById('partnerCountdown');
  const lang = getPartnerLang();
  
  // Reset
  partnerTarget = null;
  if (partnerCountdownTimer) clearInterval(partnerCountdownTimer);
  text.style.display = '';
  choices.style.display = 'none';
  choices.innerHTML = '';
  widgetContainer.style.display = 'none';
  widgetContainer.innerHTML = '';
  footer.style.display = '';
  countdown.textContent = '';
  modalContent.classList.remove('with-widget');
  modalBody.classList.remove('widget-mode');
  modal.classList.remove('top-aligned');
  const header = document.querySelector('.partner-modal-header');
  if (header) header.classList.remove('compact');
  
  if (type === 'vehicle') {
    // Choix entre location et transfert
    icon.textContent = 'üöï';
    title.textContent = pt('vehicleTitle');
    text.innerHTML = `<p>${pt('vehicleText')}</p>`;
    choices.innerHTML = `
      <div class="partner-choice-btn car" onclick="selectPartnerChoice('car')">
        <span class="choice-icon">üöó</span>
        <div class="choice-title">${pt('carTitle')}</div>
        <div class="choice-desc">${pt('carDesc')}</div>
      </div>
      <div class="partner-choice-btn transfer" onclick="selectPartnerChoice('transfer')">
        <span class="choice-icon">üöê</span>
        <div class="choice-title">${pt('transferTitle')}</div>
        <div class="choice-desc">${pt('transferDesc')}</div>
      </div>
    `;
    choices.style.display = 'flex';
    footer.style.display = 'none';
    
  } else if (type === 'car') {
    // Location voiture - lien QEEQ
    partnerTarget = 'https://qeeq.tpo.li/rMRoXmko';
    icon.textContent = 'üöó';
    title.textContent = pt('carRedirectTitle');
    text.innerHTML = pt('carRedirectText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
    
  } else if (type === 'transfer') {
    // Transfert a√©roport - lien GetTransfer
    partnerTarget = 'https://gettransfer.tpo.li/NQ4bVvpZ';
    icon.textContent = 'üöê';
    title.textContent = pt('transferRedirectTitle');
    text.innerHTML = pt('transferRedirectText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
    
  } else if (type === 'flight') {
    // Vols avec deux onglets : Recherche + Compensation
    partnerTarget = null;
    text.style.display = 'none';
    footer.style.display = 'none';
    
    const header = document.querySelector('.partner-modal-header');
    if (header) header.classList.add('compact');
    modal.classList.add('top-aligned');
    
    modalContent.classList.add('with-widget');
    modalBody.classList.add('widget-mode');
    widgetContainer.style.display = 'block';
    
    const locale = { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
    const currency = { fr:'EUR', en:'USD', es:'EUR', it:'EUR', pt:'EUR', ar:'USD' }[lang] || 'EUR';
    
    // Widgets Travelpayouts
    const searchWidgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&locale=${locale}&curr=${currency}&powered_by=true&border_radius=0&plain=true&color_button=%232681ff&color_button_text=%23ffffff&color_border=%232681ff&promo_id=4132&campaign_id=121`;
    const compensationWidgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&locale=${locale}&width=100&powered_by=true&campaign_id=86&promo_id=2110`;
    
    widgetContainer.innerHTML = `
      <style>
        .flight-tabs { display:flex; gap:0; margin-bottom:16px; }
        .flight-tab { flex:1; padding:12px 16px; border:2px solid #2681ff; background:#fff; color:#2681ff; font-weight:600; font-size:0.9rem; cursor:pointer; transition:all 0.2s; }
        .flight-tab:first-child { border-radius:8px 0 0 8px; border-right:none; }
        .flight-tab:last-child { border-radius:0 8px 8px 0; }
        .flight-tab:hover { background:#eff6ff; }
        .flight-tab.active { background:#2681ff; color:#fff; }
        .flight-tab-content { min-height:200px; }
      </style>
      <div class="flight-tabs">
        <button class="flight-tab active" data-tab="search">${pt('flightTabSearch')}</button>
        <button class="flight-tab" data-tab="compensation">${pt('flightTabCompensation')}</button>
      </div>
      <div class="flight-tab-content" id="flightTabSearch"></div>
      <div class="flight-tab-content" id="flightTabCompensation" style="display:none;"></div>
    `;
    
    function loadWidgetInContainer(containerId, widgetUrl) {
      const container = document.getElementById(containerId);
      if (!container || container.dataset.loaded) return;
      container.innerHTML = `<div style="text-align:center;padding:30px;color:#64748b;">${pt('loading')}</div>`;
      const script = document.createElement('script');
      script.src = widgetUrl;
      script.async = true;
      script.charset = 'utf-8';
      script.onload = () => {
        container.dataset.loaded = '1';
        setTimeout(() => {
          const loader = container.querySelector('div[style*="text-align:center"]');
          if (loader && container.children.length > 1) loader.remove();
        }, 500);
      };
      script.onerror = () => {
        container.innerHTML = `<div style="text-align:center;padding:40px;color:#ef4444;">Erreur de chargement</div>`;
      };
      container.appendChild(script);
    }
    
    loadWidgetInContainer('flightTabSearch', searchWidgetUrl);
    
    widgetContainer.querySelectorAll('.flight-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        widgetContainer.querySelectorAll('.flight-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const isSearch = tab.dataset.tab === 'search';
        document.getElementById('flightTabSearch').style.display = isSearch ? 'block' : 'none';
        document.getElementById('flightTabCompensation').style.display = isSearch ? 'none' : 'block';
        
        if (!isSearch) {
          loadWidgetInContainer('flightTabCompensation', compensationWidgetUrl);
        }
      });
    });
    
  } else if (type === 'insurance') {
    const insLang = { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
    partnerTarget = `https://ektatraveling.com/${insLang}/?sub_id=8d611d0d167741c58fdfe9e61-688844&utm_source=travelpayouts`;
    icon.textContent = 'üõ°';
    title.textContent = pt('insuranceTitle');
    text.innerHTML = pt('insuranceText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
  }
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  console.log('[PARTNER] Modal ouverte pour:', type);
}

function selectPartnerChoice(choice) {
  closePartnerModal();
  setTimeout(() => showPartnerModal(choice), 100);
}

function startCountdown(countdownEl) {
  let seconds = 5;
  countdownEl.textContent = `${pt('redirecting')} ${seconds}s`;
  
  partnerCountdownTimer = setInterval(() => {
    seconds--;
    if (seconds <= 0) {
      clearInterval(partnerCountdownTimer);
      confirmPartnerRedirect();
    } else {
      countdownEl.textContent = `${pt('redirecting')} ${seconds}s`;
    }
  }, 1000);
}

function closePartnerModal() {
  const modal = document.getElementById('partnerModal');
  const widgetContainer = document.getElementById('partnerWidgetContainer');
  const header = document.querySelector('.partner-modal-header');
  if (modal) {
    modal.classList.remove('show', 'top-aligned');
    document.body.style.overflow = '';
  }
  if (header) header.classList.remove('compact');
  if (widgetContainer) widgetContainer.innerHTML = '';
  if (partnerCountdownTimer) {
    clearInterval(partnerCountdownTimer);
    partnerCountdownTimer = null;
  }
  partnerTarget = null;
}

function confirmPartnerRedirect() {
  if (partnerCountdownTimer) {
    clearInterval(partnerCountdownTimer);
    partnerCountdownTimer = null;
  }
  if (partnerTarget) {
    window.open(partnerTarget, '_blank', 'noopener');
  }
  closePartnerModal();
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closePartnerModal(); });
document.getElementById('partnerModal')?.addEventListener('click', function(e) { if (e.target === this) closePartnerModal(); });
console.log('[PARTNER] ‚úÖ Partner modal ready');

// === Prevent popup from closing when cursor moves from marker to popup ===
// Annuler le timer de fermeture si la souris entre sur la modale
const mapPopup = document.getElementById('mapPopup');
if (mapPopup) {
  mapPopup.addEventListener('mouseenter', () => {
    if (popupCloseTimer) {
      clearTimeout(popupCloseTimer);
      popupCloseTimer = null;
    }
  });
  
  // Relancer le timer si la souris quitte la modale
  mapPopup.addEventListener('mouseleave', () => {
    if (document.body.classList.contains('view-map-only') && !window.popupLocked) {
      popupCloseTimer = setTimeout(() => {
        mapPopup.classList.remove('show');
        popupCloseTimer = null;
      }, 100);
    }
  });
}
</script>

</body>
</html>