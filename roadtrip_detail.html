<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JK3QGQGDDL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-JK3QGQGDDL');
</script>
<!-- Mobile redirect (only for narrow screens < 900px) -->
<script>
(function(){
  // ANTI-LOOP: utiliser localStorage (persiste entre rechargements) au lieu de sessionStorage
  var REDIRECT_MARKER = 'ort_redirect_in_progress_' + new Date().getHours();
  
  // Skip in iframes (artifacts, embeds)
  if (window.self !== window.top) return;
  // Skip if forced desktop mode
  if (/mobile=0/.test(location.search)) return;
  // Skip if redirect already in progress (prevent loop)
  if (localStorage.getItem(REDIRECT_MARKER)) {
    console.log('[ORT] Redirect already in progress, skipping');
    return;
  }
  
  // Fonction de redirection vers mobile
  function redirectToMobile() {
    localStorage.setItem(REDIRECT_MARKER, '1');
    var newUrl = location.href.replace(/roadtrip_detail(_simple)?(\.html)?/, 'roadtrip_mobile.html');
    if (newUrl === location.href) newUrl = location.href.replace(/\/([^\/]*)$/, '/roadtrip_mobile.html$1');
    if (!/mobile=0/.test(newUrl)) {
      var sep = newUrl.includes('?') ? '&' : '?';
      newUrl += sep + 'mobile=0';
    }
    console.log('[ORT] Redirecting to mobile:', newUrl);
    location.replace(newUrl);
  }
  
  // Detect mobile via user-agent
  var isMobile = /Android|iPhone|iPad|iPod|webOS|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  if (!isMobile) return;
  
  // Rediriger si écran étroit au chargement
  if (window.innerWidth < 900) {
    redirectToMobile();
    return;
  }
  
  // Écouter les changements d'orientation/resize
  window.addEventListener('resize', function() {
    if (window.innerWidth < 900) {
      redirectToMobile();
    }
  });
})();
</script>
<title>OneRoadTrip - Détails du roadtrip</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
:root{--bg:#113f7a;--card:#fff;--ink:#113f7a;--bd:#c3d6b6;--mut:#6b7a99;--danger:#c62828;--ok:#1b5e20}
*{box-sizing:border-box}
html,body{height:100%;overflow-x:hidden}
body{margin:0;background:linear-gradient(rgba(17,63,122,0.85),rgba(17,63,122,0.85)),url("/assets/image_index.webp") center/cover fixed;background-color:#113f7a;color:#e7f6fb;font-family:system-ui,sans-serif}

/* Mode lecture seule (partage) */
body.shared-view-only .delete-btn,
body.shared-view-only .edit-btn,
body.shared-view-only #btnSave,
body.shared-view-only #btnAddStep,
body.shared-view-only #btnAddMapStep,
body.shared-view-only #btnEditMapRoute,
body.shared-view-only .add-step-btn,
body.shared-view-only [contenteditable="true"] {
  display: none !important;
  pointer-events: none !important;
}
body.shared-view-only [contenteditable="true"] {
  display: block !important;
  pointer-events: none !important;
  user-select: text !important;
}

.wrap{max-width:1400px;margin:0 auto;padding:16px}
.card{background:var(--card);color:var(--ink);border-radius:14px;border:1px solid rgba(0,0,0,.08);padding:14px}
.small{font-size:.9rem;color:#1a3a7f}

header{position:sticky;top:0;z-index:10;background:url("/assets/image_index.webp") center/cover no-repeat #113f7a;border-bottom:2px solid rgba(255,255,255,0.2);box-shadow:0 2px 12px rgba(0,0,0,0.2);padding:10px 16px;display:flex;gap:12px;align-items:center}
.brandlink{display:flex;align-items:center;gap:10px;color:#fff;text-decoration:none}
.brandlink img{width:40px;height:40px}
header .brand{font-weight:800}
header .sp{flex:1}
.hdr-btn{padding:8px 10px;border-radius:10px;border:1px solid #113f7a;background:#fff;color:#113f7a;cursor:pointer;font-weight:600}

.topband{display:flex;flex-wrap:wrap;gap:12px;align-items:center;margin-bottom:12px}
.pill{background:#ffffff1a;color:#fff;border:1px solid #ffffff55;border-radius:999px;padding:6px 14px;font-weight:700;cursor:default}
.pill.clickable{cursor:pointer}
.pill.clickable:hover{background:#ffffff2b}
.pill.title{font-size:1.1rem;background:#fff;color:#113f7a;border:1px solid #113f7a}
.title-wrap{display:flex;align-items:center;gap:6px}
.title-edit-btn{background:none;border:none;cursor:pointer;font-size:14px;opacity:0.5;transition:opacity 0.2s;padding:4px}
.title-edit-btn:hover{opacity:1}
.title-wrap:not(:hover) .title-edit-btn{opacity:0}
.title-input{font-size:1.1rem;padding:6px 12px;border:2px solid #113f7a;border-radius:8px;color:#113f7a;font-weight:600;min-width:200px;max-width:400px}
.title-input:focus{outline:none;box-shadow:0 0 0 3px rgba(17,63,122,0.2)}
.counter{font-weight:800}
.counter.ok{color:#22c55e}
.counter.bad{color:#f87171}

.main{display:grid;grid-template-columns:3fr 2fr;gap:14px;align-items:start}
@media (max-width:1100px){.main{grid-template-columns:1fr}}

/* === Layout toggle (side-by-side vs stacked) === */
#layoutToggle .ico{width:22px;height:22px;vertical-align:-3px}
#layoutToggle .ico-h{display:none}
body.layout-stack #layoutToggle .ico-v{display:none}
body.layout-stack #layoutToggle .ico-h{display:inline-block}

/* Côte-à-côte (défaut) : grid 2 colonnes */
body.layout-side .main{display:grid;grid-template-columns:3fr 2fr;gap:14px;align-items:start}

/* Empilement : carte au-dessus, liste en dessous */
body.layout-stack .main{display:flex;flex-direction:column;gap:14px}
body.layout-stack .main>aside{order:0}
body.layout-stack .main>section{order:1}
body.layout-stack .sidebar{position:sticky;top:92px;margin-bottom:8px}

#map{
  width:100%;
  height:calc(100vh - 160px);
  min-height:520px;
  margin:0;
  border-radius:10px;
  position:relative;
  border:0;
}

/* Côté-à-côté : laisse de la place au popup à droite de la carte */
body.layout-side #map{
  width:calc(100% - 24px) !important;
  max-width:100% !important;
  margin-right:12px !important;
  height:min(68vh, 520px) !important;
  min-height:420px !important;
  border-bottom:0 !important;
}

body.layout-stack .main>section,
body.layout-stack .main>aside{ width:100% }

/* Popup Leaflet : largeur fixe et vignettes carrées (pas étirées) */
.leaflet-popup-content-wrapper{max-width:none}
.leaflet-popup-content{width:360px !important; margin:0}
.leaflet-popup{width:auto !important}

/* Grille d’images dans le popup (couvre la plupart des cas) */
.leaflet-popup-content .grid,
.leaflet-popup-content .photos,
.leaflet-popup-content .thumbs{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px;
}

/* Images non déformées, carrées */
.leaflet-popup-content img{
  width:100%;
  height:auto;
  display:block;
  border-radius:8px;
  object-fit:cover;
}

.leaflet-popup-content .grid img,
.leaflet-popup-content .photos img,
.leaflet-popup-content .thumbs img{
  aspect-ratio:1/1;        /* carré */
  object-fit:cover;        /* pas d’étirement */
}
/* Tooltip hover des "Autres lieux" */
.leaflet-tooltip.ort-hover{
  background:#fff; color:#0b3b6f; border:1px solid #cfd6e4;
  border-radius:8px; box-shadow:0 6px 14px rgba(0,0,0,.15);
  padding:8px; max-width:280px; z-index:12005;
}
.leaflet-tooltip.ort-hover img{ width:100%; height:auto; border-radius:6px; margin-top:6px; object-fit:cover }


/* Empilement : carte en haut, iti en bas, pleine largeur */
body.layout-stack .main{display:flex;flex-direction:column;gap:14px}
body.layout-stack .main>aside{order:0}
body.layout-stack .main>section{order:1}


.step-row{
  display: grid;
  /* 8 colonnes fixes en position, mais *adaptatives* en largeur */
  grid-template-columns:
    48px                          /* # étape */
    minmax(160px, 2fr)            /* nom lieu */
    minmax(55px,  auto)           /* distance */
    minmax(45px,  auto)           /* nuits */
    minmax(65px,  auto)           /* dates */
    minmax(70px, .5fr)            /* hôtel */
    minmax(40px,  auto)           /* réservations */
    40px;                         /* bouton ✕ */
  column-gap: 12px;
  align-items: center;
  background:#fff;
  border:1px solid #e5e7eb;
  border-radius:10px;
  padding:10px;
  margin-bottom:10px;
  transition: all .2s;
  /* ⚠️ supprimé: justify-content:space-between; (inutile en grid, causait des étirements) */
}
.step-row .cell:last-child{ justify-self:end } /* ✕ à droite */
.step-row:hover{ background:#f8fafc; box-shadow:0 2px 8px rgba(0,0,0,.08) }

/* Pour éviter les débords sur la 2e colonne (nom) */
.step-row .cell:nth-child(2){ min-width:0; overflow:hidden }
.step-row .cell:nth-child(2) a,
.step-row .cell:nth-child(2) .title,
.step-row .cell:nth-child(2) .name{
  display:inline-block; max-width:100%;
  white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}

/* Forcer les cellules suivantes à respecter l'espace */
.step-row .cell:nth-child(3),
.step-row .cell:nth-child(4),
.step-row .cell:nth-child(5) {
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
}

.step-row.highlight{background:#fef2f2;border-color:#fca5a5}
@media (max-width: 700px){
  .step-row{
    grid-template-columns:
      40px minmax(150px, 1.8fr) minmax(50px,auto) minmax(45px,auto)
      minmax(60px,auto) minmax(90px,.6fr) minmax(45px,auto) 36px;
    column-gap:8px;
  }
}

.step-row[draggable="true"]{cursor:grab}
.step-row.dragging{opacity:.6;border-style:dashed}
.cell{padding:4px}
.step-num{
  display:inline-flex;align-items:center;justify-content:center;
  width:24px;height:24px;border-radius:50%;
  background:#113f7a;color:#fff;font-weight:800;font-size:13px;
  border:2px solid #fff;box-shadow:0 1px 3px rgba(0,0,0,.25);
}

.cell .mut{color:var(--mut);font-size:.85rem}
.input{width:100%;padding:8px;border:1px solid #cbd5e1;border-radius:8px}
.btn{padding:8px 12px;border-radius:10px;border:1px solid #ffffff80;background:#113f7a;color:#fff;cursor:pointer;font-size:14px}
.btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.btn.active{background:#22c55e;border-color:#22c55e}
.btn.danger{background:#fee2e2;color:#dc2626;border:1px solid #fca5a5}
.iconbtn{background:#f8fafc;border:1px solid #e2e8f0;border-radius:8px;padding:6px;cursor:pointer;width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center}

/* Flèche “détail étape” + popover */
.go-btn{font-weight:700}
.go-pop{
  position:fixed; z-index:12000; background:#fff; color:#113f7a;
  border:1px solid #cfd6e4; border-radius:10px; box-shadow:0 10px 28px rgba(0,0,0,.18);
  padding:10px 12px; width:280px; max-width:90vw;
}
.go-pop .row{display:flex;gap:8px;justify-content:flex-end;margin-top:8px}
.go-pop .btn{background:#113f7a;border-color:#113f7a;color:#fff}
.go-pop .btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.sidebar{position:sticky;top:92px}


#map.pointer-mode{cursor:crosshair!important}
#map.pointer-mode .leaflet-container{cursor:crosshair!important}
.leaflet-container{border-radius:10px}
.leaflet-marker-icon{transition:all .2s!important}
.leaflet-marker-icon.marker-highlight{transform:scale(1.4)!important;filter:drop-shadow(0 0 12px #ef4444)!important;z-index:10000!important}
/* [F.1] le zoom part du centre (évite que le numéro “s’envole”) */
.leaflet-marker-icon{transform-origin:center center!important}
.custom-marker{background:transparent!important;border:none!important}

/* Markers de prévisualisation (verts) */
.preview-marker {
  background: #22c55e !important;
  border-color: #16a34a !important;
}

.preview-marker .marker-num {
  background: #22c55e;
  border-color: #16a34a;
}
/* === SURVOL LIGNE / POPUP === */
.leaflet-marker-icon.marker-hover{
  transform:scale(1.4)!important;
  filter:drop-shadow(0 0 10px #ef4444)!important;
  color:#ef4444!important;
  z-index:9999!important;
}

/* Pop-up unique en position:fixed avec z-index haut */
.map-popup{
  position:fixed; top:0; right:0;
  width:420px; 
  max-width: 90vw; /* s'adapte sur petits écrans */
  height:100vh;
  background:#fff; border-left:4px solid #113f7a; border-radius:0;
  box-shadow:-4px 0 20px rgba(0,0,0,.25); 
  overflow-y:auto; /* important: pas de scroll sur le parent */
  z-index:12000; display:none;
  transition: left 0.2s ease, right 0.2s ease;
}
.map-popup.show{display:block;}

/* En mode plein écran carte : le popup passe à gauche */
body.view-map-only .map-popup{
  left:0; right:auto;
  border-left:0; border-right:4px solid #113f7a;
  box-shadow:4px 0 20px rgba(0,0,0,.25);
}

/* Bouton ✕ collant en haut du flux scrollable */
.popup-close{

  position: sticky;
  top: 0;
  margin-left: auto;           /* pousse à droite dans .popup-content */
  display: flex; align-items: center; justify-content: center;
  width: 28px; height: 28px;
  background:#fff;
  border:1px solid #e5e7eb; border-radius:6px;
  cursor:pointer; z-index:10;
  /* lisibilité quand on scrolle sous des photos */
  box-shadow: 0 2px 6px rgba(0,0,0,.08);
}

/* Le contenu reste scrollable, le ✕ reste visible en haut */
  .popup-content{
  position: relative;
  padding: 12px 12px 80px 12px; /* plus d'espace en bas pour le bouton */
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  height: calc(100vh - 44px); /* hauteur fixe moins le bouton close */
  -webkit-overflow-scrolling: touch; /* scroll fluide sur iOS */
}

/* FIX: garantir un flux séparé et éviter tout chevauchement */
#descVisits, #descActivities{
  display: flow-root; /* nouveau contexte de formatage, évite le recouvrement */
  clear: both;
  margin: 8px 0;
}

.popup-photos{position:relative;width:100%;height:200px;margin-bottom:10px;border-radius:10px;overflow:hidden;background:#1e293b}
.popup-photos .carousel-slide{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;transition:opacity 0.4s ease}
.popup-photos .carousel-slide.active{opacity:1}
.popup-photos .carousel-slide img{width:100%;height:100%;object-fit:cover}
.popup-photos .carousel-btn{position:absolute;top:50%;transform:translateY(-50%);width:32px;height:32px;background:rgba(255,255,255,0.9);border:none;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:1rem;color:#1e293b;box-shadow:0 2px 6px rgba(0,0,0,0.2);transition:all 0.2s;z-index:2}
.popup-photos .carousel-btn:hover{background:#fff;transform:translateY(-50%) scale(1.1)}
.popup-photos .carousel-btn.prev{left:6px}
.popup-photos .carousel-btn.next{right:6px}
.popup-photos .carousel-dots{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:flex;gap:5px;z-index:2}
.popup-photos .carousel-dot{width:7px;height:7px;border-radius:50%;background:rgba(255,255,255,0.5);cursor:pointer;transition:all 0.2s}
.popup-photos .carousel-dot.active{background:#fff;transform:scale(1.2)}
.popup-photos .carousel-counter{position:absolute;top:8px;right:8px;background:rgba(0,0,0,0.6);color:#fff;padding:3px 8px;border-radius:10px;font-size:0.7rem;font-weight:600;z-index:2}
.popup-photos .no-photo{display:flex;align-items:center;justify-content:center;height:100%;color:#94a3b8;font-size:0.85rem}
.popup-title{font-weight:700;font-size:1.05rem;color:#113f7a}
.popup-header{display:flex;align-items:center;gap:10px;margin-bottom:8px;flex-wrap:wrap}
.popup-stars{font-size:0.95rem;font-weight:600;letter-spacing:1px}
.popup-stars .star{color:#fbbf24}
.popup-stars .star-empty{color:#e5e7eb}
.popup-desc{font-size:.85rem;color:#475569;line-height:1.4;position:relative;z-index:1}
.popup-desc p{margin:8px 0}

footer{text-align:center;margin:18px 0 28px;font-size:14px;opacity:.9}

/* Boutons dans la fiche latérale : forcés en plein (bleu ORT sur fond blanc) */
.map-popup .btn{
  background:#113f7a !important;
  color:#fff !important;
  border:1px solid #113f7a !important;
  width: 100%; /* bouton pleine largeur */
  padding: 12px !important; /* plus facile à cliquer sur tablette */
  font-size: 15px !important;
   font-weight: 600 !important;
}

/* Conteneur d’actions spécifique, plus “dernier enfant” générique */
.map-popup .popup-actions{
  position: sticky;
  bottom: 0;
  background: #fff;
  padding: 12px 0;
  margin: 0 -12px -80px -12px; /* compense le padding du parent */
  padding-left: 12px;
  padding-right: 12px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.08);
  z-index: 10;
}
.map-popup .btn.ghost{
  background:#fff !important;
  color:#113f7a !important;

  border:1px solid #113f7a !important;
}


/* === FICHE PAYS — bouton latéral + tiroir === */
/* Bouton countryTab masqué - utiliser les icônes inline à la place */
#countryTab{
  display:none !important;
}

#countryDrawer{
  position:fixed; top:0; right:0; height:100vh; width:min(520px,88vw);
  background:#fff; color:#113f7a; z-index:12600; display:none;
  border-left:4px solid #113f7a; box-shadow:-6px 0 24px rgba(0,0,0,.22);
}
#countryDrawer.show{ display:block }
#countryDrawer .cd-head{
  position:sticky; top:0; background:#f8fbfc; padding:12px 14px;
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  border-bottom:1px solid #e5e7eb; z-index:1;
}
#countryDrawer .cd-title{ font-weight:900; font-size:1.05rem }
#countryDrawer .cd-close{
  background:#fff; border:1px solid #cfd6e4; border-radius:8px;
  width:32px; height:32px; display:inline-flex; align-items:center; justify-content:center; cursor:pointer;
}
#countryDrawer .cd-body{ padding:14px; overflow-y:auto; height:calc(100% - 56px) }
#countryDrawer .tabs{ display:flex; flex-wrap:wrap; gap:8px; padding:6px 0 12px }
#countryDrawer .tab{ background:#f1f5f9; border:1px solid #e2e8f0; padding:6px 10px; border-radius:999px; cursor:pointer; font-weight:700; color:#113f7a }
#countryDrawer .tab.active{ background:#c3d6b6; border-color:#c3d6b6 }
#countryDrawer .pane{ display:none; white-space:pre-wrap; line-height:1.45 }
#countryDrawer .pane.active{ display:block }


footer a{color:#c3d6b6;text-decoration:none}

.step-marker {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  font-size: 13px;
  font-weight: bold;
  text-align: center;
  line-height: 24px;
  border: 2px solid #fff;
  box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
/* [P.2] teinte rouge au survol ligne (sans changer le transform) */
.step-marker.marker-red{ background:#ef4444 !important; border-color:#fecaca !important; }


/* [J.1] Grossissement sur le chiffre interne (évite le “saut”) */
.step-marker .marker-num { transition: transform .15s ease; position: relative; }
.step-marker .marker-num.num-boost { transform: scale(1.35); transform-origin: center; }

/* Drapeau pour les hubs (étapes avec nuits d'hôtel) */
.step-marker .hub-flag {
  position: absolute;
  top: -10px;
  right: -8px;
  font-size: 12px;
  filter: drop-shadow(0 1px 1px rgba(0,0,0,0.3));
  animation: flag-wave 2s ease-in-out infinite;
}
@keyframes flag-wave {
  0%, 100% { transform: rotate(-5deg); }
  50% { transform: rotate(5deg); }
}

/* === OVERRIDES LAYOUT — prend le dessus sur #map par !important === */

/* Empilement : carte en haut, iti en bas, pleine largeur */
body.layout-stack .main{display:flex;flex-direction:column;gap:14px}
body.layout-stack .main>aside{order:0}
body.layout-stack .main>section{order:1}

/* Carte réduite en mode empilé */
body.layout-stack #map{
  height:calc(50vh - 80px) !important;
  min-height:280px !important;
  max-height:400px !important;
}


/* Côte-à-côte : laisser de la place au popup à droite */
body.layout-side #map{
  width:calc(100% - 24px) !important;   /* carte un peu plus étroite */
  margin-right:12px !important;
}

/* Popup custom : largeur fixe et position selon layout */
#map .map-popup{width:380px;max-width:380px}

/* En côte-à-côte : déporter le popup à droite DEHORS de la carte */
body.layout-side #map .map-popup{
  right:10px; left:auto;
  top:4px;                            /* plus haut */
}

/* En empilé : le popup reste au-dessus de la carte, centré visuellement */
body.layout-stack #map .map-popup{
  left:auto; right:10px;                /* redevient interne à la carte */
}


/* === Map / Itin full view toggles === */
.main{position:relative}
/* garder la carte sticky en scroll */
.sidebar{position:sticky; top:92px}

/* Overlays de la carte (en haut à droite) */
#mapActions{
  position:absolute; top:140px; right:8px; z-index:1000;
  display:flex; gap:6px;
}

@media (max-width:580px){
  #mapActions{
    top: 80px;
    right: 8px;
  }
  #mapActions .tool{
    width: 44px;
    height: 44px;
    font-size: 22px;
  }
}

/* >>> Assure que les contrôles Leaflet passent DEVANT #mapActions */
.leaflet-control-container{ z-index: 1201 !important; }

/* Optionnel : léger décalage à droite pour laisser respirer le layers-control */
body.layout-side .leaflet-top.leaflet-right{ right: 46px !important; }

/* Style générique pour tous les petits boutons carrés */
.ctl{
  width:32px; height:32px; border-radius:8px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#fff; color:#0b3b6f; border:1px solid #cfd6e4;
  box-shadow:0 2px 6px rgba(0,0,0,.12); cursor:pointer;
  padding:0;           /* assure le carré strict */
}
.ctl:hover{ background:#f6f8fb }

/* Style historique conservé pour les overlays de carte */
#mapActions .tool{
  width:40px; height:40px; border-radius:8px;
  display:inline-flex; align-items:center; justify-content:center;
  background:#fff; color:#0b3b6f; border:2px solid #cfd6e4;
  box-shadow:0 2px 6px rgba(0,0,0,.12); cursor:pointer;
  font-size:20px; font-weight:bold;
}
#mapActions .tool:hover{background:#f6f8fb}
#mapActions #btnMapFull, #mapActions #btnMapExit {
  background:#dc3545; color:#fff; border-color:#dc3545;
}
#mapActions #btnMapFull:hover, #mapActions #btnMapExit:hover {
  background:#c82333; border-color:#bd2130;
}

/* Plein écran carte */
body.view-map-only {
  overflow: hidden; /* Empêche le scroll du body */
}
body.view-map-only .main{display:block}
body.view-map-only .main>section{display:none !important}
body.view-map-only .main>aside{
  width:100% !important;
  position: fixed;
  top: 92px;
  left: 0;
  right: 0;
  height: calc(100vh - 92px);
  padding-top: 0;
  z-index: 1;
}

body.view-map-only #map{
  height: 100% !important;
  min-height: 520px !important;
  width: 100% !important;
  position: relative;
}

/* Décalage des contrôles Leaflet en plein écran pour éviter le header */
body.view-map-only .leaflet-top {
  top: 110px !important;
}


/* Plein écran itinéraire */
body.view-itin-only {
  overflow: hidden;
}
body.view-itin-only header {
  display: none !important;
}
body.view-itin-only .main{display:block}
body.view-itin-only .main>aside{display:none !important}
body.view-itin-only .main>section{
  width:100% !important;
  max-width: 100% !important;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  height: 100vh;
  overflow-y: auto;
  padding: 48px 10px 10px 10px;
  z-index: 9999;
  background: #113f7a;
  border-radius: 0;
  box-shadow: none;
}
body.view-itin-only .main>section>.small,
body.view-itin-only .main>section>div:first-child {
  display: none !important;
}
body.view-itin-only .main>section>div:last-child {
  display: none !important;
}

/* === MODE PLEIN ÉCRAN LISTE (2 colonnes) === */
body.view-itin-only #rows {
  max-width: 100%;
  margin: 0;
  display: grid;
  grid-template-columns: 1fr;
  gap: 3px 8px;
}

/* Lignes ultra-compactes en plein écran */
body.view-itin-only .step-row {
  padding: 3px 6px !important;
  margin-bottom: 3px !important;
  border-radius: 4px !important;
  min-height: auto !important;
  font-size: 0.8rem !important;
  column-gap: 6px !important;
  grid-template-columns:
    32px                          /* # étape */
    minmax(130px, 1.6fr)          /* nom lieu */
    55px                          /* distance */
    42px                          /* nuits */
    60px                          /* dates */
    minmax(75px, 0.6fr)           /* hôtel */
    minmax(45px, auto)            /* réservations */
    24px !important;              /* bouton ✕ */
}
body.view-itin-only .step-row .cell {
  padding: 1px 2px !important;
}
body.view-itin-only .step-row .step-num {
  width: 20px !important;
  height: 20px !important;
  font-size: 11px !important;
}
body.view-itin-only .step-row .stars {
  font-size: 0.65rem !important;
}
body.view-itin-only .step-row .visit-time {
  font-size: 0.7rem !important;
}
/* Cacher les éléments non essentiels */
body.view-itin-only .step-row .link-icon,
body.view-itin-only .step-row [data-i18n-title="step.link"],
body.view-itin-only .step-row .eye-btn,
body.view-itin-only .step-row .copy-btn {
  display: none !important;
}
/* Réduire la taille des badges hôtel */
body.view-itin-only .hotel-card {
  padding: 2px 4px !important;
  font-size: 0.7rem !important;
}
body.view-itin-only .hotel-card img {
  display: none !important;
}
body.view-itin-only .hotel-card .hotel-name {
  max-width: 80px !important;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
/* Bouton supprimer plus petit */
body.view-itin-only .step-row .del-btn,
body.view-itin-only .step-row .iconbtn:last-child {
  width: 18px !important;
  height: 18px !important;
  font-size: 10px !important;
  padding: 0 !important;
}
/* Input nuits plus compact */
body.view-itin-only .step-row input[type="number"] {
  width: 32px !important;
  height: 22px !important;
  font-size: 0.75rem !important;
  padding: 1px !important;
}
/* Dates plus compactes */
body.view-itin-only .step-row .dates-cell {
  font-size: 0.7rem !important;
  line-height: 1.1 !important;
}
/* Badge groupe plus petit */
body.view-itin-only .group-badge {
  font-size: 7px !important;
  padding: 1px 3px !important;
  top: 2px !important;
  left: 4px !important;
}

/* Responsive: 1 colonne sur petits écrans */
@media (max-width: 1100px) {
  body.view-itin-only #rows {
    grid-template-columns: 1fr;
  }
}

/* Icônes SVG (taille unifiée) */
.btn-ico{width:18px;height:18px;vertical-align:-2px}

/* Icône réorganisation en mode plein écran (BAS GAUCHE) */
#reorgFullscreenBtn{
  display:none;
  width:40px;            
  height:40px;
  border-radius:8px;     
  background:#fff;       
  color:#dc2626;         
  border:2px solid #cfd6e4; 
  box-shadow:0 2px 6px rgba(0,0,0,.12);
  font-size:20px;        
  font-weight:bold;
  cursor:pointer;
  transition:all .2s;
  align-items:center;
  justify-content:center;
}
/* Dans mapActions : position absolute */
#mapActions #reorgFullscreenBtn{
  position:absolute;      
  top:46px;              
  right:0;               
  z-index:1000;
  display:none;
}
/* Dans mapActions en mode map-only */
body.view-map-only #mapActions #reorgFullscreenBtn{ display:inline-flex; }
/* Dans Outils : normal (tools-item) */
#toolsPop #reorgFullscreenBtn{
  display:block;
  position:static;
  width:auto;
  height:auto;
  background:transparent;
  color:inherit;
  border:none;
  box-shadow:none;
  font-size:inherit;
  padding:0;
}
#reorgFullscreenBtn:hover{
  background:#fef2f2;    
  border-color:#dc2626;  
  transform:scale(1.05); 
}

/* Modal d'information réorganisation */
#reorgInfoModal{
  position:fixed; inset:0; z-index:13000;
  background:rgba(0,0,0,.6); display:none;
  align-items:center; justify-content:center;
  backdrop-filter:blur(4px);
}
#reorgInfoModal.show{ display:flex; }
.reorg-info-box{
  background:#fff; color:#113f7a;
  border:4px solid #113f7a; border-radius:16px;
  padding:24px 28px; max-width:min(560px,90vw);
  box-shadow:0 12px 40px rgba(0,0,0,.3);
  position:relative;
}
.reorg-info-box h2{
  margin:0 0 16px; font-size:1.4rem; font-weight:800;
  color:#113f7a; display:flex; align-items:center; gap:10px;
}
.reorg-info-box p{
  margin:10px 0; line-height:1.6; font-size:1rem;
}
.reorg-info-box strong{
  color:#113f7a; font-weight:700;
}
.reorg-info-box .btn-close-info{
  margin-top:20px; width:100%; padding:12px;
  background:#113f7a; color:#fff; border:2px solid #113f7a;
  border-radius:10px; font-size:1.05rem; font-weight:700;
  cursor:pointer; transition:all .2s;
}
.reorg-info-box .btn-close-info:hover{
  background:#1a4d8f; border-color:#1a4d8f;
}

/* === Panneau latéral de réorganisation === */
#reorgPanel {
  position: fixed;
  top: 0;
  right: -420px; /* caché par défaut */
  width: 400px;
  height: 100vh;
  background: #fff;
  color: #113f7a;
  border-left: 4px solid #113f7a;
  box-shadow: -6px 0 24px rgba(0,0,0,.22);
  z-index: 13500;
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
}

#reorgPanel.show {
  right: 0;
}

/* Header du panneau */
.reorg-panel-header {
  background: #113f7a;
  color: #fff;
  padding: 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-shrink: 0;
}

.reorg-panel-header h3 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 800;
}

.reorg-panel-close {
  width: 32px;
  height: 32px;
  border-radius: 8px;
  background: rgba(255,255,255,0.2);
  border: 1px solid rgba(255,255,255,0.3);
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: all 0.2s;
}

.reorg-panel-close:hover {
  background: rgba(255,255,255,0.3);
  transform: scale(1.05);
}

/* Corps du panneau (liste des étapes) */
.reorg-panel-body {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 16px 16px 100px 16px; /* beaucoup plus d'espace en bas */
  -webkit-overflow-scrolling: touch; /* scroll fluide iOS */
}

/* Item d'étape */
.reorg-step-item {
  background: #f8f9fa;
  border: 2px solid #e5e7eb;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
  position: relative;
  display: flex;
  align-items: center;
  gap: 12px;
}

.reorg-step-item:hover {
  border-color: #113f7a;
  transform: translateX(-4px);
}

/* Étape modifiée (position changée) */
.reorg-step-item.selected {
  background: #fee;
  border-color: #ef4444;
}

/* Étape supprimée */
.reorg-step-item.deleted {
  background: #fecaca;
  border-color: #ef4444;
  opacity: 0.7;
  text-decoration: line-through;
}

/* Numéro d'ordre */
.reorg-step-num {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: #113f7a;
  color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 14px;
  flex-shrink: 0;
}

.reorg-step-item.selected .reorg-step-num {
  background: #ef4444;
}

.reorg-step-item.deleted .reorg-step-num {
  background: #ef4444;
}

/* Info de l'étape */
.reorg-step-info {
  flex: 1;
  min-width: 0;
}

.reorg-step-name {
  font-weight: 700;
  font-size: 1rem;
  color: #113f7a;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.reorg-step-meta {
  font-size: 0.85rem;
  color: #64748b;
  margin-top: 4px;
}

/* Badge état (supprimé/modifié) */
.reorg-step-badge {
  position: absolute;
  top: 8px;
  right: 8px;
  background: #ef4444;
  color: #fff;
  font-size: 11px;
  font-weight: 700;
  padding: 3px 8px;
  border-radius: 12px;
}

.reorg-step-item.deleted .reorg-step-badge {
  background: #ef4444;
}

/* Icônes flottants sous les instructions */
.reorg-float-tools{
  position: relative;
  display: flex;
  gap: 12px;
  margin-top: 12px;
  overflow: visible;           /* évite le rognage du tooltip */
}
.reorg-fab{
  position: relative;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 2px solid #113f7a;
  background: #fff;
  color: #113f7a;
  font-size: 18px;
  font-weight: 700;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 3px 10px rgba(0,0,0,.12);
}
.reorg-fab:hover{ transform: translateY(-1px); }
.reorg-fab:active{ transform: translateY(0); }

/* Tooltip I18N (toujours DANS le panneau) */
.reorg-tip{
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translate(-50%, -2px);
  z-index: 5;
  background: #0b3b6f;
  color: #fff;
  font-size: 12px;
  line-height: 1.35;
  padding: 8px 10px;
  border-radius: 8px;
  white-space: normal;
  width: 260px;                /* largeur fixe lisible */
  max-width: calc(100vw - 80px);
  box-shadow: 0 6px 18px rgba(0,0,0,.18);
  opacity: 0;
  pointer-events: none;
  transition: opacity .15s ease, transform .15s ease;
}
.reorg-fab:hover .reorg-tip{ opacity: 1; }

/* réalignements anti-découpage */
.reorg-tip.align-left{  left: 0;   transform: translateY(-2px); }
.reorg-tip.align-right{ right: 0;  left: auto; transform: translateY(-2px); }

/* Bouton Prévisualiser - rouge centré en haut de la carte */
.reorg-save-btn {
  position: fixed;
  top: 140px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9999;
  background: #c62828;
  color: #fff;
  border: 2px solid #a21919;
  border-radius: 10px;
  padding: 12px 28px;
  font-size: 1.1rem;
  font-weight: 700;
  cursor: pointer;
  transition: all 0.2s;
  display: none;
  align-items: center;
  justify-content: center;
  gap: 8px;
  box-shadow: 0 4px 16px rgba(198, 40, 40, 0.3);
}

/* Visible uniquement quand le panneau de réorganisation est ouvert */
.reorg-panel.show .reorg-save-btn,
body.reorg-active .reorg-save-btn {
  display: flex;
}

.reorg-save-btn:hover {
  background: #d32f2f;
  transform: translateX(-50%) translateY(-2px);
  box-shadow: 0 6px 20px rgba(198, 40, 40, 0.5);
}

.reorg-save-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: translateX(-50%);
}


/* Instructions en haut du panneau */
.reorg-instructions {
  background: #e3f2fd;
  border: 2px solid #2196F3;
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 16px;
  font-size: 0.9rem;
  line-height: 1.5;
  color: #0b3b6f;
}

.reorg-instructions strong {
  color: #113f7a;
}

/* Overlay pendant la réorganisation */
body.reorg-active #reorgPanel {
  right: 0;
}

body.reorg-active #map {
  pointer-events: all;
}

/* Marqueur en mode réorganisation */
body.reorg-active .leaflet-marker-icon {
  cursor: pointer !important;
  transition: transform 0.2s, filter 0.2s;
}

body.reorg-active .leaflet-marker-icon:hover {
  transform: scale(1.15);
}

/* Marqueur sélectionné (bleu) */
.leaflet-marker-icon.reorg-selected {
  filter: hue-rotate(200deg) brightness(1.2);
}

/* Marqueur supprimé (rouge grisé) */
.leaflet-marker-icon.reorg-deleted {
  filter: grayscale(80%) brightness(0.8);
  opacity: 0.5;
}

/* Animations pour effet miroir liste → carte */
@keyframes marker-pulse-red {
  0% { filter: drop-shadow(0 0 0px transparent); }
  50% { filter: drop-shadow(0 0 16px #ef4444); }
  100% { filter: drop-shadow(0 0 0px transparent); }
}

@keyframes marker-pulse-green {
  0% { filter: drop-shadow(0 0 0px transparent); }
  50% { filter: drop-shadow(0 0 16px #22c55e); }
  100% { filter: drop-shadow(0 0 0px transparent); }
}

@keyframes marker-pulse-gray {
  0% { filter: grayscale(0%); }
  50% { filter: grayscale(100%); }
  100% { filter: grayscale(0%); }
}

.leaflet-marker-icon.marker-animate-red {
  animation: marker-pulse-red 0.6s ease;
}

.leaflet-marker-icon.marker-animate-green {
  animation: marker-pulse-green 0.6s ease;
}

.leaflet-marker-icon.marker-animate-gray {
  animation: marker-pulse-gray 0.6s ease;
}

/* Modal de prévisualisation de réorganisation */
#reorgPreviewModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  background: transparent;
  display: none;
  align-items: center;
  justify-content: flex-start;
  z-index: 11000;
  opacity: 0;
  transition: opacity 0.3s;
  pointer-events: none;
}

#reorgPreviewModal.show {
  opacity: 1;
  pointer-events: none;
}

.reorg-preview-box {
  background: #fff;
  border-radius: 0 14px 14px 0;
  padding: 16px 16px 120px 16px; /* plus d'espace en bas pour les boutons */
  width: 320px;
  max-width: 90vw; /* s'adapte aux petits écrans */
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  box-shadow: 4px 0 20px rgba(0, 0, 0, 0.25);
  margin-left: 0;
  pointer-events: auto;
  -webkit-overflow-scrolling: touch; /* scroll fluide iOS */
  display: flex;
  flex-direction: column;
}

.reorg-preview-box h2 {
  margin: 0 0 16px 0;
  font-size: 1.3rem;
  color: #113f7a;
}

.preview-step-item {
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.preview-step-num {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  flex-shrink: 0;
}

.preview-step-content {
  flex: 1;
}

.preview-step-name {
  font-weight: 600;
  color: #113f7a;
  margin-bottom: 4px;
}

.preview-step-nights {
  font-size: 0.85rem;
  color: #64748b;
}

/* Conteneur des boutons de prévisualisation - sticky en bas */
.reorg-preview-box > div:last-child {
  position: sticky;
  bottom: 0;
  background: #fff;
  padding: 16px 0 0 0;
  margin: 16px -16px -120px -16px; /* compense le padding du parent */
  padding-left: 16px;
  padding-right: 16px;
  box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
  z-index: 10;
}

.btn-preview-cancel,
.btn-preview-validate {
  padding: 12px 24px !important;
  font-size: 15px !important;
  font-weight: 600 !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  transition: all 0.2s;
}

.btn-preview-cancel {
  border: 2px solid #94a3b8 !important;
  background: #fff !important;
  color: #475569 !important;
}

.btn-preview-cancel:hover {
  background: #f1f5f9 !important;
  border-color: #64748b !important;
}

.btn-preview-validate {
  border: none !important;
  background: #113f7a !important;
  color: #fff !important;
}

.btn-preview-validate:hover {
  background: #0d3461 !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(17, 63, 122, 0.3);
}

/* Zone de contenu scrollable de la prévisualisation */
#reorgPreviewContent {
  flex: 1;
  overflow-y: auto !important;
  overflow-x: hidden;
  max-height: calc(100vh - 200px) !important;
  padding-bottom: 20px;
  -webkit-overflow-scrolling: touch;
}

/* Aide/Légende à côté du titre */
.help-anchor{position:relative;display:flex;align-items:center;gap:8px;flex-wrap:wrap}
```css

.reorg-preview-box h2 {
  margin: 0 0 16px 0;
  font-size: 1.3rem;
  color: #113f7a;
}

.preview-step-item {
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 10px;
  padding: 12px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 12px;
}

.preview-step-num {
  background: #113f7a;
  color: #fff;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.9rem;
  flex-shrink: 0;
}

.preview-step-content {
  flex: 1;
}

.preview-step-name {
  font-weight: 600;
  color: #113f7a;
  margin-bottom: 4px;
}

.preview-step-nights {
  font-size: 0.85rem;
  color: #64748b;
}

.btn-preview-cancel:hover {
  background: #f1f5f9;
}

.btn-preview-validate:hover {
  background: #0d3461;
}

.help-pop{
  position:absolute; top:100%; left:0;
  background:#fff; color:#0b3b6f;
  border:1px solid #cfd6e4; border-radius:10px;
  padding:12px; width:320px; box-shadow:0 8px 28px rgba(0,0,0,.18);
  display:none; z-index:1200;
}
.help-pop.show{display:block}

/* ➜ Affichage au SURVOL de la zone titre + i (plus besoin de clic) */
.help-anchor:hover .help-pop{display:block}
.help-pop .row{display:flex;justify-content:space-between;margin:6px 0}
.help-pop .mut{color:#64748b;font-size:.9rem}

/* Icônes actions dans la ligne du header (avant la date) */
.rt-inline-icons{
  position:static;            /* plus d'absolu */
  display:inline-flex;
  gap:8px;
  z-index:auto;
  margin-right:8px;           /* petit espace avant la date */
  transform:none;
}
.pill-ico{
  width:32px;height:32px;border-radius:999px;


  display:inline-flex;align-items:center;justify-content:center;
  background:#fff; color:#113f7a;
  border:1px solid #cfd6e4; box-shadow:0 2px 6px rgba(0,0,0,.12);
  cursor:pointer; line-height:1; font-size:18px; padding:0;
}
.pill-ico.danger{ color:#dc2626; border-color:#fecaca; }
.pill-ico.saved{ background:#c3d6b6; color:#0f5132; border-color:#c3d6b6; }

/* Badge moyenne (★ 8.2/10) */
#rtAvgBadge{
  font:700 12px/1 system-ui; color:#113f7a; background:#fff;
  border:1px solid #cfd6e4; border-radius:10px; padding:4px 8px;
  display:none; align-items:center; gap:4px;
}

/* Popover de notation */
.rate-pop{
  position:absolute; z-index:12000;
  background:#fff; color:#113f7a; border:1px solid #cfd6e4;
  border-radius:12px; box-shadow:0 10px 28px rgba(0,0,0,.18);
  padding:12px; width:min(320px,92vw);
}
.rate-pop .row{display:flex; align-items:center; justify-content:space-between; gap:8px; margin:6px 0}
.rate-pop .btn{background:#113f7a;color:#fff;border:1px solid #113f7a}
.rate-pop .btn.ghost{background:#fff;color:#113f7a;border:1px solid #113f7a}
.rate-pop .mut{color:#64748b;font-size:.9rem}

/* Couleurs de note (texte) */
.note-bad{color:#dc2626}
.note-mid{color:#d97706}
.note-good{color:#16a34a}

/* Pavé stats compact */
.pill.stats{background:#ffffff; color:#113f7a; border-color:#113f7a}
.pill.stats span{font-weight:700}



/* === Header aligné sur 'presentation.html' === */
header{position:sticky;top:0;z-index:10;background:url("/assets/image_index.webp") center/cover no-repeat #113f7a;color:#fff;padding:12px 16px;display:flex;align-items:center;gap:12px;border-bottom:2px solid rgba(255,255,255,0.2);box-shadow:0 2px 12px rgba(0,0,0,0.2)}
.brandlink{display:flex;align-items:center;gap:10px;color:#fff;text-decoration:none}
.brandlink img{width:80px;height:80px}
.brand{font-weight:800;font-size:20px}
.spacer{flex:1}
.langpick{appearance:none;background:#fff;border:1px solid #113f7a;border-radius:10px;padding:8px 10px;cursor:pointer;color:#113f7a}
.btn{padding:8px 12px;border-radius:10px;border:1px solid #ffffff80;background:#ffffff1a;color:#fff;cursor:pointer}
.btn:hover{background:#ffffff2b}
.btn:disabled{opacity:.6;cursor:not-allowed}
.auth{position:relative}
.auth-pop{position:absolute;right:0;top:44px;background:#fff;color:#113f7a;border:1px solid #c3d6b6;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:8px;display:none;min-width:260px}
.auth-pop .btn{display:block;width:100%;margin:6px 0;background:#113f7a;border:1px solid #113f7a;color:#fff}
.auth-pop .btn.out{background:#fff;color:#113f7a}

/* == Outils dans le header == */
.rt-tools{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-right:8px}
.rt-tools .btn{background:#ffffff1a;border-color:#ffffff80}
.rt-tools .btn.ghost{background:#fff;color:#113f7a;border-color:#113f7a}

/* == Carte sans "tour" (pas de carte encartée) == */
.sidebar > .card{background:transparent;border:0;padding:0}
#map{border:0 !important;border-radius:10px}

/* On supprime toute mention d’aide sous la carte → pas besoin de place */
#map + .small{display:none}

/* === Mobile toolbar (≤ 580px) === */
@media (max-width:580px){
  header .brandlink img{width:48px;height:48px}
  header .brand{font-size:18px}
  .rt-tools{gap:6px}

  /* Sur mobile, réduire les boutons */
  #btnAddStep, #btnAddMapStep, #btnEditMapRoute { padding:8px 10px; font-size:13px; }
  #toolsBtn { padding:8px 10px; font-size:13px; }
}

/* Popup Outils */
.tools-pop {
  position: fixed;
  background: #fff;
  color: #113f7a;
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.2);
  padding: 8px 0;
  min-width: 240px;
  max-width: 280px;
  max-height: 80vh;
  overflow-y: auto;
  display: none;
  z-index: 12000;
}
.tools-pop.show { display: block; }

.tools-pop-title {
  font-weight: 700;
  font-size: 15px;
  padding: 10px 16px 12px;
  border-bottom: 1px solid #e2e8f0;
  margin-bottom: 4px;
  background: linear-gradient(135deg, #113f7a 0%, #1a5298 100%);
  color: #fff;
  border-radius: 11px 11px 0 0;
  margin: -8px 0 8px 0;
  padding: 12px 16px;
}

.tools-section-title {
  font-size: 11px;
  font-weight: 700;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 8px 16px 4px;
}

.tools-item {
  display: flex;
  align-items: center;
  gap: 8px;
  width: 100%;
  padding: 10px 16px;
  background: none;
  border: none;
  font: inherit;
  font-size: 14px;
  color: #113f7a;
  cursor: pointer;
  text-align: left;
  transition: background 0.15s;
}
.tools-item:hover {
  background: #f1f5f9;
}

.tools-separator {
  height: 1px;
  background: #e2e8f0;
  margin: 8px 0;
}

/* Mobile: menu Outils plein écran */
@media (max-width: 480px) {
  .tools-pop {
    position: fixed;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    max-width: none;
    max-height: none;
    border-radius: 0;
    padding-bottom: 60px;
  }
  .tools-pop-title {
    border-radius: 0;
    font-size: 17px;
    padding: 16px;
  }
  .tools-item {
    padding: 14px 16px;
    font-size: 15px;
  }
  .tools-section-title {
    padding: 12px 16px 6px;
  }
}

.tools-layout {
  display: flex;
  align-items: center;
  gap: 8px;
}
.tools-layout .layout-btn {
  width: 32px;
  height: 32px;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  background: #f8fafc;
  cursor: pointer;
  font-size: 16px;
  transition: all 0.15s;
}
.tools-layout .layout-btn:hover {
  background: #e2e8f0;
}
.tools-layout .layout-btn.active {
  background: #113f7a;
  color: #fff;
  border-color: #113f7a;
}

.tools-lang {
  display: flex;
  align-items: center;
  gap: 8px;
}
.tools-lang-select {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 13px;
  color: #113f7a;
  background: #fff;
  cursor: pointer;
}

/* Mode submenu inline (dans le popup) */
.mode-submenu-inline {
  display: none;
  background: #f8fafc;
  border-radius: 6px;
  margin: 4px 12px 8px;
  padding: 4px;
}
.mode-submenu-inline.show {
  display: block;
}
.mode-submenu-inline > div,
.mode-submenu-inline > button {
  padding: 8px 12px;
  cursor: pointer;
  border-radius: 4px;
  font-size: 13px;
  width: 100%;
  text-align: left;
  background: none;
  border: none;
}
.mode-submenu-inline > div:hover,
.mode-submenu-inline > button:hover {
  background: #e2e8f0;
}

/* Labels de groupe au-dessus des points */
.step-label{
  position:relative;
  transform: translate(-50%, -28px); /* centré au-dessus du point */
  background:#fff; color:#113f7a; border:1px solid #cfd6e4;
  border-radius:10px; padding:2px 6px; font-size:12px; font-weight:700;
  box-shadow:0 2px 6px rgba(0,0,0,.12);
  white-space:nowrap; pointer-events:none; /* ne capte pas la souris */
  user-select:none;
}

.step-label.group-label {
  pointer-events: auto; /* Rendre cliquable */
  cursor: pointer;
  transition: all 0.2s ease;
}

.step-label.group-label:hover,
.step-label.group-label.highlighted {
  transform: translate(-50%, -28px) scale(1.5);
  z-index: 1000;
  background: #fef3c7;
  border-color: #f59e0b;
  box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
}

/* Mini marqueurs pour les sous-étapes (multi-nuits) */
.mini-step-marker {
  width: 20px;
  height: 20px;
  background: #3b82f6;
  border: 2px solid white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.mini-step-num {
  color: white;
  font-size: 10px;
  font-weight: 700;
  line-height: 1;
}

.mini-step-marker-hover {
  width: 32px !important;
  height: 32px !important;
  transform: scale(1.3);
  background: #2563eb;
  border-color: #fbbf24;
  box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
  z-index: 1000 !important;
}

.mini-step-marker-hover .mini-step-num {
  font-size: 13px;
}

/* Forcer l’affichage des boutons de disposition en desktop */
@media (min-width:581px){
  #layoutSideBtn, #layoutStackBtn { display:inline-flex !important; }
}
/* === COULEURS DES GROUPES HOTELS === */

/* === Étoiles (marqueurs 5★) === */
.star-marker {
  filter: drop-shadow(0 1px 3px rgba(0,0,0,0.4));
  transition: transform 0.15s ease;
}

.star-marker:hover {
  transform: scale(1.2);
}

.star-marker.selected {
  filter: drop-shadow(0 2px 4px rgba(225,29,72,0.5));
}

/* === PANNEAU EXPANDABLE ACTIVITÉS === */
.step-wrapper {
  margin-bottom: 10px;
}
.step-expand-toggle {
  background: linear-gradient(135deg, #113f7a 0%, #1a5298 100%);
  border: none;
  cursor: pointer;
  font-size: 14px;
  color: #fff;
  padding: 8px 12px;
  border-radius: 8px;
  transition: all 0.2s;
  box-shadow: 0 2px 8px rgba(17,63,122,0.3);
  font-weight: 600;
}
.step-expand-toggle:hover {
  background: linear-gradient(135deg, #0d2f5c 0%, #113f7a 100%);
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(17,63,122,0.4);
}
.step-expand-toggle.open {
  transform: rotate(90deg);
  background: linear-gradient(135deg, #ff5533 0%, #ff7744 100%);
  box-shadow: 0 2px 8px rgba(255,85,51,0.3);
}
.step-details-panel {
  display: none;
  background: #f8fafc;
  border: 1px solid #e2e8f0;
  border-radius: 0 0 10px 10px;
  margin-top: -10px;
  padding: 12px 14px;
  margin-bottom: 10px;
}
.step-details-panel.open {
  display: block;
}
.step-details-section {
  margin-bottom: 12px;
}
.step-details-section h4 {
  font-size: 0.85rem;
  color: #475569;
  margin: 0 0 8px 0;
  display: flex;
  align-items: center;
  gap: 6px;
}
.step-details-list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.step-details-list li {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 8px;
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 6px;
  margin-bottom: 6px;
  font-size: 0.9rem;
}
.step-details-list li .item-text {
  flex: 1;
  min-width: 0;
}
.step-details-list li .item-text[contenteditable] {
  outline: none;
  cursor: text;
}
.step-details-list li .item-text[contenteditable]:focus {
  background: #fffbeb;
  border-radius: 4px;
}
.step-details-list li .item-del {
  background: none;
  border: none;
  cursor: pointer;
  color: #94a3b8;
  font-size: 14px;
  padding: 2px;
}
.step-details-list li .item-del:hover {
  color: #ef4444;
}
.step-add-item {
  display: flex;
  gap: 6px;
  margin-top: 6px;
}
.step-add-item input {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 0.85rem;
}
.step-add-item button {
  background: #22c55e;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 6px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.85rem;
}
.step-add-item button:hover {
  background: #16a34a;
}
.step-actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e2e8f0;
}
.step-action-link {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 0.8rem;
  color: #64748b;
  text-decoration: none;
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
  background: #fff;
  transition: all 0.2s;
}
.step-action-link:hover {
  background: #f1f5f9;
  color: #113f7a;
  border-color: #113f7a;
}
.step-action-link.coming-soon {
  opacity: 0.5;
  cursor: not-allowed;
}
.step-action-link.coming-soon:hover {
  background: #fff;
  color: #64748b;
  border-color: #e2e8f0;
}
/* Icônes d'action avec tooltips */
.step-actions-icons {
  display: flex;
  gap: 8px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid #e2e8f0;
}
.action-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  font-size: 1.2rem;
  border-radius: 8px;
  border: 1px solid #e2e8f0;
  background: #fff;
  cursor: pointer;
  transition: all 0.2s;
  text-decoration: none;
  position: relative;
}
.action-icon:hover {
  background: #f1f5f9;
  border-color: #113f7a;
  transform: scale(1.1);
}
.action-icon.disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.action-icon.disabled:hover {
  transform: none;
  background: #fff;
  border-color: #e2e8f0;
}
/* Tooltip natif amélioré via CSS */
.action-icon[title] {
  position: relative;
}
.section-icon {
  cursor: help;
}

/* Carrousel de photos dans le panneau de détails */
.step-photos-carousel {
  position: relative;
  width: 100%;
  height: 180px;
  border-radius: 12px;
  overflow: hidden;
  background: #1e293b;
  margin-bottom: 16px;
}
.step-photos-carousel .carousel-slide {
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  opacity: 0;
  transition: opacity 0.4s ease;
}
.step-photos-carousel .carousel-slide.active {
  opacity: 1;
}
.step-photos-carousel .carousel-slide img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.step-photos-carousel .carousel-btn {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 36px;
  height: 36px;
  background: rgba(255,255,255,0.9);
  border: none;
  border-radius: 50%;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  color: #1e293b;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  transition: all 0.2s;
  z-index: 2;
}
.step-photos-carousel .carousel-btn:hover {
  background: #fff;
  transform: translateY(-50%) scale(1.1);
}
.step-photos-carousel .carousel-btn.prev { left: 8px; }
.step-photos-carousel .carousel-btn.next { right: 8px; }
.step-photos-carousel .carousel-dots {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  z-index: 2;
}
.step-photos-carousel .carousel-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: rgba(255,255,255,0.5);
  cursor: pointer;
  transition: all 0.2s;
}
.step-photos-carousel .carousel-dot.active {
  background: #fff;
  transform: scale(1.2);
}
.step-photos-carousel .carousel-counter {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 4px 10px;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 600;
  z-index: 2;
}
.step-photos-carousel .no-photo {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #94a3b8;
  font-size: 0.9rem;
}

</style>

<!-- ⬇️ AJOUTER AVANT </head> -->
<script src="/js/ort-config.js"></script>
<script src="/js/ort-tripid.js"></script>
<script src="/js/ort-i18n.js"></script>
<script src="/js/ort-trip-data.js"></script>
<script>
// === Fallback i18n si ort-i18n.js non chargé ===
if (typeof t !== 'function') {
  const ORT_I18N_FALLBACK = {
    dashboard: { fr: 'Tableau de bord', en: 'Dashboard', es: 'Panel', it: 'Cruscotto', pt: 'Painel', ar: 'لوحة القيادة' },
    startDate: { fr: 'Date de départ', en: 'Start date', es: 'Fecha de salida', it: 'Data di partenza', pt: 'Data de partida', ar: 'تاريخ المغادرة' },
    tools: { fr: 'Outils', en: 'Tools', es: 'Herramientas', it: 'Strumenti', pt: 'Ferramentas', ar: 'أدوات' },
    generatePdf: { fr: 'Générer PDF', en: 'Generate PDF', es: 'Generar PDF', it: 'Genera PDF', pt: 'Gerar PDF', ar: 'إنشاء PDF' },
    bookFlight: { fr: 'Réserver un vol', en: 'Book a flight', es: 'Reservar vuelo', it: 'Prenota volo', pt: 'Reservar voo', ar: 'حجز رحلة' },
    bookCar: { fr: 'Louer une voiture', en: 'Rent a car', es: 'Alquilar coche', it: 'Noleggia auto', pt: 'Alugar carro', ar: 'استئجار سيارة' },
    bookInsurance: { fr: 'Assurance voyage', en: 'Travel insurance', es: 'Seguro de viaje', it: 'Assicurazione viaggio', pt: 'Seguro viagem', ar: 'تأمين السفر' },
    countrySheet: { fr: 'Fiche pays', en: 'Country sheet', es: 'Ficha país', it: 'Scheda paese', pt: 'Ficha país', ar: 'بطاقة البلد' },
    userPhotosResas: { fr: '📷 Photos et résas', en: '📷 Photos & bookings', es: '📷 Fotos y reservas', it: '📷 Foto e prenotazioni', pt: '📷 Fotos e reservas', ar: '📷 الصور والحجوزات' },
    userPhotosResasTooltip: { fr: 'Insérez vos propres photos et vos réservations', en: 'Add your own photos and bookings', es: 'Añade tus propias fotos y reservas', it: 'Inserisci le tue foto e prenotazioni', pt: 'Adicione suas próprias fotos e reservas', ar: 'أضف صورك وحجوزاتك الخاصة' },
    customize: { fr: '✨ Personnaliser', en: '✨ Customize', es: '✨ Personalizar', it: '✨ Personalizza', pt: '✨ Personalizar', ar: '✨ تخصيص' },
    customizeTooltip: { fr: 'Photos, réservations et documents', en: 'Photos, bookings and documents', es: 'Fotos, reservas y documentos', it: 'Foto, prenotazioni e documenti', pt: 'Fotos, reservas e documentos', ar: 'الصور والحجوزات والوثائق' },
    menuMyPhotos: { fr: '📷 Intégrer mes photos', en: '📷 Add my photos', es: '📷 Añadir mis fotos', it: '📷 Aggiungi le mie foto', pt: '📷 Adicionar minhas fotos', ar: '📷 إضافة صوري' },
    menuImportBooking: { fr: '➕ Importer une réservation', en: '➕ Import a booking', es: '➕ Importar una reserva', it: '➕ Importa una prenotazione', pt: '➕ Importar uma reserva', ar: '➕ استيراد حجز' },
    menuViewBookings: { fr: '📋 Voir mes réservations', en: '📋 View my bookings', es: '📋 Ver mis reservas', it: '📋 Vedi le mie prenotazioni', pt: '📋 Ver minhas reservas', ar: '📋 عرض حجوزاتي' },
    budget: { fr: 'Budget', en: 'Budget', es: 'Presupuesto', it: 'Budget', pt: 'Orçamento', ar: 'الميزانية' },
    budgetTooltip: { fr: 'Cliquez pour voir le détail', en: 'Click to see details', es: 'Haga clic para ver los detalles', it: 'Clicca per vedere i dettagli', pt: 'Clique para ver detalhes', ar: 'انقر لرؤية التفاصيل' },
    budgetTotal: { fr: 'Budget total', en: 'Total budget', es: 'Presupuesto total', it: 'Budget totale', pt: 'Orçamento total', ar: 'الميزانية الإجمالية' },
    budgetByCategory: { fr: 'Par catégorie', en: 'By category', es: 'Por categoría', it: 'Per categoria', pt: 'Por categoria', ar: 'حسب الفئة' },
    budgetTransport: { fr: 'Transport', en: 'Transport', es: 'Transporte', it: 'Trasporto', pt: 'Transporte', ar: 'النقل' },
    budgetAccommodation: { fr: 'Hébergement', en: 'Accommodation', es: 'Alojamiento', it: 'Alloggio', pt: 'Hospedagem', ar: 'الإقامة' },
    budgetActivities: { fr: 'Activités', en: 'Activities', es: 'Actividades', it: 'Attività', pt: 'Atividades', ar: 'الأنشطة' },
    budgetOther: { fr: 'Autres', en: 'Other', es: 'Otros', it: 'Altro', pt: 'Outros', ar: 'أخرى' },
    addManualItem: { fr: '➕ Ajouter une dépense', en: '➕ Add expense', es: '➕ Añadir gasto', it: '➕ Aggiungi spesa', pt: '➕ Adicionar despesa', ar: '➕ إضافة نفقة' },
    noBudget: { fr: 'Aucune réservation', en: 'No bookings', es: 'Sin reservas', it: 'Nessuna prenotazione', pt: 'Sem reservas', ar: 'لا توجد حجوزات' },
    flights: { fr: 'Vols', en: 'Flights', es: 'Vuelos', it: 'Voli', pt: 'Voos', ar: 'الرحلات' },
    carRental: { fr: 'Location voiture', en: 'Car rental', es: 'Alquiler de coche', it: 'Noleggio auto', pt: 'Aluguel de carro', ar: 'تأجير سيارات' },
    transfers: { fr: 'Transferts', en: 'Transfers', es: 'Traslados', it: 'Trasferimenti', pt: 'Transferências', ar: 'التحويلات' },
    insurance: { fr: 'Assurance', en: 'Insurance', es: 'Seguro', it: 'Assicurazione', pt: 'Seguro', ar: 'التأمين' },
    delayCompensation: { fr: 'Compensation retard', en: 'Delay compensation', es: 'Compensación por retraso', it: 'Compensazione ritardo', pt: 'Compensação por atraso', ar: 'تعويض التأخير' }
  };
  const _lang = (new URLSearchParams(location.search).get('lang') || localStorage.getItem('lang') || 'fr').slice(0, 2);
  window.t = function(key) {
    const entry = ORT_I18N_FALLBACK[key];
    return entry ? (entry[_lang] || entry.fr || key) : key;
  };
}
</script>
<script>
// === Firebase config (préprod / prod) — via ORT_CONFIG ===
(function(){
  const host = location.hostname;
  const isPreprod = /oneroadtrip-preprod|localhost|127\.0\.0\.1|0\.0\.0\.0/.test(host);
  const cfg  = isPreprod ? (window.ORT_CONFIG?.PREPROD || {}) : (window.ORT_CONFIG?.PROD || {});
  const safe = (cfg && cfg.apiKey) ? cfg : (window.ORT_CONFIG?.PREPROD || {});
  window.__FIREBASE_CONFIG__ = safe;
})();
</script>

<!-- Stay22 Integration -->
<script>
  (function (s, t, a, y, twenty, two) {
    s.Stay22 = s.Stay22 || {};
    s.Stay22.params = { lmaID: '692f0c75b2478d16bb9b22fa' };
    twenty = t.createElement(a);
    two = t.getElementsByTagName(a)[0];
    twenty.async = 1;
    twenty.src = y;
    two.parentNode.insertBefore(twenty, two);
  })(window, document, 'script', 'https://scripts.stay22.com/letmeallez.js');
</script>

<!-- Module réservations -->
<script src="bookings-module.js"></script>
<style id="bookings-modal-styles"></style>

</head>
<body>


<header>
    <a class="brandlink" id="homeLink" href="#">
    <img src="../assets/symbol.webp" alt="Logo"><div class="brand">OneRoadTrip</div>
  </a>
  <div class="spacer"></div>

  <!-- Bouton Outils seul dans le header (le popup sera positionné via JS) -->
  <button id="toolsBtn" class="btn ghost" type="button" title="Outils" style="display:none;">🔧 Outils</button>

  <!-- Popup Outils (sera repositionné dynamiquement) -->
  <div id="toolsPop" class="tools-pop" role="menu" aria-hidden="true">
    <div class="tools-pop-title">
      🔧 <span data-i18n="tools">Outils</span>
      <button id="toolsCloseBtn" type="button" style="float:right;background:none;border:none;color:#fff;font-size:20px;cursor:pointer;padding:0;margin:-4px 0 0 0;">✕</button>
    </div>
    
    <div class="tools-section-title" data-i18n="steps">Étapes</div>
    <button class="tools-item" id="btnAddStep" type="button">
      ➕ <span data-i18n="addStep">Ajouter une étape</span>
    </button>
    <button class="tools-item" id="btnAddMapStep" type="button">
      📍 <span data-i18n="addOnMap">Ajouter sur la carte</span>
    </button>
    <button class="tools-item" id="btnEditMapRoute" type="button">
      🗺️ <span data-i18n="editMapRoute">Modifier l'itinéraire sur la carte</span>
    </button>
    <button class="tools-item" id="btnShowOtherPlaces" type="button">
      📌 <span data-i18n="suggestOtherPlaces">Proposer d'autres lieux</span>
    </button>
    <button class="tools-item" id="centerRouteBtn" type="button">
      🎯 <span data-i18n="centerOnRoute">Centrer sur le trajet</span>
    </button>
    
    <div class="tools-separator"></div>
    <div class="tools-section-title" data-i18n="display">Affichage</div>
    
    <div class="tools-item tools-layout">
      <span data-i18n="layout">Disposition</span>:
      <button id="layoutSideBtn" class="layout-btn active" type="button" data-i18n-title="horizontal" title="Horizontal">⟷</button>
      <button id="layoutStackBtn" class="layout-btn" type="button" data-i18n-title="vertical" title="Vertical">↕</button>
    </div>
    
    <div class="tools-separator"></div>
    <div class="tools-section-title" data-i18n="information">Informations</div>
    
    <button class="tools-item" id="btnToolsCountry" type="button">
      🌍 <span data-i18n="countrySheet">Fiche pays</span>
    </button>
    <button class="tools-item" id="btnToolsReport" type="button">
      ❗ <span data-i18n="reportError">Signaler une erreur</span>
    </button>
    <button class="tools-item" id="btnToolsRate" type="button">
      ⭐ <span data-i18n="rateTrip">Noter ce road trip</span>
    </button>
    <button class="tools-item" id="btnShareTrip" type="button">
      🔗 <span data-i18n="shareTrip">Partager ce voyage</span>
    </button>
    
    <!-- SUPPRIMÉ: km/mi, modes transport, gestion nuits/groupes, hébergements -->
    <!-- Gardés en commentaire pour réactivation future si besoin
    <button class="tools-item" id="unitToggle" type="button">📏 Unité: km</button>
    <button class="tools-item" id="modeToggle" type="button">🚆 Mode: Auto ▼</button>
    <button class="tools-item" id="btnRecalcNights" type="button">🔢 Recalculer les nuits</button>
    <button class="tools-item" id="btnResetGroups" type="button">✖ Annuler les groupes</button>
    <button class="tools-item" id="btnStay22Map" type="button">🗺️ Carte hébergements</button>
    -->
    <button class="tools-item" id="btnSaveSourceTools" type="button" style="display:none;background:#dc2626;color:#fff;">
      🔴 Écrire source (admin)
    </button>
    <button class="tools-item" id="btnOpenItinTools" type="button" style="display:none;background:#2563eb;color:#fff;">
      🔓 Ouvrir un itin (admin)
    </button>
  </div>

  <!-- Sélecteur de langue dans le header -->
  <select id="langSel" class="langpick" aria-label="Langue">
    <option value="fr">Français</option>
    <option value="en">English</option>
    <option value="it">Italiano</option>
    <option value="es">Español</option>
    <option value="pt">Português</option>
    <option value="ar">العربية</option>
  </select>

  <div class="auth">
    <button id="openAuth" class="btn" type="button" data-i18n="signIn">Se connecter</button>
    <div id="authPop" class="auth-pop" role="dialog" aria-label="Connexion">
      <button id="btnGoogle" class="btn" type="button">Google</button>
      <button id="btnEmail" class="btn" type="button">E-mail</button>
      <button id="btnLogout" class="btn out" type="button" style="display:none" data-i18n="signOut">Déconnexion</button>
    </div>
  </div>

<script>
!function(){
  try{
    // 1) Cible le <header> et le rend wrap pour autoriser une 2e ligne
    var hdr = document.querySelector('header'); if(!hdr) return;
    hdr.style.display = (getComputedStyle(hdr).display==='flex' ? 'flex' : hdr.style.display || 'flex');
    hdr.style.flexWrap = 'wrap';

    // 2) Évite les doublons si déjà injecté
    if(document.getElementById('ortDashRow')) return;

    // 3) Prépare i18n pour le pop-up
    var lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').toLowerCase();
    var MSG = ({
      fr:'Vous devez être enregistré pour accéder au Dashboard.',
      en:'You must be signed in to access the Dashboard.',
      it:'Devi essere registrato per accedere alla Dashboard.',
      es:'Debe estar registrado para accedere al Panel.',
      pt:'Você precisa estar conectado para acessar o Dashboard.',
      ar:'يجب أن تكون مسجّلًا للوصول إلى لوحة التحكم.'
    })[lang] || 'Vous devez être enregistré pour accéder au Dashboard.';

    // 4) Crée UNE NOUVELLE LIGNE PLEINE LARGEUR sous la 1re ligne du header
var row = document.createElement('div');
row.id = 'ortDashRow';
row.style.flexBasis = '100%';
row.style.display = 'flex';
row.style.justifyContent = 'center';
row.style.alignItems = 'center';
row.style.marginTop = '-15px';   // ↓ remonte le Dashboard
row.style.marginBottom = '0';   // ↓ supprime l’espace dessous

    // 5) Le bouton "Dashboard" (centré, même style header)
    var a = document.createElement('a');
    a.href = 'dashboard_user.html?lang=' + lang;
    a.innerHTML = t('dashboard');
    a.className = 'hdr-btn';
    // renforts visuels au cas où hdr-btn n’existe pas partout
    a.style.textDecoration = 'none';
    a.style.whiteSpace = 'nowrap';
    a.style.padding = a.style.padding || '6px 12px';
    a.style.borderRadius = a.style.borderRadius || '10px';

    // 6) Si non connecté, bloque et affiche un pop-up i18n
    a.addEventListener('click', function(ev){
      var user = (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) || null;
      if(!user){var row = document.createElement('div');
        ev.preventDefault();
        var box = document.createElement('div');
        Object.assign(box.style, {
          position:'fixed', left:'50%', top:'18px', transform:'translateX(-50%)',
          background:'#fff', color:'#113f7a',
          padding:'10px 14px', borderRadius:'10px',
          border:'1px solid #c3d6b6', boxShadow:'0 6px 18px rgba(0,0,0,.15)',
          zIndex:9999, maxWidth:'90%', fontFamily:'system-ui,Segoe UI,Roboto,Arial,sans-serif'
        });
        box.textContent = MSG;
        document.body.appendChild(box);
        setTimeout(function(){ box.remove(); }, 2400);
      }
    });

    row.appendChild(a);

    var d = document.getElementById('rtStartDate');
if(!d){
  d = document.createElement('input');
  d.type = 'date';
  d.id   = 'rtStartDate';
  // Ajouter la langue du document pour forcer le calendrier natif à l'utiliser
  const lang = (document.documentElement.lang || 'fr').slice(0, 2);
  d.lang = lang;
  // Priorité: URL departure > localStorage
  const urlDeparture = new URLSearchParams(location.search).get('departure') || '';
  d.value = urlDeparture || localStorage.getItem('ort.rtStartDate') || '';
  Object.assign(d.style, {
    padding:'6px 10px', borderRadius:'10px',
    border:'1px solid #c3d6b6', color:'#113f7a'
  });
  // i18n titre 6 langues
  d.title = t('startDate');
}
// écouteurs (saisie immédiate + validation)
function onDateChange(){
  localStorage.setItem('ort.rtStartDate', d.value || '');
  if (window.state){ state.startDateStr = d.value || ''; renderRows(); }
}
d.addEventListener('input',  onDateChange);
// Helpers notation (clé par itinéraire)
function rtKeyForRating(){
  const qs = new URLSearchParams(location.search);
  return decodeURIComponent(qs.get('itin') || qs.get('rtKey') || 'RT');
}
function loadRatings(){
  try{ return JSON.parse(localStorage.getItem('ort.rtRatings::'+rtKeyForRating())||'[]'); }catch(_){ return []; }
}
function saveRatings(arr){
  try{ localStorage.setItem('ort.rtRatings::'+rtKeyForRating(), JSON.stringify(arr)); }catch(_){}
}
function myRatingGet(){ try{ return JSON.parse(localStorage.getItem('ort.myRtRating::'+rtKeyForRating())||'null'); }catch(_){ return null; } }
function myRatingSet(obj){ try{ localStorage.setItem('ort.myRtRating::'+rtKeyForRating(), JSON.stringify(obj||null)); }catch(_){ } }
function avg(arr){ if(!arr.length) return null; const s=arr.reduce((a,x)=>a+Number(x.score||0),0); return Math.round((s/arr.length)*10)/10; }
function noteClass(v){ if(v==null) return ''; if(v<4) return 'note-bad'; if(v<7) return 'note-mid'; return 'note-good'; }

// I18N tooltips
// I18N tooltips
const LANG = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
const TIP_SAVE = ({fr:'Sauvegarder ce road trip',en:'Save this road trip',it:'Salva questo road trip',es:'Guardar este road trip',pt:'Guardar este road trip',ar:'حفظ هذه الرحلة'})[LANG] || 'Save';
const TIP_FLAG = ({
  fr:'Signaler un RT ou une erreur',
  en:'Report a trip or an error',
  it:'Segnala un viaggio o un errore',
  es:'Informar de un viaje o un error',
  pt:'Reportar uma viagem ou um erro',
  ar:'الإبلاغ عن رحلة أو خطأ'
})[LANG] || 'Report';
const TIP_RATE = ({fr:'Noter ce road trip',en:'Rate this road trip',it:'Valuta questo road trip',es:'Valorar este road trip',pt:'Avaliar este road trip',ar:'قيّم هذه الرحلة'})[LANG] || 'Rate';
// TIP_COUNTRY supprimé - fiche pays dans menu Outils
// const TIP_COUNTRY = t('countrySheet');

// === INITIALISATION SYSTÈME DE RÉSERVATIONS ===
if (typeof initBookingManager === 'function') {
  initBookingManager(LANG);
  const styleEl = document.getElementById('bookings-modal-styles');
  if (styleEl) {
    styleEl.textContent = BOOKINGS_CSS;
  }
  console.log('[BOOKINGS] ✅ Initialisé avec langue:', LANG);
  
  // === RAPATRIER LES RÉSERVATIONS ===
  
  // Écouter les événements de réservations depuis ort-ai-parser.js
  window.addEventListener('ort:booking-added', (event) => {
    const booking = event.detail;
    if (!booking) return;
    
    // Récupérer le stepId
    const stepId = booking._stepId;
    let stepIdx = 0;
    
    if (stepId === 'travel') {
      // Réservation globale du voyage
      stepIdx = 0;
    } else if (stepId && stepId.startsWith('day_')) {
      // Réservation spécifique à un jour
      const dayNum = parseInt(stepId.replace('day_', '')) - 1;
      
      // Trouver l'étape qui contient ce jour
      let currentDay = 1;
      if (state.steps) {
        for (let i = 0; i < state.steps.length; i++) {
          const nights = state.steps[i].nights || 1;
          if (dayNum >= currentDay - 1 && dayNum < currentDay + nights - 1) {
            stepIdx = i;
            break;
          }
          currentDay += nights;
        }
      }
    }
    
    // Normaliser la réservation au format du module
    const normalized = {
      id: booking.id || `b_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      type: booking.type,
      category: booking.category || 'other',
      name: booking.name,
      confirmationNumber: booking.confirmation_number,
      checkin: booking.date_start,
      checkout: booking.date_end,
      departure: booking.date_start,
      arrival: booking.date_end,
      date: booking.date_start || booking.date_end,
      price: booking.price?.amount,
      currency: booking.price?.currency,
      address: booking.provider,
      city: booking.city,
      guests: booking.guests,
      notes: booking.notes
    };
    
    // Ajouter au gestionnaire
    if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
      globalBookingManager.addBooking(stepIdx, normalized);
      console.log('[BOOKINGS] ✅ Réservation ajoutée à l\'étape', stepIdx, ':', booking.name);
      
      // Rafraîchir l'affichage si existant
      if (typeof renderRows === 'function') {
        renderRows();
      }
    }
  });
  
  console.log('[BOOKINGS] 🔔 Écoute active pour ort:booking-added');
  
  // === Persistance localStorage pour les RT temporaires ===
  window.addEventListener('beforeunload', () => {
    const tripId = localStorage.getItem('ORT_CURRENT_TRIP_ID');
    if (tripId && tripId.startsWith('temp_') && window.state) {
      // Ajouter les bookings au state avant de sauvegarder
      if (typeof globalBookingManager !== 'undefined' && globalBookingManager.bookings) {
        window.state.bookings = globalBookingManager.bookings;
        console.log('[BOOKINGS] 📦 Bookings ajoutés au state:', Object.keys(window.state.bookings).length, 'étapes');
      }
      localStorage.setItem(`ORT_TEMP_STATE_${tripId}`, JSON.stringify(window.state));
      console.log('[BOOKINGS] 💾 État temporaire sauvegardé au beforeunload');
    }
  });
}

// === FONCTION DE DÉTECTION CATÉGORIE RÉSERVATION ===
function detectBookingCategory(booking) {
  const type = (booking.type || booking['@type'] || '').toLowerCase();
  if (type.includes('lodging') || type.includes('hotel')) return 'lodging';
  if (type.includes('flight')) return 'flight';
  if (type.includes('car') || type.includes('rental')) return 'car';
  if (type.includes('train')) return 'train';
  if (type.includes('restaurant')) return 'restaurant';
  if (type.includes('activity')) return 'activity';
  return 'other';
}
const L_DONE = ({fr:'Avez-vous fait ce RT ?',en:'Have you done this road trip?',it:'Hai fatto questo road trip?',es:'¿Ha hecho este road trip?',pt:'Fez este road trip?',ar:'هل قمت بهذه الرحلة؟'})[LANG] || 'Done?';
const L_YES = ({fr:'Oui',en:'Yes',it:'Sì',es:'Sí',pt:'Sim',ar:'نعم'})[LANG] || 'Yes';
const L_NO  = ({fr:'Non',en:'No', it:'No', es:'No', pt:'Não', ar:'لا'})[LANG] || 'No';
const L_SCORE = ({fr:'Note (1 à 10)',en:'Score (1 to 10)',it:'Voto (1–10)',es:'Nota (1–10)',pt:'Nota (1–10)',ar:'تقييم (1–10)'} )[LANG] || 'Score';
const L_SAVE = ({fr:'Enregistrer',en:'Save',it:'Salva',es:'Guardar',pt:'Guardar',ar:'حفظ'})[LANG] || 'Save';
const L_YOUR = ({fr:"Votre note",en:"Your score",it:"Tuo voto",es:"Tu nota",pt:"Sua nota",ar:"تقييمك"})[LANG] || 'Your score';
const L_AVG  = ({fr:"Moy.",en:"Avg.",it:"Media",es:"Media",pt:"Média",ar:"المتوسط"})[LANG] || 'Avg.';
const L_COMMENT = ({
  fr:'Commentaire (facultatif)',
  en:'Comment (optional)',
  it:'Commento (facoltativo)',
  es:'Comentario (opcional)',
  pt:'Comentário (opcional)',
  ar:'تعليق (اختياري)'
})[LANG] || 'Comment (optional)';

const L_PLACEHOLDER = ({
  fr:'Ajoutez un retour utile pour les autres voyageurs…',
  en:'Add feedback that helps other travelers…',
  it:'Aggiungi un feedback utile per altri viaggiatori…',
  es:'Añade comentarios útiles para otros viajeros…',
  pt:'Adicione um feedback útil para outros viajantes…',
  ar:'أضف ملاحظات مفيدة للمسافرين الآخرين…'
})[LANG] || 'Add feedback that helps other travelers…';

const L_SENT_OK = ({
  fr:'✅ Merci ! Votre note a été prise en compte.',
  en:'✅ Thanks! Your rating was recorded.',
  it:'✅ Grazie! La tua valutazione è stata registrata.',
  es:'✅ ¡Gracias! Tu valoración se ha registrado.',
  pt:'✅ Obrigado! Sua avaliação foi registrada.',
  ar:'✅ شكرًا! تم تسجيل تقييمك.'
})[LANG] || '✅ Thanks! Your rating was recorded.';
d.addEventListener('change', onDateChange);

// == Icônes à GAUCHE de la date (sans décaler la date) ==
let icoWrap = document.getElementById('rtInlineIcons');
if(!icoWrap){
  icoWrap = document.createElement('div');
  icoWrap.id = 'rtInlineIcons';
  icoWrap.className = 'rt-inline-icons';
  // boutons
  const bSave = document.createElement('button');
  bSave.type='button'; bSave.className='pill-ico'; bSave.title=TIP_SAVE; bSave.setAttribute('aria-label',TIP_SAVE); bSave.textContent='💾';
   const bFlag = document.createElement('button');
  bFlag.type='button'; bFlag.className='pill-ico danger'; bFlag.title=TIP_FLAG; bFlag.setAttribute('aria-label',TIP_FLAG); bFlag.textContent='❗';
  const bRate = document.createElement('button');
  bRate.type='button'; bRate.className='pill-ico'; bRate.title=TIP_RATE; bRate.setAttribute('aria-label',TIP_RATE);
  bRate.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">'
                  +   '<circle cx="12" cy="12" r="10" fill="#fff" stroke="#ff4040" stroke-width="2"></circle>'
                  +   '<text x="12" y="16" text-anchor="middle" font-size="12" font-family="Arial" font-weight="700" fill="#ff4040">10</text>'
                  + '</svg>';
  
  // Bouton Fiche pays déplacé dans menu Outils
  // const bCountry = document.createElement('button');
  // bCountry.type='button'; bCountry.className='pill-ico'; bCountry.id='countryTabInline';
  // bCountry.title=TIP_COUNTRY; bCountry.setAttribute('aria-label',TIP_COUNTRY); bCountry.textContent='🌍';

  // Badge moyenne
  const avgBadge = document.createElement('span');

  avgBadge.id='rtAvgBadge';

  // état saved visuel si déjà dans ORTSaves (heuristique locale)
  try{
    const u=currentUser(); if(u){
      const arr = ORTSaves.load(u.uid);
      const here = (arr||[]).some(x=>x?.detailUrl===location.href || x?.id===ensureRid());
      if(here) bSave.classList.add('saved');
    }
  }catch(_){}

  // actions
  // actions
  bSave.addEventListener('click', ()=>{ document.getElementById('btnSave')?.click(); bSave.classList.add('saved'); });

  // ❗ Alerter → boîte de dialogue + envoi silencieux
  bFlag.addEventListener('click', ()=>{
    const title = TIP_FLAG; // I18N déjà mis à jour plus haut
    const note = prompt(title + '\n\nÉcrivez votre message libre :');
    if(!note || !note.trim()) return;

    const payload = {
      subject: '[ORT] Signalement — Roadtrip',
      message:
        `URL: ${location.href}\nLang: ${LANG}\nUser: ${(currentUser()?.email||'guest')}\n\n` +
        `Note:\n${note.trim()}`
    };

    fetch('https://formsubmit.co/ajax/contact@oneroadtrip.com', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(payload)
    })
    .then(r => { console.log('[Signalement ORT]', r.status); toast('✅ Signalement envoyé'); })
    .catch(e => { console.warn('Erreur signalement ORT', e); toast('❌ Envoi impossible'); });
  });

  // popover Notation (+ commentaire + e-mail + stockage)
  function openRatePopover(anchor){
    // cleanup existant
    document.querySelectorAll('.rate-pop').forEach(x=>x.remove());
    const pop=document.createElement('div'); pop.className='rate-pop';

    const mine = myRatingGet() || { done:false, score:7, comment:'' };
    pop.innerHTML = `
      <div class="row"><strong>${L_DONE}</strong>
        <span>
          <label><input type="radio" name="rtDone" value="1" ${mine.done?'checked':''}> ${L_YES}</label>
          <label style="margin-left:10px"><input type="radio" name="rtDone" value="0" ${!mine.done?'checked':''}> ${L_NO}</label>
        </span>
      </div>
      <div class="row">
        <label for="rtScore"><strong>${L_SCORE}</strong></label>
        <input id="rtScore" type="range" min="1" max="10" step="1" value="${mine.score||7}" style="width:160px">
        <span id="rtScoreLbl">${mine.score||7}/10</span>
      </div>

      <div class="row" style="align-items:flex-start">
        <label for="rtComment" style="margin-right:8px"><strong>🖊 ${L_COMMENT}</strong></label>
      </div>
      <div class="row" style="display:block">
        <textarea id="rtComment" rows="3" placeholder="${L_PLACEHOLDER}"
          style="width:100%;padding:8px;border:1px solid #cfd6e4;border-radius:8px;resize:vertical">${mine.comment?String(mine.comment).replace(/</g,'&lt;'):''}</textarea>
      </div>

      <div class="mut" id="rtAvgLine" style="margin:6px 0"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px">
        <button class="btn ghost" data-act="cancel" type="button">✕</button>
        <button class="btn" data-act="save" type="button">${L_SAVE}</button>
      </div>
    `;
    document.body.appendChild(pop);
    // positionnement
    const r=anchor.getBoundingClientRect();
    pop.style.left = Math.min(window.innerWidth- pop.offsetWidth-12, Math.max(12, r.left + window.scrollX - 6))+'px';
    pop.style.top  = (r.bottom + window.scrollY + 8)+'px';

    // interactions
    const score   = pop.querySelector('#rtScore');
    const lbl     = pop.querySelector('#rtScoreLbl');
    const avgLine = pop.querySelector('#rtAvgLine');
    const comment = pop.querySelector('#rtComment');

    function refreshAvgLine(){
      const arr=loadRatings(); const A=avg(arr);
      const mineVal = Number(score.value||7);
      const cls = noteClass(mineVal);
      const avgTxt = (A==null)?'—':`${A}/10`;
      avgLine.innerHTML = `<strong>${L_YOUR}:</strong> <span class="${cls}">${mineVal}/10</span>  ·  <strong>${L_AVG}:</strong> ${avgTxt}`;
      // badge
      const badge = document.getElementById('rtAvgBadge');
      if(badge){ 
        if(A!=null){ badge.style.display='inline-flex'; badge.innerHTML=`⭐ ${A}/10`; } 
        else { badge.style.display='none'; }
      }
    }
    score.addEventListener('input', ()=>{ lbl.textContent = `${score.value}/10`; refreshAvgLine(); });
    refreshAvgLine();

    pop.addEventListener('click', async (e)=>{
      const act=e.target?.dataset?.act;
      if(act==='cancel'){ pop.remove(); }
      if(act==='save'){
        const done = pop.querySelector('input[name="rtDone"]:checked')?.value==='1';
        const sc   = Number(score.value||7);
        const cmt  = (comment?.value||'').trim();

        // 1) MAJ mon vote (incl. commentaire)
        const mineNow = { done, score: sc, comment: cmt, ts: Date.now() };
        myRatingSet(mineNow);

        // 2) MAJ pool local (1 vote par navigateur → index 0)
        const arr=loadRatings();
        if(!arr.length){ arr.push(mineNow); } else { arr[0]=mineNow; }
        saveRatings(arr);

        // 3) Envoi e-mail silencieux
        try{
          const rtKey = (new URLSearchParams(location.search).get('itin')||new URLSearchParams(location.search).get('rtKey')||'RT');
          const user  = (currentUser()?.email || 'guest');
          const payload = {
            subject: '[ORT] Nouvelle note de roadtrip',
            message:
              `URL: ${location.href}\nLang: ${ (localStorage.getItem('lang') || document.documentElement.lang || 'fr') }\n` +
              `User: ${user}\nRT: ${rtKey}\nDone: ${done}\nScore: ${sc}/10\nComment:\n${cmt||'(vide)'}\n` +
              `When: ${new Date().toISOString()}`
          };
          fetch('https://formsubmit.co/ajax/contact@oneroadtrip.com', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          }).then(r=>console.log('[Rating mail]', r.status)).catch(()=>{});
        }catch(_){}

        // 4) Push optionnel vers API (si dispo)
        try{
          const FEED_API = (localStorage.ORT_FEEDBACK_API || '').replace(/\/+$/,'');
          if(FEED_API){
            const qs = new URLSearchParams(location.search);
            const body = {
              itin: decodeURIComponent(qs.get('itin')||''),
              cc:   (qs.get('cc')||'').toUpperCase(),
              score: sc,
              done,
              comment: cmt,
              url: location.href,
              user: (currentUser()?.email || null),
              ts: Date.now()
            };
            fetch(`${FEED_API}/ratings`, {
              method:'POST',
              headers:{'Content-Type':'application/json'},
              body: JSON.stringify(body)
            }).catch(()=>{});
          }
        }catch(_){}

        refreshAvgLine();
        pop.remove();
        toast(L_SENT_OK);
      }
    });

    document.addEventListener('click', function onDoc(e){
      if(!pop.contains(e.target) && e.target!==anchor){ pop.remove(); document.removeEventListener('click', onDoc); }
    }, {capture:true});
  }
  // Exposer globalement pour le menu Outils
  window.openRatePopover = openRatePopover;
  
  bRate.addEventListener('click', (e)=>{ e.stopPropagation(); openRatePopover(bRate); });
  
  // Handler Fiche pays - déplacé dans menu Outils
  // bCountry.addEventListener('click', ()=>{
  //   const drawer = document.getElementById('countryDrawer');
  //   if(drawer) drawer.classList.toggle('open');
  // });

  // Icônes déplacées dans le menu Outils - on garde bSave + avgBadge
  icoWrap.appendChild(bSave);  // 💾 Sauvegarder visible
  // icoWrap.appendChild(bCountry);
  // icoWrap.appendChild(bFlag);
  // icoWrap.appendChild(bRate);
  icoWrap.appendChild(avgBadge);
  // on n'accroche pas ici : on le fera après avoir inséré 'd' dans 'row'
}

// insérer la date AVANT le bouton Dashboard
row.insertBefore(d, a);

// puis placer les icônes à GAUCHE de la date
row.insertBefore(icoWrap, d);

// === Bouton Outils à côté du Dashboard ===
const toolsBtnRow = document.createElement('button');
toolsBtnRow.id = 'toolsBtnRow';
toolsBtnRow.type = 'button';
toolsBtnRow.className = 'hdr-btn';
toolsBtnRow.textContent = '🔧 ' + t('tools');
toolsBtnRow.title = t('tools');
Object.assign(toolsBtnRow.style, {
  marginLeft: '12px',
  padding: '6px 14px',
  borderRadius: '10px',
  background: '#fff',
  color: '#113f7a',
  border: '1px solid #c3d6b6',
  cursor: 'pointer',
  fontWeight: '600',
  fontSize: '14px'
});

// Handler pour ouvrir le popup
toolsBtnRow.addEventListener('click', function(e){
  e.stopPropagation();
  const pop = document.getElementById('toolsPop');
  if(!pop) return;
  const isOpen = pop.classList.contains('show');
  pop.classList.toggle('show', !isOpen);
  
  // Positionner le popup sous le bouton
  if(!isOpen){
    const rect = toolsBtnRow.getBoundingClientRect();
    pop.style.position = 'fixed';
    pop.style.top = (rect.bottom + 8) + 'px';
    pop.style.left = Math.max(10, rect.left - 100) + 'px';
    pop.style.right = 'auto';
  }
});

// puis terminer comme avant
row.appendChild(a);
row.appendChild(toolsBtnRow);

// === Bouton PDF dans le header ===
const pdfBtnRow = document.createElement('button');
pdfBtnRow.id = 'btnExportPDFHeader';
pdfBtnRow.type = 'button';
pdfBtnRow.className = 'hdr-btn';
pdfBtnRow.textContent = '📄 Carnet';
pdfBtnRow.title = t('generatePdf');
Object.assign(pdfBtnRow.style, {
  marginLeft: '8px',
  padding: '6px 14px',
  borderRadius: '10px',
  background: '#fff',
  color: '#113f7a',
  border: '1px solid #c3d6b6',
  cursor: 'pointer',
  fontWeight: '600',
  fontSize: '14px'
});
pdfBtnRow.addEventListener('click', () => {
  if (window.ORT_PDF && window.state) {
    const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
    ORT_PDF.export(state, lang);
  } else {
    alert('Module PDF non chargé ou state non disponible');
  }
});
row.appendChild(pdfBtnRow);

// === Menu Personnaliser (Photos, Résas, Documents) ===
const customizeWrap = document.createElement('div');
customizeWrap.className = 'customize-dropdown';
customizeWrap.style.cssText = 'position:relative;display:inline-block;margin-left:6px;';

const customizeBtn = document.createElement('button');
customizeBtn.id = 'btnCustomize';
customizeBtn.type = 'button';
customizeBtn.className = 'hdr-btn';
customizeBtn.textContent = t('customize');
customizeBtn.title = t('customizeTooltip');
Object.assign(customizeBtn.style, {
  background: '#fff',
  color: '#113f7a',
  border: '1px solid #113f7a',
  cursor: 'pointer'
});

const customizeMenu = document.createElement('div');
customizeMenu.className = 'customize-menu';
customizeMenu.style.cssText = `
  display:none;position:absolute;top:100%;right:0;margin-top:4px;
  background:#fff;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.15);
  min-width:220px;z-index:1000;overflow:hidden;border:1px solid #e5e7eb;
`;

const menuItems = [
  { key: 'menuMyPhotos', page: 'rt-photos.html', icon: '📷' },
  { key: 'menuImportBooking', page: 'rt-booking-import.html', icon: '➕' },
  { key: 'menuViewBookings', page: 'rt-bookings.html', icon: '📋' }
];

menuItems.forEach((item, idx) => {
  const menuItem = document.createElement('div');
  menuItem.className = 'customize-menu-item';
  menuItem.textContent = t(item.key);
  menuItem.style.cssText = `
    padding:12px 16px;cursor:pointer;font-weight:500;color:#113f7a;
    border-bottom:${idx < menuItems.length - 1 ? '1px solid #f1f5f9' : 'none'};
    transition:background 0.15s;
  `;
  menuItem.addEventListener('mouseenter', () => menuItem.style.background = '#f8fafc');
  menuItem.addEventListener('mouseleave', () => menuItem.style.background = '#fff');
  menuItem.addEventListener('click', () => {
    customizeMenu.style.display = 'none';
    navigateToCustomizePage(item.page);
  });
  customizeMenu.appendChild(menuItem);
});

customizeBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const isOpen = customizeMenu.style.display === 'block';
  customizeMenu.style.display = isOpen ? 'none' : 'block';
});

document.addEventListener('click', () => {
  customizeMenu.style.display = 'none';
});

customizeWrap.appendChild(customizeBtn);
customizeWrap.appendChild(customizeMenu);
row.appendChild(customizeWrap);

function navigateToCustomizePage(page) {
  const tripId = window.ORT_TRIPID ? window.ORT_TRIPID.get() : (window.state?.tripId || 'default');
  const params = new URLSearchParams(location.search);
  const cc = params.get('cc') || '';
  const itin = params.get('itin') || '';
  
  // Stocker le trip enrichi
  if (window.state && window.state.steps) {
    const tripData = {
      id: tripId,
      title: window.state.title,
      country: window.state.country,
      steps: window.state.steps,
      updatedAt: Date.now()
    };
    localStorage.setItem(`ort_trip_${tripId}`, JSON.stringify(tripData));
    console.log('[CUSTOMIZE] Trip stocké:', tripId, tripData.steps.length, 'étapes');
  }
  
  console.log('[CUSTOMIZE] Navigation vers:', page, 'tripId:', tripId);
  if (window.ORT_TRIPID) {
    window.ORT_TRIPID.navigateTo(page, { id: tripId, cc: cc, itin: itin });
  } else {
    window.location.href = `${page}?id=${encodeURIComponent(tripId)}&cc=${cc}&itin=${itin}`;
  }
}

hdr.appendChild(row);

// Init badge moyenne au chargement
(function(){
  const badge = document.getElementById('rtAvgBadge');
  const A = avg(loadRatings());
  if(badge){
    if(A!=null){ badge.style.display='inline-flex'; badge.innerHTML=`⭐ ${A}/10`; }
    else { badge.style.display='none'; }
  }
})();

// === Icônes Réservation (✈︎ / 🚗 / 🛡 Assurances) à droite du Dashboard ===
(function(){
  console.log('[SERVICES] Menu Services - début');
  // éviter les doublons si re-render
  if(row.querySelector('[data-rt-resv="wrap"]')) {
    console.log('[SERVICES] Wrap existe déjà, retour');
    return;
  }
  
  console.log('[SERVICES] Création du menu');
  const getParam = (k)=> new URLSearchParams(location.search).get(k)||'';
  const rtKey = window.CURRENT_TRIP_ID || getParam('rtKey') || 'trip_demo';

  const uidRaw = (window.CURRENT_USER_ID || localStorage.ORT_USER_ID || localStorage.getItem('ORT_USER_EMAIL') || 'guest')+'';
  const uid = uidRaw.toLowerCase().replace(/[^a-z0-9]/g,'');

  const pagePath = location.pathname + location.search;
  const lang=(document.documentElement.lang||'fr').slice(0,2);

  // états réservations (persistés localStorage) — avion/voiture
  const flightKey = `ort.rtBooked.flight.${rtKey}`;
  const carKey    = `ort.rtBooked.car.${rtKey}`;
  if(localStorage.getItem(flightKey)!=='1') localStorage.setItem(flightKey,'0');
  if(localStorage.getItem(carKey)!=='1')    localStorage.setItem(carKey,'0');
  const flightBooked = localStorage.getItem(flightKey)==='1';
  const carBooked    = localStorage.getItem(carKey)==='1';

  // I18N tooltips
  const TIP_FLIGHT = t('bookFlight');
  const TIP_CAR = t('bookCar');

  // I18N libellé assurances (tooltip + aria-label)
  const TIP_INS = t('bookInsurance');

  const wrap = document.createElement('span');
  wrap.setAttribute('data-rt-resv','wrap');
  wrap.style.display='inline-flex';
  wrap.style.gap='10px';
  wrap.style.marginLeft='10px';

  // Bouton rond (icône) — vert si réservé, rouge sinon
  const mkBtn=(icon,label,href,isOn)=>{
    const el=document.createElement('a');
    el.href=href; el.target='_self'; el.title=label; el.setAttribute('aria-label',label);
    Object.assign(el.style,{
      display:'inline-flex',alignItems:'center',justifyContent:'center',
      width:'34px',height:'34px',borderRadius:'50%',
      border:'1px solid #c3d6b6',
      background:isOn?'#0f9d58':'#e63b2e', /* vert si réservé, rouge sinon */
      color:'#fff',textDecoration:'none',fontSize:'18px',
      boxShadow:'0 2px 8px rgba(0,0,0,.12)', lineHeight:'1'
    });
    el.textContent=icon;
    return el;
  };

  // === Liens réels avec paramètres d’identification ===
  // ✈︎/🚗: on conserve la redirection interne
   const flightHref=`/web/redirect.html?type=flight&uid=${uid}&rtKey=${encodeURIComponent(rtKey)}&lang=${lang}&page=${encodeURIComponent(pagePath)}`;
  const carHref   =`/web/redirect.html?type=car&uid=${uid}&rtKey=${encodeURIComponent(rtKey)}&lang=${lang}&page=${encodeURIComponent(pagePath)}`;

  // 🛡 Assurances: lien affilié Ekta Traveling avec langue dynamique
  const insLang = { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
  const insHref = `https://ektatraveling.com/${insLang}/?sub_id=8d611d0d167741c58fdfe9e61-688844&utm_source=travelpayouts`;

  // Icônes voiture Porsche (rouge=non réservé, verte=réservé)
  const CAR_ICON_RED = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAABAGlDQ1BpY2MAABiVY2BgPMEABCwGDAy5eSVFQe5OChGRUQrsDxgYgRAMEpOLCxhwA6Cqb9cgai/r4lGHC3CmpBYnA+kPQKxSBLQcaKQIkC2SDmFrgNhJELYNiF1eUlACZAeA2EUhQc5AdgqQrZGOxE5CYicXFIHU9wDZNrk5pckIdzPwpOaFBgNpDiCWYShmCGJwZ3AC+R+iJH8RA4PFVwYG5gkIsaSZDAzbWxkYJG4hxFQWMDDwtzAwbDuPEEOESUFiUSJYiAWImdLSGBg+LWdg4I1kYBC+wMDAFQ0LCBxuUwC7zZ0hHwjTGXIYUoEingx5DMkMekCWEYMBgyGDGQCm1j8/yRb+6wAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH6QwLDyMNJCrGCwAADJ1JREFUaN7tmGmMZNdVx3/nvq2Wrt63melpe8bj3WHsLEYBJzGJQ4gC+ENiRQaBErE4smQkEjlBxAIkjBD+QBAE8gEFAYkQOAFMDIqNIrwlGC+xY8czHpPxaHo67unppaqru6redu89fKjqnp6M7dgofECaIx3deq/ue+/8z34uXKALdIEu0AW6QP+PSf43D63/1+OYOA5dWo5pWYy7wo47W45aZ4fVa43SV7y6GMWg4Lx13vlChMx538G6tnq3IWJaGoatUn2b3NpvXF/wqWt/7U3JEr6ZzcVjj3Pvffex8vzRq4s4vkORn0zT3mTay+pZliZZnodFWRpbWqy1eGdR71HAiCEUwRhxoRgbh2GWRFEnjqK1OEmeSeALnzx859O3/oXTvbd/4kdvAf/cEf7lK3/PeK1++MX25t8sFfbw2tYm6+1NNjpbbHZ7pFlGWRY451CBrNfDOUcYhgiCACJCZAxJFFGNYoYqCdMjo8xXqy8frtc/vrDReuxj77+J2Ttuf0NyBW8UwAf3z7O/Vh97aOn0nz+X5+863mpxcnWVxZUV1rc2cUYZnh5nfM8UwxOjFEVGlueUzhJXK+w7dBEj0xNEtQqdLGN9c5PVrS1W05SVsuB0WY6X3e6lN05OP/DSyYXOV488/6MDsPC5z3PN79/FNRcduO25Xu/25W7HbDTXaa6v0et2KfKcXqdDY6TBFYevZHRqgtpwnbGpCfbM72PfwXnmDswzOTtNp91m4fgJiizHlhZbFoiADwxb1s6HWbp5x/3/9Oj7z6zxV08/9eZd6PjiEqevvJrRe/5oTL+/eKn3tE8uL76U1EcOPbjZ/rfj6i5rtzdpNZu0my3CKCTPcvIsI6nGvPO9N5BUq6gqqh4UkP5n1Due+I9vcWZpGWMMIoItS5JaldpQg/rQEFeJnLp1776f9Xnx3asuOXCgyIq9fm7uhP/Vjy3Ld57Xn7j5514bwANXXEvwMz9Ftyx+7OK8/NPk1OLbT6XpkwtJePPa1OynnzXctZ7ntJstmmvrWFui6sl6KbYs8d5RawwhIqhXFEVVdz6kquRpRhhF/bjynrIocdaSVKsMjQwzFobclFQ/94H9e357Oi++rEsrH2pNz5xYmZ747ffsu+Srn73/7/jrI8deOwv97YP/ikP3NLLiQCXNK+00rb/thne97UR74xc3opAiTSk7HWoGTBLT63RBFQtIECC9FFv2s08UR4gIeZ7jnMcEhsbQEBKYvkUUNI7JeimuKLDdLu044Wia3XKoktz79ePH6p00r6TLp/b7kaErnvjaP7M6Of5DslAAeEKEvTfsmfn1H983/+Ebr39nsLC0fCgrC6mNThCgkGUEQBgEdLc2d4Te1vj229V7ytLirEPV45zHe4dXRcIICzgFggCnnrTbIRK47i3XPPvQc9+OH15ceHRJyy+I8S8HxvS6reL168DXP/0pelgd1+jw0MjEh+KkfoUJQsbqw9RHRqlNTBCEIeIcqBLEES5NsXmOWof3HlTp41DUg/duEBN9FiN45+h2e4gZ5BEjaBBi85TmqUVGZueu+4WpGW4Rv5kV3QmJeCGQiJ//k8+/tgX+4c7fZLG1Grzj4stui5PK3a2tdMyeOMlUUeBrVcKJSZIoplpJkIEwQWDAe9LWBliLWot613cPdMdV+kXAQBAQxBHdXkqv06GSJCiCF0NlfBzCgNVjx6DXoxnHsH8vw0OVM5ntfebh06e+dNXohP+Nv/zy+Ra455c/yJ56nYk4vClS7n5laHjs8fU2R5eXuGZtjffZEhkeoT4ySjAyTCAC3uMEAoGi1UbLAnUOdQ504E4KKoAxO2yMod1NCUTIgxACgwkjXGuV9toaW6+8wjcrFb4zPMLesWFunJ2ZGV3dvOfaibGFahI//J5L53nke6fOBTAXNHj3790t3/qtT35ko9sdK6+cwC1+n46Bb4QBcbvJDWtn6I2MUhsbQ+IInMerx6uiaQ+b5+Ac3m0Lvx0TAsagRkAMBUphPXEQ4BEwQhiGdMSwtXqGJ+KEh+IGcWRoTE7A/jlaCy9N+3Ttw7d94rMPnzzx0vkAll94kd85NFvpnjhxoDU2RZ6lZFlKq7XB3Nw+Tu2b5fRjjzK3vkpepIRx1Pd157HqkbJEiwK8B+93XGgbgAoogopQqGI4e40IRRiSOcep0rL0juuZsI4zZ1aoJAlWHRsbLYa2Vg/94R/fmSRO8vNcKGu1kNwlC089Ndq45jqWjh7lissOEYUBW+02zWaTx0dGubW5iuuCswmBenAe1CPeE1rbt4bqrkDu1zI/WBUwCtEgBBXFiVAUBZl6npqaoVutM1urcvlll3PJwYs5efRFxpttehsbk8FIteK8ng+AosA4F5VlVp2Pq5gnn+Hlp59hcs8sw0NDjE9NUuyfp6aepLlGrB4jghukTlFFULz2NesBLzqwRD+SZYAm5Ox9r/0C573Hj0+SzM2zf24vZadL0Fxj4d6vMN1LmU5iFrO8GiUS7849OwAkCFBroziO4kajwfXW89bFk7QXFmiLkIcRM40Go2GIVBLM4CUqBhXFa5/VaF94FTx9SzhlcA+cKE4FNwDr6RdBjGFI4eYza6z/430EzhF5JQpj4osuplevgQnijV4WBiY8H8DknnGsuqDa6ga60URMwNDsLCN5hslzKAvIU6Rew1QqiHq2c+S2BnUAwnt/FpCCU4/3ivUep4r1/f+c74N10k+jKobRXpc9QUgeJ2RhRBpF+DBAXU61npjG+LARDLyweC4AEwpxmOC7Xb755KN8t5NTD0KmkoTxJGEkjvucxNTjmAQGgXi2QHnnsc7ivO8Lp7sso4of3LPaB1OqYhVy+pwppLagU6RsOkfbWVpliV88zsHRKiMzw9RqFbx151vAOkuA+ky9/1ov4/jUDHsmJ/Bpiut2KDdamE6Xg0XJ5aqMBUKI0ANK+q7gB22BGwSt2xW4u7OQDvZ56e8rga4qS15ZDQy2WiWoVYlGxwgrVZZXVlnb2OLGybq3zqp3rwJAnUdEXG6dXVOhKEt8EDJ14AD1eo2VlRWOHHmRrdJSS1OG87Qv6Hael7PZps8yANEHtr1NVftgpL+nfw+WgpDvxQFpFHL42muZmZkhzzJarQ3ONJus9zxpXtiaLa0tX9UCJcb40nqXo8ry8hmWTy9TqyREUYiIkGU5m87jooC3z07SdcrpvCRXxW1rXz1WBxpm4ELbaXSgfZX+eBkFAaNxQNvlfDu1tKxFnOW5Z5/FO09pS/KiJAhDJiNDlhf5Zq9XloU9H0C3L0gpXrPqQLOhMSRJTGAMIqCVhLekGR+tJjzv4IutTU47jwOMnNVmvwcaXLzqBNXfEYmwLwv46XrEu+sxa+2MDRMg6jGm3+la028EE5TC2k4rLQqXlecD2LIWZyimVLduqCWsq7DsPWbQv4gRDpaWj8cB/+0897RatAMhjEOs84Q7Pf7ZAuYHHalsA1PFiCACzishYDjmlc3NjFvG6ryvkvDvpSUzgoggAyWOGcPFSUyu0kqdFvpqAF7slDwyFJS/UriNy+pDfGZ8hle6XdZsyRqAtXxgdJROp8OfNTfohYZ6HOIUisL3G7Wd+rKrnd72/wGqXfMZgQhhIJz2ngc3etwyNUXQ6XHMFiRBwFAQMjpSZ0+jQeYzljVfuffZhfK9c+PnA/jPTs4vZYV7xJjFI1vr5GGHiWqV6TjioBgmggAxhkXr+GijTihC5j2F89gk3skqJVCgWJRStwNY+xkIEBWMAhiM9YSDM6NIhHaasb+SUC+ENIroGaGJ8vLGGqVaskq08NbJGq+0s/PngUpkmJsdwzn/kSwvv9TJygoiBMYQiqFRSRiOYqpANQwIvCLOYbansJ3+R3cK2k47vdMPbVdfzgluJ4IzQmkMGZBZS+Yc1jnsYECqxEE3joJbh2dH728fP8Nq4c4F0IiErFRTq8fzHu4qSneT89rwXiNVDRAREcQrRsD0z6lEXueA7LUPzfSsk20fWPQfEBVB1eu20byAM0bSIDAPiPd/4Et/ohGaYt36cz+SCBiQEhpWOQBcjTAPzAqMAHWghlAHhoAqSowQDybpYFCcDf1u+bXA7W5OHYIDSpQSoUDJgBToKWyirAILwJMCLyg0ZTBGv57mYqA2ELQBDA9+1wZAhgZrdbAmQIQQDoQPdjoNdsDojtBnAZRsh01/TYEesAVsAm2gBTQH3N317A89G5UBbwsU7lpD+i399hrtEnT3c+wS3m8fs+4SwP/AqGAHQPJd4OyAzxH8TR/uvspeeY31dTz/DZH+wF7lAl2gC3SBLtD/Ff0Prf6CSy2Pm8gAAAAedEVYdGljYzpjb3B5cmlnaHQAR29vZ2xlIEluYy4gMjAxNqwLMzgAAAAUdEVYdGljYzpkZXNjcmlwdGlvbgBzUkdCupBzBwAAAABJRU5ErkJggg==';
  const CAR_ICON_GREEN = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAgCAYAAABU1PscAAABAGlDQ1BpY2MAABiVY2BgPMEABCwGDAy5eSVFQe5OChGRUQrsDxgYgRAMEpOLCxhwA6Cqb9cgai/r4lGHC3CmpBYnA+kPQKxSBLQcaKQIkC2SDmFrgNhJELYNiF1eUlACZAeA2EUhQc5AdgqQrZGOxE5CYicXFIHU9wDZNrk5pckIdzPwpOaFBgNpDiCWYShmCGJwZ3AC+R+iJH8RA4PFVwYG5gkIsaSZDAzbWxkYJG4hxFQWMDDwtzAwbDuPEEOESUFiUSJYiAWImdLSGBg+LWdg4I1kYBC+wMDAFQ0LCBxuUwC7zZ0hHwjTGXIYUoEingx5DMkMekCWEYMBgyGDGQCm1j8/yRb+6wAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH6QwLDyMOvSOXsQAAC8hJREFUWMOVmGuMnNdZx3/PeW9zn53Z28yuLxvvxkm8dpyobaCRohSiOqGBQlGJCi0CPoCoIIUv8DUK4vIFqYIiIb5UERE0QgqCQhTVCrnQBjWp0zhOHOO7d+31rmfXc92ZeW/nHD6M10mwY68f6WjO+855zvP+n9s5z+MAAnDgwAEplUrSbDZl692taHx8XOb3zMtmf1OSJAFgcXFR4jiWKIpuxnJ9z0OHDokxRnzfl507d0qtVpNcLieu64pSSuI4vq38LVJbE2MMjuNsl49iqYjy1Sd44jgG4IEHHrglb7lcxhjDxsYG7XabKIpwXZd+v8/U1BS1Wu124q8DdLcmjUYDay2AvR2353o4nmO1SUXUR8o6ffq0BTh69Ogt+R3HoVQqUSqVEBH6/T5JknDgwAF832dlZeV2n2A/DsACdLtdjDHb0n5qUnSkcbMe1li2SdcXtttt+v0+Sik6nQ7VapUgCGi1WmxsbNBqtbbtCWrLHJ7noZTaMs8tfVBEyBVzZPIZsrnsdmUJwDPPPEOhUMBaS7PZxHVdBoMB7XabcrlMPp/nTkgB+L5PGIakabotplwuR3WyQiaXYWJy4o4s8Oyzz5IkCWEYAqC1ptfrMRgM6Ha7JElCsVjcNgAXsHEcMzExgdZ6W+YLhyGNS+sUS0Vc5XKn1Ov3sDLyqHKpjOM4OK7D4uIip0+fxlrLI488QhiGPPfcc7cFIICdmZkhSZJtAUjTlKvNq+L5HpcvX76Zq9wyMF595VUL8IXHf44Ly+elmqviOz7vf/A+rWbLZjIZabfbLC4ubssCAAwGAz4lf9+UMpkM5XKZ2dlZDh8+fEN6+59v/xtf3vxzvqoe9jfcXimUuJiaNLDWGt/1woyT2Zwp1Ddf+91Xk598eMQ+tPi5T+z/wgsvbDuwBLD33nuvJEnC2bNnb8gaN6O75u5icnJSer0eJ/73xPW1X/7NL5LLumptrbcnKTq/aHdkvhDG8XwyiMs2Nb611ihHRY7jtJTvXnJ971TgZo76iffTKarnjmycCP/50F/wua8/uj0A9XpdnnrqKXv48GEJw5AoilhbW8OYW+fH3Xt2y8TkBOfPnqe50bRf+b0vITYW5RYWNnuD32m0r34tzsucTkT82CefyeM4LsYY1lcbhOEQIxpVcHFLvnFyXsPLBkcCP/NSUWVfXcjPntuI2un3//bWlnB835fXX38dEZHBYIAxhuFweFvknVaH1ZVV/vIf/pSklKVen5zCyX4zNfbbAzf+5TSrKhV3UvYtLPLAzzzIvQfvZX7xbmZ3z7K+0kQPNRk3Q32iRngllKgRFqLuYG/I8EtdL/zK5fDq/ZFJzL7P379+7q0TYStp8NYPj9zchfysb5VVorUmSRImf6mGPx3YwZk+rdc3APjXv/9H9hbm5O+WX3AuDRtBYtNcGsWF1qlGYbJUvS/I5P7YKB5KsokT65DI1ezb+QAzEzMYa0i1xhhDr7vJez8+RmfjKsp3qU6P0Whs0B+GaJuSBilp3UUph4z4YVZljuUc//uZwPuvWnWiUcjlN86/e6J7z6MP8t1vfuejGBifGxd/V8DUN6aIXrtoH5//Bq3uarblhXc3s/39sdXziU53pEZPpVpPYO2YCGUT65yk5NOBzuBZ3FjoHVsnnlZU5mpkclm01Rg02hqMGLTRaJ1iAeNY7LXjVKyglAtGsBpsCso4ZCQgEK9bdDL9kvG+Z95d/hN3oWZefv4HHwHY+4MFOfjSrD33xhuy82uHpivD2UOloPrV1fzqz7YznfFBf6iurjUJByFe1qU0UaBYyuFnXFBgUotRGhtrmhfW6NuY8R01MrkAEUEElAg6MrQ2Oriez/hkmUzeIxsEeJ5Hvztk5eQVWpc7pNbiF7NgPUwPvIbg9TVFL3PWGfd+a3A5eLM8NxylvT/77rf40cq7FFV2IgnU1yvO9G8X0/H97qx2mY65cPwCx/7jOPFqDAZSR5Pbk6X2mQnIaIZhRBynpFzTqtWkqQYro2EsxlgwYEPLoB8iohir59k1V+XA3QsMrmre/Kdj9M4McLRDmEZE2Zji/ir5Shm7abGxxkUouN7LRcOvJuKE7q/91eO8efEdHC0Ptuj9dZqoR7WrHH8uwfWFyz9s8NMXP6DqjlEaryEiJEnC5Q+v8MHSSdgtWLGIAuuM7kkAdoTkGohrH2/ttcufoBxhgwjxIpzYcPY/1/HXcuyamCUMhxSLRZrNDuffXia6pwepRjQEysPLl6KFXfekq60GTrQe03ynGyRO8p1er/8LViVqrC4M4hZnl85z9JVTVJMq+XyWcLiJtYZ+f8BsvUbrcofYiVFKEDMaKgVSkGQ0SEFSi6SABtGM1qEQF8QVGuc6yCmPydI4YRQiWDzXpV6fpt3o0It6OBmFg8IVD0+C1ahn/yXsJ4lrQ4ubdXTrvd56FCWoSdi40iAyKfFQYy5bSjNFRAz3LOxhvFrhzLlltLGUs0V67QEqB1ZbrGORUTRePwbttYkIiBKUo3A9F+MYlCeY1JI0NFWvQBiFzNQmObh/HyfPnOPipcvM1mpcXWtCFcxaQjLQDAJ26qwas9b23XOnLsmexV1pfqJ4bHP5CulqiltysAGYGGxsQWA46BMEAeOVKsfjMxgLgR9g+xalFEHBwy04KKVQnqBcQSmFOKNfx1U4nsIPfBxPYbH0+0M67R5mmGKNpVwtEWQyWAStNdXxcaIwxKaQNg3JqraZrN8TR708bDU3rAX3ieces2eWzpHNZzZL08UPhulwB0JJJ1rpyJAkKeEwYqwyzsWVNS4srzAYRuyYneHsuSXQQMciWvASDyVqpH17zeetRRtNbNPRsx5gUoNODWmSkugU3TZ00x4zO2Y5e26ZZrNFp9Pls5/9DEeOvBsW3eK6H/vHpeq8kc1nf1SpVN+72mpGpz84hVurjMvuqZnicDNcauc7rzU7rZ9vtdu5VrftJ2GCxHDp0grVif3kcjk2e5vMzdVZXl6m1ergOAp71hJKSKJiZAvAx65S1o6C+1rJev2dNSNXEwN9t8/yhWXump8nCHzqszs5efI0gzB05mfu8kulUqVQKu7MZbNznuusihD+4R/8RuIiCmutVUoN/cD/sJDNtdGm5OMWwiDKpfk0m6Y6e+bUmexYZSyby+Wc48c/TLq9Xm9qeqLjOE5fRGKsTSw2xpJarAaMjMLWIJhRdrpWBMjo/JFRQaWsxTNa54aDfunkh8cLuXzeTZMksdAbGxvrBBm/6bhqwxqzolN9XilpKiW60+5/snQ0JkXEkXfefYU33vhvdeHCsmq12mqz13euNtvu8tJFZ3NzU8pjZb2wMJ9OTlbScjGvp6bG7f3777FPPPErNpvfAWC30untyBiNiJKj77/O889/T73145+o5eWLsjB/t33yycfNk4ceN/cd+Lw1xmyVvDfWqaMyMS/XhNp+f/OWQr/3R5+8qP7632y7jcPvf+t+RESWL3R56d/P2+0UQLel6elpisWiFAoF2U5RDzA3NycPP/ywlMvlm67N5hyKZQ8/uFFrX3xyXmozH8mqVCoyNjb2cdnb1ogLyJUrV6zneR9vq9xWI0EQWMdx5NNcZTjQo5PrJtRtZhAywMjSk5OTKKVot9tbsu+oM2cBkiRBa72tjx9lEYvWmv379/PQQw/dkcUr5V147kftk/X1dRqNBgC1Wk127tzJnQCQffv2US6XKRQKbBf97t27RalRBnv77bdv+P+xxx5j7969vPjiizfEnTGaKAqva79erzM1NQWMml4bGxt3BID77rvvU4P70yiXy1ksHDt2TG5SY5OmKfV6naeffvpGC4xV8DwP3/cpFouUSiUKhQLFYpF6vU6lUtk2AAeQEydOMDU1JY7j0O/3t+VGg8FA8vk8jUbjelP34+CXlpZYWlqi1+vx/wJTDh48SKPRwHEcjDHEcUy320VEGAwG9Ho9pqent3hvG8TXabudORi1IovFIq57542tzc1NXNcliiKCIGBlZYUwDDl48CC9Xo9SqcTS0tK29vo/nM6709Fe9NcAAAAedEVYdGljYzpjb3B5cmlnaHQAR29vZ2xlIEluYy4gMjAxNqwLMzgAAAAUdEVYdGljYzpkZXNjcmlwdGlvbgBzUkdCupBzBwAAAABJRU5ErkJggg==';
  const carIcon = carBooked ? CAR_ICON_GREEN : CAR_ICON_RED;

  // === MENU SERVICES (dropdown) ===
  const servicesMenuBtn = document.createElement('button');
  const getLangServices = () => window.ORT_getLang ? window.ORT_getLang() : (localStorage.getItem('lang') || 'fr').slice(0, 2);
  const getServices = (key) => {
    const lang = getLangServices();
    const fServices = { services: { fr: 'Services', en: 'Services', es: 'Servicios', it: 'Servizi', pt: 'Serviços', ar: 'خدمات' }, servicesPartnerTooltip: { fr: 'Accès aux services partenaires', en: 'Access to partner services', es: 'Acceso a servicios asociados', it: 'Accesso ai servizi partner', pt: 'Acesso aos serviços parceiros', ar: 'الوصول إلى خدمات الشركاء' } };
    if (window.ORT_I18N?.[key]?.[lang]) return window.ORT_I18N[key][lang];
    if (window.ORT_I18N?.[key]?.fr) return window.ORT_I18N[key].fr;
    return fServices[key]?.[lang] || fServices[key]?.fr || key;
  };
  servicesMenuBtn.innerHTML = '🛠️ ' + getServices('services');
  servicesMenuBtn.title = getServices('servicesPartnerTooltip');
  servicesMenuBtn.style.cssText = `
    padding:8px 14px;
    border-radius:6px;
    border:1px solid #c3d6b6;
    background:#f8fafc;
    cursor:pointer;
    font-weight:600;
    font-size:14px;
    display:inline-flex;
    align-items:center;
    gap:6px;
    box-shadow:0 2px 8px rgba(0,0,0,.12);
    position:relative;
  `;
  
  // Dropdown menu
  const dropdown = document.createElement('div');
  dropdown.style.cssText = `
    position:absolute;
    top:100%;
    left:0;
    margin-top:4px;
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:8px;
    box-shadow:0 4px 20px rgba(0,0,0,0.15);
    display:none;
    min-width:220px;
    z-index:10000;
  `;
  
  const getLang = () => window.ORT_getLang ? window.ORT_getLang() : (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0, 2);
  const getLabel = (key) => {
    // Chercher d'abord dans window.ORT_I18N, sinon dans le fallback
    const lang = getLang();
    if (window.ORT_I18N?.[key]?.[lang]) return window.ORT_I18N[key][lang];
    if (window.ORT_I18N?.[key]?.fr) return window.ORT_I18N[key].fr;
    // Fallback
    const fb = { flights: { fr: 'Vols', en: 'Flights', es: 'Vuelos', it: 'Voli', pt: 'Voos', ar: 'الرحلات' }, carRental: { fr: 'Location voiture', en: 'Car rental', es: 'Alquiler de coche', it: 'Noleggio auto', pt: 'Aluguel de carro', ar: 'تأجير سيارات' }, transfers: { fr: 'Transferts', en: 'Transfers', es: 'Traslados', it: 'Trasferimenti', pt: 'Transferências', ar: 'التحويلات' }, insurance: { fr: 'Assurance', en: 'Insurance', es: 'Seguro', it: 'Assicurazione', pt: 'Seguro', ar: 'التأمين' }, delayCompensation: { fr: 'Compensation retard', en: 'Delay compensation', es: 'Compensación por retraso', it: 'Compensazione ritardo', pt: 'Compensação por atraso', ar: 'تعويض التأخير' } };
    return fb[key]?.[lang] || fb[key]?.fr || key;
  };
  
  const services = [
    { emoji: '✈️', i18nKey: 'flights', action: () => showPartnerModal('flight') },
    { emoji: '🚗', i18nKey: 'carRental', action: () => showPartnerModal('vehicle') },
    { emoji: '🚐', i18nKey: 'transfers', action: () => showPartnerModal('transfer') },
    { emoji: '🛡', i18nKey: 'insurance', action: () => showPartnerModal('insurance') },
    { emoji: '💰', i18nKey: 'delayCompensation', action: () => showPartnerModal('flight') }
  ];
  
  services.forEach((svc, idx) => {
    const item = document.createElement('button');
    item.innerHTML = `<span style="font-size:18px;margin-right:8px;">${svc.emoji}</span>${getLabel(svc.i18nKey)}`;
    item.style.cssText = `
      width:100%;
      padding:10px 16px;
      text-align:left;
      border:none;
      background:none;
      cursor:pointer;
      font-size:14px;
      color:#1f2937;
      transition:all 0.2s;
      ${idx === 0 ? 'border-radius:8px 8px 0 0' : ''}
      ${idx === services.length - 1 ? 'border-radius:0 0 8px 8px' : ''}
    `;
    item.onmouseover = () => item.style.background = '#f3f4f6';
    item.onmouseout = () => item.style.background = 'none';
    item.onclick = (e) => {
      e.preventDefault();
      svc.action();
      dropdown.style.display = 'none';
    };
    dropdown.appendChild(item);
  });
  
  servicesMenuBtn.appendChild(dropdown);
  servicesMenuBtn.addEventListener('click', (e) => {
    e.preventDefault();
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
  });
  
  // Fermer le dropdown quand on clique ailleurs
  document.addEventListener('click', (e) => {
    if (!servicesMenuBtn.contains(e.target)) {
      dropdown.style.display = 'none';
    }
  });
  
  console.log('[SERVICES] Avant wrap.appendChild(servicesMenuBtn)');
  wrap.appendChild(servicesMenuBtn);
  console.log('[SERVICES] Avant row.appendChild(wrap)');
  row.appendChild(wrap);
  console.log('[SERVICES] ✅ Menu Services ajouté');
})();

  }catch(_){}

}();
</script>

</header>

<div class="wrap">
  <div class="card topband">
  <div class="help-anchor">
    <div id="rtTitleWrap" class="title-wrap">
      <div id="rtTitle" class="pill title" data-i18n="loading">Chargement...</div>
      <button id="rtTitleEdit" class="title-edit-btn" data-i18n-title="editTitle" title="Modifier le titre">✏️</button>
    </div>
<!-- countryTab déplacé dans les icônes inline (bCountry) -->
<button id="countryTab" data-i18n-title="countrySheet" title="Fiche pays" style="display:none">
  <img src="../assets/icon-country.webp" alt="Fiche pays" style="width:22px;height:22px">
</button>
    <div id="quickStats" class="pill stats" data-i18n-title="legend" title="Survolez pour la légende">
      <span id="qsNights">— nuits</span> · <span id="qsDelta">Δ 0</span> ·
      <span id="qsKm">— km</span> · <span id="qsTime">— h — min</span> · <span id="qsTravelDays" title="Jours de trajet (vols/longues routes)">+0j trajet</span>
    </div>
    <div id="budgetBadge" class="pill budget-badge" style="display:none;cursor:pointer;background:#dcfce7;color:#166534;border-color:#86efac;" title="Cliquez pour voir le détail">
      💰 <span id="budgetAmount">0 €</span>
    </div>
    <button id="helpBtn" class="hdr-btn" title="Aide" aria-expanded="false" data-i18n-title="help.title">ℹ️</button>
    <div id="helpPop" class="help-pop" role="dialog" aria-hidden="true"></div>
  </div>


</div>



  <div class="main">
    <section class="card">
     <div style="display:flex;gap:8px;justify-content:space-between;align-items:center;margin-bottom:12px">
  <div class="small" data-i18n="dragToReorder">Glissez pour réordonner</div>
  <div style="display:flex;gap:6px;">
    <button id="btnListFull" class="iconbtn" type="button" data-i18n-title="fullscreenList" title="Plein écran liste (2 colonnes)" style="font-size:16px;padding:4px 8px;background:#f1f5f9;border:1px solid #cbd5e1;border-radius:4px;cursor:pointer;">⤢</button>
  </div>
</div>

<!-- Réservations du voyage (non étapes) -->
<div id="tripBookingsContainer" style="margin-bottom:24px"></div>

      <div id="rows"></div>
      <div style="margin-top:12px;display:flex;gap:8px">
        <button class="btn" id="btnSave">💾 Sauvegarder</button>
        <button class="btn ghost" id="btnExport" data-i18n="export">📥 Exporter</button>
        <button class="btn" id="btnSaveSource" style="display:none;background:#dc2626" title="Écrire les modifications dans le fichier JSON source">
          🔴 Écrire source
        </button>
        <button class="btn" id="btnDeleteItin" style="display:none;background:#7f1d1d" title="Supprimer définitivement cet itinéraire de toutes les langues">
          🗑️ Supprimer
        </button>
        <button class="btn" id="btnOpenItinBottom" style="display:none;background:#2563eb" title="Ouvrir un itinéraire par son ID">
          🔓 Ouvrir itin
        </button>
      </div>
    </section>

    <aside class="sidebar">
  <div class="card">
    <!-- Bandeau et copies de boutons supprimés : tous les contrôles sont dans le header -->
 <div id="map">
  <!-- Overlay actions carte -->
    <!-- Overlay actions carte -->
  <div id="mapActions" aria-label="Actions carte">
<button id="btnMapFull" class="tool" type="button" data-i18n-title="fullscreen" title="Plein écran">⤢</button>
<button id="btnMapExit" class="tool" type="button" data-i18n-title="exitFullscreen" title="Quitter plein écran" style="display:none">⤡</button>
<button id="reorgFullscreenBtn" type="button" aria-label="Modifier itinéraire" title="Modifier l'ordre des étapes">✏️</button>

   
  </div>

</div>
         <!-- Aide "Survolez un marqueur" supprimée -->
->
  </div>
</aside>

  </div>
</div>

<!-- Footer ORT -->
<footer id="footer-legal"></footer>

<!-- === FICHE PAYS (tiroir latéral global) === -->

<div id="countryDrawer" role="dialog" aria-label="Fiche pays">
  <div class="cd-head">
    <div class="cd-title" id="cdTitle" data-i18n="country">Pays</div>
    <button class="cd-close" id="cdClose" aria-label="Fermer">✕</button>
  </div>
  <div class="cd-body">
    <div class="tabs" id="cdTabs"></div>
    <div id="cdPanes"></div>
  </div>
</div><!-- === FICHE PAYS (tiroir latéral global) === -->

<script>
// Place le bouton "Fiche pays" dans la barre d’icônes du header (toujours visible)
(function ensureCountryTab(){
  function openDrawer(){
    const d = document.getElementById('countryDrawer');
    if (d) d.classList.add('show');
  }

  function mountInIcons(){
    // Icône pays supprimée du header - accessible via menu Outils
    return true;
  }

  function mountFallback(){
    // Fallback supprimé
  }

  // Désactivé - fiche pays dans menu Outils
  // if (!mountInIcons()) mountFallback();

  const cdClose = document.getElementById('cdClose');
  if (cdClose && !cdClose.__wired){
    cdClose.addEventListener('click', () => {
      document.getElementById('countryDrawer')?.classList.remove('show');
    });
    cdClose.__wired = true;
  }
})();
</script>


<!-- === Modale e-mail (même structure que presentation.html) === -->
<div id="emailModal" role="dialog" aria-modal="true" aria-label="E-mail" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.4);align-items:center;justify-content:center;z-index:10000">
  <div class="modal-card" style="width:min(440px,92vw);background:#fff;border-radius:14px;border:1px solid #c3d6b6;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.16);color:#113f7a">
    <h3 id="emailTitle" style="margin:0 0 6px" data-i18n="emailLogin">Connexion par e-mail</h3>
    <div id="alertContainer"></div>
    <input id="emailInput" class="input" type="email" placeholder="Votre e-mail" autocomplete="email" style="width:100%;padding:10px 12px;border:1px solid #113f7a;border-radius:10px;margin:8px 0">
    <div class="input-wrap" style="position:relative">
      <input id="pwdInput" class="input" type="password" placeholder="Mot de passe (min. 6 caractères)" autocomplete="current-password" style="width:100%;padding:10px 12px;border:1px solid #113f7a;border-radius:10px;margin:8px 0">
    </div>
    <div id="pwd2Group" class="input-wrap" style="display:none">
      <input id="pwd2Input" class="input" type="password" placeholder="Confirmez le mot de passe" autocomplete="new-password" style="width:100%;padding:10px 12px;border:1px solid #113f7a;border-radius:10px;margin:8px 0">
    </div>
    <div class="actions" style="display:flex;gap:10px;justify-content:flex-end;margin-top:8px">
      <button id="emailCancel" class="btn" type="button" style="background:#fff;color:#113f7a;border-color:#113f7a" data-i18n="cancel">Annuler</button>
      <button id="emailGo" class="btn" type="button" style="background:#113f7a;border-color:#113f7a" data-i18n="validate">Valider</button>
    </div>
  </div>
</div>

<script>
/* Helpers header */
(function(){
  const $=id=>document.getElementById(id);
  const openAuth=$('openAuth'), pop=$('authPop'), btnGoogle=$('btnGoogle'), btnEmail=$('btnEmail'), btnLogout=$('btnLogout');

  function L(){
    const lang=document.documentElement.lang||'fr';
    const MAP_LOGIN={fr:"Se connecter",en:"Sign in",it:"Accedi",es:"Iniciar sesión",pt:"Iniciar sessão",ar:"تسجيل الدخول"};
    const MAP_LOGOUT={fr:"Déconnexion",en:"Log out",it:"Esci",es:"Cerrar sesión",pt:"Terminar sessão",ar:"تسجيل الخروج"};
    return { login:MAP_LOGIN[lang]||MAP_LOGIN.fr, logout:MAP_LOGOUT[lang]||MAP_LOGOUT.fr, google:"Google", email:"E-mail" };
  }

 async function ensureFirebase(){
    if(window.firebase?.apps?.length && typeof window.firebase.auth === 'function') return window.firebase;
    
    // Charger les scripts si nécessaire
    if (!window.firebase?.initializeApp) {
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js");
    }
    if (typeof window.firebase?.auth !== 'function') {
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js");
    }
    if (!window.firebase?.firestore) {
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js");
    }
    
    // Attendre que firebase.auth soit vraiment disponible
    for (let i = 0; i < 50; i++) {
      if (typeof window.firebase?.auth === 'function') break;
      await new Promise(r => setTimeout(r, 50));
    }
    
    if (typeof window.firebase?.auth !== 'function') {
      throw new Error('firebase.auth not available');
    }
    
    // Initialiser seulement si pas déjà fait
    if (!window.firebase.apps.length) {
      window.firebase.initializeApp(window.__FIREBASE_CONFIG__);
    }
    await window.firebase.auth().setPersistence(window.firebase.auth.Auth.Persistence.LOCAL);
    return window.firebase;
  }
  
  function load(src){ return new Promise((ok,ko)=>{ const s=document.createElement('script'); s.src=src; s.onload=ok; s.onerror=()=>ko(new Error('load '+src)); document.head.appendChild(s); }); }

  function setHeaderLabel(user){
    if(!openAuth) return;
    if(user){
      let label=user.displayName||user.email||'Mon compte';
      if(user.email && user.emailVerified===false) label+=' (à vérifier)';
      openAuth.textContent=label;
      if(btnLogout) btnLogout.style.display='';
      if(btnGoogle) btnGoogle.style.display='none';
      if(btnEmail)  btnEmail.style.display='none';
    }else{
      openAuth.textContent=L().login;
      if(btnLogout) btnLogout.style.display='none';
      if(btnGoogle){ btnGoogle.style.display=''; btnGoogle.textContent=L().google; }
      if(btnEmail){  btnEmail.style.display='';  btnEmail.textContent=L().email;  }
    }
  }

  /* Menu popin */
  if(openAuth && pop){
    openAuth.addEventListener('click',e=>{ e.stopPropagation(); pop.style.display=pop.style.display==='block'?'none':'block'; });
    document.addEventListener('click',()=>{ pop.style.display='none'; });
    pop.addEventListener('click', e=> e.stopPropagation());
  }

  /* Google sign-in */
  if(btnGoogle){
    btnGoogle.addEventListener('click', async()=>{
      try{
        const fb=await ensureFirebase(); const a=fb.auth();
        const p=new fb.auth.GoogleAuthProvider(); p.addScope('email'); p.addScope('profile');
        const r=await a.signInWithPopup(p);
        setHeaderLabel(r.user); if(pop) pop.style.display='none';
      }catch(_){}
    });
  }

  /* E-mail (modale simple alignée) */
  const modal=$('emailModal');
  if(btnEmail && modal){
    const email=$('emailInput'), pwd=$('pwdInput'), pwd2=$('pwd2Input'), pwd2Group=$('pwd2Group'), btnValider=$('emailGo'), btnCancel=$('emailCancel'), title=$('emailTitle'), alertWrap=$('alertContainer');
    function showMsg(text, ok){ alertWrap.innerHTML='<div class="'+(ok?'alert-success':'alert-error')+'" style="padding:10px;border:1px solid '+(ok?'#bbf7d0':'#fecaca')+';border-radius:8px;margin:6px 0">'+text+'</div>'; }
    function switchMode(signup){ title.textContent= signup ? t('createAccount') : t('emailLogin'); if(pwd2Group) pwd2Group.style.display= signup ? '' : 'none'; alertWrap.innerHTML=''; }
    btnEmail.addEventListener('click', ()=>{ switchMode(false); modal.style.display='flex'; email?.focus(); });
    btnCancel?.addEventListener('click', ()=>{ modal.style.display='none'; alertWrap.innerHTML=''; });
    btnValider?.addEventListener('click', async()=>{
      try{
        const fb=await ensureFirebase(); const a=fb.auth();
        const mail=(email.value||'').trim().toLowerCase(); const pass=pwd.value||'';
        if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(mail)) return showMsg("E-mail invalide", false);
        if(!pass || pass.length<6) return showMsg("Mot de passe ≥ 6 caractères", false);
        const r=await a.signInWithEmailAndPassword(mail,pass).catch(async(e)=>{
          if(e.code==='auth/user-not-found'){ switchMode(true); showMsg("Aucun compte. Création ci-dessous.", false); return null; }
          throw e;
        });
        if(r?.user){ showMsg("Connexion réussie.", true); setHeaderLabel(r.user); setTimeout(()=>{ modal.style.display='none'; }, 500); }
      }catch(e){ showMsg("Erreur. Réessayez.", false); }
    });
  }

  /* Déconnexion */
  if(btnLogout){
    btnLogout.addEventListener('click', async()=>{
      try{ const fb=await ensureFirebase(); await fb.auth().signOut(); }catch(_){}
      setHeaderLabel(null);
    });
  }

  /* Sync session */
  try{ ensureFirebase().then(fb=>fb.auth().onAuthStateChanged(u=>setHeaderLabel(u))); }catch(_){}

  /* Auto-lang + navigation cohérente */
  (function(){
    const SUP=["fr","en","it","es","pt","ar"];
    let lang = new URLSearchParams(location.search).get('lang')
             || localStorage.getItem('lang')
             || (navigator.languages && navigator.languages[0]) || navigator.language || 'en';
    lang = (lang||'en').slice(0,2).toLowerCase();
    if(!SUP.includes(lang)) lang='en';
    localStorage.setItem('lang',lang);
    document.documentElement.lang=lang;
    document.documentElement.dir=(lang==='ar')?'rtl':'ltr';

    const sel=document.getElementById('langSel'); if(sel){ sel.value=lang; sel.addEventListener('change',e=>{ const code=e.target.value; localStorage.setItem('lang',code); const u=new URL(location.href); u.searchParams.set('lang',code); location.replace(u.toString()); }); }
    const home=document.getElementById('homeLink'); if(home){ home.addEventListener('click',e=>{ e.preventDefault(); const u=new URL('presentation.html', location.href); u.searchParams.set('lang', lang); location.href=u.toString(); }); }
    /* Libellés du bouton selon langue - seulement si pas encore connecté */
    if(openAuth && !window.firebase?.auth?.()?.currentUser) openAuth.textContent = L().login;
  })();
})();
</script>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="js/ort-step-common.js"></script>
<!-- STATE MANAGER -->
<script src="js/ort-state-manager.js"></script>
<script src="js/ort-detail-adapter.js"></script>
<script src="/js/ort-route-builder.js"></script>
<script>
 // === App script ===
 const ROUTE_API = null; // SUPPRIMÉ - utilise OSRM/Mapbox direct

// Config API Search - détection auto local/prod
const SEARCH_API = (() => {
  const host = window.location.hostname;
  if (host === 'localhost' || host === '127.0.0.1' || host.match(/^192\.168\./)) {
    return 'http://localhost:3031';
  }
  return '/.netlify/functions'; // NETLIFY FUNCTIONS en prod
})();

// === ORT Saves SDK (dashboard_user.html compatible) ===
const ORTSaves = {
  key(uid){ return `ort.saves::${uid}`; },
  load(uid){ try{ return JSON.parse(localStorage.getItem(this.key(uid))||'[]'); }catch(_){ return []; } },
  save(uid, arr){ try{ localStorage.setItem(this.key(uid), JSON.stringify(arr)); }catch(_){} },
  upsert(user, rt){
    if(!user){ toast('🔐 Connectez-vous pour sauvegarder'); return false; }
    if(window.ORT_STATE && typeof window.ORT_STATE.saveTrip === 'function') {
      const tripData = Object.assign({ createdAt: Date.now(), updatedAt: Date.now() }, rt);
      window.ORT_STATE.saveTrip(tripData);
      return true;
    }
    // Fallback localStorage (ancien système)
    const uid = user.uid, arr = this.load(uid);
    const key = `ort.saves::${uid || 'anon'}`;
    const i = arr.findIndex(x => x.id === rt.id);
    if(i >= 0) arr[i] = Object.assign({}, arr[i], rt, { updatedAt: Date.now() });
    else arr.push(Object.assign({ createdAt: Date.now(), updatedAt: Date.now() }, rt));
    localStorage.setItem(key, JSON.stringify(arr));
    return true;
  }
};
function currentUser(){ try{ return (window.firebase && window.firebase.auth && window.firebase.auth().currentUser) || null; }catch(_){ return null; } }

// === Générer un tripId unique ===
function getTripId() {
  const params = new URLSearchParams(location.search);
  const cc = params.get('cc');
  const itin = params.get('itin');
  const from = params.get('from');
  
  // Pour les RT standards (cc+itin), créer un tripId STABLE
  if (cc && itin) {
    const tripId = `user::${cc}::${itin}`.replace(/[^a-zA-Z0-9:_-]/g, '_');
    console.log('[getTripId] ✅ TripId stable:', tripId);
    return tripId;
  }
  
  // ══════════════════════════════════════════════════════════════
  // ROUTE BUILDER : Toujours créer un NOUVEAU tripId
  // Sinon on réutilise un ancien voyage = BUG CRITIQUE
  // ══════════════════════════════════════════════════════════════
  if (from === 'builder') {
    const newId = `trip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    localStorage.setItem('ORT_CURRENT_TRIP_ID', newId);
    console.log('[getTripId] 🆕 Nouveau tripId (Route Builder):', newId);
    return newId;
  }
  
  // Pour RT temporaires (import, etc.), vérifier si on a déjà un tripId en cours
  const tempId = localStorage.getItem('ORT_CURRENT_TRIP_ID');
  if (tempId) {
    console.log('[getTripId] ✅ TripId temporaire existant:', tempId);
    return tempId;
  }
  
  // Sinon, générer un nouveau tripId temporaire
  const newId = `trip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  localStorage.setItem('ORT_CURRENT_TRIP_ID', newId);
  console.log('[getTripId] ⚠️ Nouveau tripId temporaire:', newId);
  return newId;
}

// === Clic sur étape → popup affiliés (pas de navigation) ===
function openStepPage(step, idx){
  console.log('[STEP] Popup affiliés pour:', step?.name, 'idx:', idx);
  // Afficher le popup centré sur la carte
  showAffiliatePopover(null, step, idx);
}

// I18N pour le popup affiliés
function L_affiliate(){
  const lang=(localStorage.getItem('lang')||document.documentElement.lang||'fr').slice(0,2).toLowerCase();
  const t={
    hotels:{fr:"Chercher un hôtel",en:"Find a hotel",it:"Cerca un hotel",es:"Buscar hotel",pt:"Procurar hotel",ar:"البحث عن فندق"},
    close:{fr:"Fermer",en:"Close",it:"Chiudi",es:"Cerrar",pt:"Fechar",ar:"إغلاق"}
  }; 
  return {
    hotels: t.hotels[lang]||t.hotels.fr,
    close: t.close[lang]||t.close.fr
  };
}

// Popup affiliés ancré au marqueur ou centré
function showAffiliatePopover(anchorEl, step, idx){
  const t = L_affiliate();
  document.querySelectorAll('.go-pop').forEach(x=>x.remove());
  
  const box = document.createElement('div'); 
  box.className = 'go-pop';
  box.style.minWidth = '220px';
  box.style.zIndex = '10000';
  
  const checkIn = new Date().toISOString().split('T')[0];
  const nights = step.nights || 1;
  const lat = step.lat || 0;
  const lng = step.lon || step.lng || 0;
  const address = encodeURIComponent(step.name || 'Hotel');
  const stay22Url = `https://www.stay22.com/allez/booking?campaign=oneroadtrip&aid=oneroadtrip&checkin=${checkIn}&nights=${nights}&lat=${lat}&lng=${lng}&address=${address}`;
  
  box.innerHTML = `
    <div style="font-weight:600;margin-bottom:8px;color:#113f7a;">${step.name || 'Étape'}</div>
    <div style="font-size:12px;color:#64748b;margin-bottom:10px;">${step.nights || 0} nuit(s)</div>
    <a href="${stay22Url}" target="_blank" rel="noopener" class="btn" style="display:block;text-align:center;text-decoration:none;margin-bottom:6px;">
      🏨 ${t.hotels}
    </a>
    <button class="btn ghost" data-act="close" style="width:100%">${t.close}</button>
  `;
  
  document.body.appendChild(box);
  
  // Positionnement : ancré si anchorEl valide, sinon centré sur la carte
  if (anchorEl && anchorEl !== document.body) {
    const r = anchorEl.getBoundingClientRect();
    box.style.left = Math.min(window.innerWidth - box.offsetWidth - 12, Math.max(12, r.left + window.scrollX - 8)) + 'px';
    box.style.top = (r.bottom + window.scrollY + 8) + 'px';
  } else {
    // Centrer sur la carte ou l'écran
    const mapEl = document.getElementById('map');
    if (mapEl) {
      const mapRect = mapEl.getBoundingClientRect();
      box.style.left = (mapRect.left + mapRect.width / 2 - box.offsetWidth / 2) + 'px';
      box.style.top = (mapRect.top + window.scrollY + mapRect.height / 2 - 80) + 'px';
    } else {
      // Fallback: centré sur l'écran
      box.style.left = (window.innerWidth / 2 - box.offsetWidth / 2) + 'px';
      box.style.top = (window.innerHeight / 2 - 80 + window.scrollY) + 'px';
    }
  }
  
  box.addEventListener('click', (e) => {
    const act = e.target?.dataset?.act;
    if(act === 'close') box.remove();
  });
  
  // Fermer au clic extérieur après un court délai (évite fermeture immédiate)
  setTimeout(() => {
    document.addEventListener('click', function onDoc(e){
      if(!box.contains(e.target)){ 
        box.remove(); 
        document.removeEventListener('click', onDoc); 
      }
    }, {capture:true});
  }, 100);
}

// Compat: redirection vers popup affiliés
function showGoPopover(anchorEl, step, idx){
  showAffiliatePopover(anchorEl, step, idx);
}

function ensureRid(){
  // A) clé par URL (stable, sans dépendre de variables hors scope)
  const urlKey = `ort.rid.url::${location.pathname}${location.search}`;
  let rid = localStorage.getItem(urlKey);
  if (rid) return rid;

  // B) fallback par paramètres d'URL (itin / rtKey), sinon 'RT'
  const qs = new URLSearchParams(location.search);
  const base = qs.get('itin') || qs.get('rtKey') || 'RT';
  const k = `ort.rid::${base}`;
  rid = localStorage.getItem(k) || crypto.randomUUID();

  localStorage.setItem(urlKey, rid);
  return rid;
}

let __asTimer = null;
let __hasUnsavedChanges = false;

// Marquer qu'il y a des modifications non sauvegardées
function markUnsavedChanges() {
  if (__hasUnsavedChanges) return; // Déjà marqué
  __hasUnsavedChanges = true;
  
  // Afficher un badge/indicateur visuel
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) {
    indicator.style.display = 'flex';
  } else {
    // Créer l'indicateur s'il n'existe pas
    const div = document.createElement('div');
    div.id = 'unsavedIndicator';
    div.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:#f59e0b;color:#000;padding:8px 16px;border-radius:20px;font-size:13px;font-weight:600;z-index:9999;display:flex;align-items:center;gap:8px;box-shadow:0 2px 10px rgba(0,0,0,0.2);';
    div.innerHTML = `${window.t ? window.t('unsavedChanges') : '⚠️ Modifications non sauvegardées'} <button onclick="document.getElementById('unsavedIndicator').style.display='none'" style="background:none;border:none;cursor:pointer;font-size:16px;padding:0 0 0 8px;">✕</button>`;
    document.body.appendChild(div);
  }
  
  // Toast une seule fois
  if (typeof toast === 'function') {
    toast(window.t ? window.t('unsavedToast') : '💡 Pensez à sauvegarder vos modifications via le bouton 💾', 4000);
  }
}

// Réinitialiser le flag (appelé après sauvegarde réussie)
function clearUnsavedChanges() {
  __hasUnsavedChanges = false;
  const indicator = document.getElementById('unsavedIndicator');
  if (indicator) indicator.style.display = 'none';
}

// Ancienne fonction désactivée - remplacée par markUnsavedChanges
function scheduleAutosave(){
  // DÉSACTIVÉ - le dashboard n'est alimenté que via le bouton sauvegarder explicite
  // markUnsavedChanges() - SUPPRIMÉ (arrête de spammer l'alerte)
  return;
  
  /* ANCIEN CODE DÉSACTIVÉ
  clearTimeout(__asTimer);
  __asTimer = setTimeout(async () => {
    const u = currentUser(); 
    if(!u) return;
    
    const rid = ensureRid();
    const nights = (state.steps||[]).reduce((s,x)=> s + Number(x.nights||0), 0);
    let exportedTitle = state.title || 'Voyage';
    const stepsCoords = (state.steps||[]).map(s => 
      (Number.isFinite(s.lat) && Number.isFinite(s.lon)) ? [s.lat, s.lon] : null
    ).filter(Boolean);
    const coords = stepsCoords.length ? [
      +(stepsCoords.reduce((a,p)=>a+p[0],0)/stepsCoords.length).toFixed(5),
      +(stepsCoords.reduce((a,p)=>a+p[1],0)/stepsCoords.length).toFixed(5)
    ] : null;
    const coordsPath = stepsCoords.length >= 2 ? stepsCoords : null;
    let coverUrl = document.querySelector('#rtCover img, .hero img, .cover img')?.src || null;
    const summary = {
      id: rid, tripId: rid, title: exportedTitle,
      country: state.country || 'XX', nights,
      kms: Number((typeof TOTALS!=='undefined' && TOTALS.km) || 0),
      steps: (state.steps||[]).length,
      pace: (typeof getTransportMode==='function' ? (getTransportMode()==='car'?'auto':'train') : 'auto'),
      tags: Array.from(new Set((state.steps||[]).flatMap(s => s.tags || []))).slice(0, 6),
      detailUrl: location.href, coords, coordsPath, coverUrl
    };
    ORTSaves.upsert(u, summary);
  }, 600);
  */
}

// Petite fonction d'échappement HTML (utilisée par renderRow / showStepPreview)
function safe(v){
  return String(v ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

// === ICÔNES CATÉGORIES RÉSERVATIONS ===
function getCategoryIconForCell(category) {
  const icons = {
    lodging: '🏨',
    hotel: '🏨',
    flight: '✈️',
    car_rental: '🚗',
    car: '🚗',
    train: '🚆',
    restaurant: '🍽️',
    activity: '🎯',
    visit: '🏛️',
    show: '🎭',
    insurance: '🛡️',
    other: '📄'
  };
  return icons[category] || '📄';
}

// === MODALE RÉSERVATIONS ÉTAPE ===
function openBookingsModal(stepIdx, stepName) {
  // Récupérer les réservations
  let bookings = [];
  if (window.ORT_TRIP_DATA) {
    bookings = ORT_TRIP_DATA.getStepBookings(stepIdx) || [];
  } else if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
    bookings = globalBookingManager.getBookings(stepIdx) || [];
  }
  
  const lang = (localStorage.getItem('lang') || 'fr').slice(0,2);
  const I18N = {
    title: { fr: 'Réservations', en: 'Bookings', es: 'Reservas', it: 'Prenotazioni', pt: 'Reservas', ar: 'الحجوزات' },
    noBookings: { fr: 'Aucune réservation pour cette étape', en: 'No bookings for this step', es: 'Sin reservas para esta etapa', it: 'Nessuna prenotazione per questa tappa', pt: 'Sem reservas para esta etapa', ar: 'لا حجوزات لهذه المرحلة' },
    close: { fr: 'Fermer', en: 'Close', es: 'Cerrar', it: 'Chiudi', pt: 'Fechar', ar: 'إغلاق' },
    outbound: { fr: 'ALLER', en: 'OUTBOUND', es: 'IDA', it: 'ANDATA', pt: 'IDA', ar: 'ذهاب' },
    return: { fr: 'RETOUR', en: 'RETURN', es: 'VUELTA', it: 'RITORNO', pt: 'VOLTA', ar: 'عودة' },
    pickup: { fr: 'PRISE EN CHARGE', en: 'PICKUP', es: 'RECOGIDA', it: 'RITIRO', pt: 'RETIRADA', ar: 'استلام' },
    dropoff: { fr: 'RESTITUTION', en: 'DROPOFF', es: 'DEVOLUCIÓN', it: 'RICONSEGNA', pt: 'DEVOLUÇÃO', ar: 'تسليم' },
    duration: { fr: 'Durée', en: 'Duration', es: 'Duración', it: 'Durata', pt: 'Duração', ar: 'المدة' },
    mileage: { fr: 'Kilométrage', en: 'Mileage', es: 'Kilometraje', it: 'Chilometraggio', pt: 'Quilometragem', ar: 'المسافة' },
    fuel: { fr: 'Carburant', en: 'Fuel', es: 'Combustible', it: 'Carburante', pt: 'Combustível', ar: 'الوقود' },
    addToCalendar: { fr: '📅 Calendrier', en: '📅 Calendar', es: '📅 Calendario', it: '📅 Calendario', pt: '📅 Calendário', ar: '📅 التقويم' },
    addAllToCalendar: { fr: '📅 Tout ajouter au calendrier', en: '📅 Add all to calendar', es: '📅 Añadir todo al calendario', it: '📅 Aggiungi tutto al calendario', pt: '📅 Adicionar tudo ao calendário', ar: '📅 إضافة الكل للتقويم' }
  };
  const t = (key) => I18N[key]?.[lang] || I18N[key]?.fr || key;
  
  // Formater la durée
  const formatDuration = (minutes) => {
    if (!minutes) return '';
    const h = Math.floor(minutes / 60);
    const m = minutes % 60;
    return m > 0 ? `${h}h${String(m).padStart(2, '0')}` : `${h}h`;
  };
  
  // Stocker les bookings pour l'export calendrier
  window._currentModalBookings = bookings;
  
  // Générer le HTML des réservations
  let bookingsHTML = '';
  if (bookings.length === 0) {
    bookingsHTML = `<div style="text-align:center;padding:40px;color:#666">${t('noBookings')}</div>`;
  } else {
    bookings.forEach((b, bIdx) => {
      const icon = getCategoryIconForCell(b.category);
      let detailsHTML = '';
      
      // Détails spécifiques aux vols
      if (b.category === 'flight' && b.flights && b.flights.length > 0) {
        detailsHTML = '<div style="margin-top:10px;border-top:1px solid #e5e7eb;padding-top:10px">';
        b.flights.forEach(flight => {
          const typeLabel = flight.type === 'outbound' ? `✈️ ${t('outbound')}` : `✈️ ${t('return')}`;
          const route = `${flight.departure_city || '?'} (${flight.departure_airport || '?'}) → ${flight.arrival_city || '?'} (${flight.arrival_airport || '?'})`;
          
          detailsHTML += `
            <div style="margin-bottom:12px;padding:10px;background:#f0f9ff;border-radius:8px">
              <div style="font-weight:700;color:#1e40af;margin-bottom:6px">${typeLabel}</div>
              <div style="font-size:0.9rem;margin-bottom:4px">🛫 ${route}</div>
              ${flight.airline || flight.flight_number ? `<div style="font-size:0.85rem;color:#666">🔢 ${[flight.airline, flight.flight_number].filter(Boolean).join(' • ')}</div>` : ''}
              ${flight.departure_date || flight.departure_time ? `<div style="font-size:0.85rem;color:#666">🛫 Départ: ${[flight.departure_date, flight.departure_time ? 'à ' + flight.departure_time : ''].filter(Boolean).join(' ')}</div>` : ''}
              ${flight.arrival_date || flight.arrival_time ? `<div style="font-size:0.85rem;color:#666">🛬 Arrivée: ${[flight.arrival_date, flight.arrival_time ? 'à ' + flight.arrival_time : ''].filter(Boolean).join(' ')}${flight.arrival_date && flight.departure_date && flight.arrival_date !== flight.departure_date ? ' (+1j)' : ''}</div>` : ''}
              ${flight.duration_minutes ? `<div style="font-size:0.85rem;color:#666">⏱️ ${t('duration')}: ${formatDuration(flight.duration_minutes)}</div>` : ''}
            </div>
          `;
        });
        detailsHTML += '</div>';
      }
      
      // Détails spécifiques aux locations de voiture
      if (b.category === 'car_rental' && b.car_rental) {
        const car = b.car_rental;
        detailsHTML = `
          <div style="margin-top:10px;border-top:1px solid #e5e7eb;padding-top:10px">
            ${car.vehicle_model || car.vehicle_type ? `<div style="font-size:0.9rem;margin-bottom:8px">🚗 ${car.vehicle_model || car.vehicle_type}</div>` : ''}
            
            <div style="margin-bottom:8px;padding:8px;background:#f0fdf4;border-radius:6px">
              <div style="font-weight:600;color:#16a34a;margin-bottom:4px">📍 ${t('pickup')}</div>
              ${car.pickup_location ? `<div style="font-size:0.85rem">${car.pickup_location}</div>` : ''}
              ${car.pickup_date || car.pickup_time ? `<div style="font-size:0.85rem;color:#666">📅 ${[car.pickup_date, car.pickup_time ? 'à ' + car.pickup_time : ''].filter(Boolean).join(' ')}</div>` : ''}
            </div>
            
            <div style="margin-bottom:8px;padding:8px;background:#fef2f2;border-radius:6px">
              <div style="font-weight:600;color:#dc2626;margin-bottom:4px">📍 ${t('dropoff')}</div>
              ${car.dropoff_location ? `<div style="font-size:0.85rem">${car.dropoff_location}</div>` : ''}
              ${car.dropoff_date || car.dropoff_time ? `<div style="font-size:0.85rem;color:#666">📅 ${[car.dropoff_date, car.dropoff_time ? 'à ' + car.dropoff_time : ''].filter(Boolean).join(' ')}</div>` : ''}
            </div>
            
            ${car.included_km ? `<div style="font-size:0.85rem;color:#666">🛣️ ${t('mileage')}: ${car.included_km}</div>` : ''}
            ${car.fuel_policy ? `<div style="font-size:0.85rem;color:#666">⛽ ${t('fuel')}: ${car.fuel_policy}</div>` : ''}
          </div>
        `;
      }
      
      bookingsHTML += `
        <div style="background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:14px;margin-bottom:12px;box-shadow:0 1px 3px rgba(0,0,0,0.05)">
          <div style="display:flex;align-items:flex-start;gap:12px">
            <div style="font-size:1.8rem">${icon}</div>
            <div style="flex:1">
              <div style="font-weight:700;font-size:1rem;color:#1f2937">${b.name || 'Sans nom'}</div>
              ${b.provider ? `<div style="font-size:0.85rem;color:#6b7280">🏢 ${b.provider}</div>` : ''}
              ${b.date_start || b.date_end ? `<div style="font-size:0.85rem;color:#6b7280">📅 ${[b.date_start, b.date_end && b.date_end !== b.date_start ? '→ ' + b.date_end : ''].filter(Boolean).join(' ')}</div>` : ''}
              ${b.reference ? `<div style="font-size:0.85rem;color:#6b7280">🔖 Réf: ${b.reference}</div>` : ''}
              ${b.price ? `<div style="font-size:0.9rem;font-weight:600;color:#16a34a;margin-top:4px">💰 ${typeof b.price === 'object' ? b.price.amount : b.price} €</div>` : ''}
              ${b.address ? `<div style="font-size:0.85rem;color:#6b7280">📍 ${b.address}</div>` : ''}
              ${b.notes ? `<div style="font-size:0.85rem;color:#6b7280;font-style:italic;margin-top:4px">📝 ${b.notes}</div>` : ''}
            </div>
            <button onclick="addBookingToCalendar(${bIdx})" style="padding:6px 10px;background:#f0f9ff;color:#1e40af;border:1px solid #bfdbfe;border-radius:6px;cursor:pointer;font-size:0.8rem;white-space:nowrap" title="${t('addToCalendar')}">${t('addToCalendar')}</button>
          </div>
          ${detailsHTML}
        </div>
      `;
    });
  }
  
  // Créer la modale
  const modalId = 'stepBookingsModal';
  let modal = document.getElementById(modalId);
  if (modal) modal.remove();
  
  modal = document.createElement('div');
  modal.id = modalId;
  modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:9999;display:flex;align-items:center;justify-content:center;padding:20px';
  
  modal.innerHTML = `
    <div style="background:#f8fafc;border-radius:16px;max-width:500px;width:100%;max-height:85vh;display:flex;flex-direction:column;overflow:hidden">
      <div style="background:#113f7a;color:#fff;padding:16px 20px;display:flex;align-items:center;justify-content:space-between">
        <h2 style="margin:0;font-size:1.1rem">📋 ${t('title')} - ${stepName}</h2>
        <button onclick="document.getElementById('${modalId}').remove()" style="background:none;border:none;color:#fff;font-size:1.5rem;cursor:pointer;padding:0">×</button>
      </div>
      <div style="padding:16px;overflow-y:auto;flex:1">
        ${bookingsHTML}
      </div>
      <div style="padding:12px 16px;border-top:1px solid #e5e7eb;display:flex;gap:10px;justify-content:space-between">
        ${bookings.length > 0 ? `<button onclick="addAllBookingsToCalendar()" style="padding:10px 16px;background:#f0f9ff;color:#1e40af;border:1px solid #bfdbfe;border-radius:8px;cursor:pointer;font-weight:600;font-size:0.9rem">${t('addAllToCalendar')}</button>` : '<div></div>'}
        <button onclick="document.getElementById('${modalId}').remove()" style="padding:10px 24px;background:#113f7a;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:600">${t('close')}</button>
      </div>
    </div>
  `;
  
  // Fermer au clic sur le backdrop
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
  
  document.body.appendChild(modal);
}

// Fonction pour ajouter une réservation au calendrier
function addBookingToCalendar(bookingIdx) {
  const booking = window._currentModalBookings?.[bookingIdx];
  if (!booking) {
    console.warn('[CALENDAR] Réservation non trouvée');
    return;
  }
  
  if (window.ORT_CALENDAR) {
    ORT_CALENDAR.showCalendarMenu(booking, 1, event?.target);
  } else {
    // Fallback: générer un fichier ICS simple
    console.warn('[CALENDAR] Module ORT_CALENDAR non chargé, fallback...');
    const title = booking.name || 'Réservation';
    const start = booking.date_start || '';
    const end = booking.date_end || start;
    
    if (!start) {
      alert('Pas de date pour cette réservation');
      return;
    }
    
    // Lien Google Calendar
    const googleUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${encodeURIComponent(title)}&dates=${start.replace(/-/g, '')}/${end.replace(/-/g, '')}&details=${encodeURIComponent(booking.reference ? 'Réf: ' + booking.reference : '')}`;
    window.open(googleUrl, '_blank');
  }
}

// Fonction pour ajouter toutes les réservations au calendrier
function addAllBookingsToCalendar() {
  const bookings = window._currentModalBookings || [];
  if (bookings.length === 0) return;
  
  if (window.ORT_CALENDAR) {
    // Créer un map simulé pour l'export
    const stepBookingsMap = {};
    bookings.forEach((b, i) => {
      stepBookingsMap[`booking_${i}`] = { booking: b, steps: [0], firstStepIndex: 0 };
    });
    
    const result = ORT_CALENDAR.exportAllBookings([], stepBookingsMap, window.state?.title || 'Voyage');
    if (result && result.ics) {
      ORT_CALENDAR.downloadICS(result.ics, 'reservations.ics');
    }
  } else {
    alert('Module calendrier non disponible');
  }
}




// === SIDs uniques & stables ===
function __collectSids(){
  const set = new Set();
  (window.state?.steps||[]).forEach(s=>{ if(s && s.__sid) set.add(s.__sid); });
  return set;
}
function __nextSid(){
  const used = __collectSids();
  let n = 1;
  while(used.has(`D${String(n).padStart(2,'0')}`)) n++;
  return `D${String(n).padStart(2,'0')}`;
}
function ensureSid(step){
  if(!step) return null;
  if(step.__sid && !__collectSids().has(step.__sid)) return step.__sid;
  // (ré)assigne un SID jamais utilisé
  const sid = __nextSid();
  step.__sid = sid;
  return sid;
}

// ➜ AJOUT : parse JSON tolérant (utilisé plus bas pour les objets TEMP)
function safeJSONParse(str){
  try{ return str ? JSON.parse(str) : null; }
  catch(e){ return null; }
}

// --- Traduction du titre #rtTitle ---
// NOTE: Les itinéraires sont maintenant pré-traduits, pas besoin d'API de traduction
function setTitleTranslated(raw){
  const el = document.getElementById('rtTitle');
  if(!el){ return; }
  
  // Supprimer data-i18n pour éviter que applyI18N() écrase le titre
  el.removeAttribute('data-i18n');
  
  // Affiche directement le titre (déjà traduit dans les données)
  el.textContent = raw || '';
}

// === Layout buttons init (header uniquement) ===
(function initLayoutButtons(){
  const body = document.body;
  const saved = localStorage.getItem('ort.layout') || 'side';
  body.classList.toggle('layout-stack', saved === 'stack');
  body.classList.toggle('layout-side',  saved === 'side');

  const sideBtn  = document.getElementById('layoutSideBtn');
  const stackBtn = document.getElementById('layoutStackBtn');

  function reflect(next){
    const isStack = next === 'stack';
    sideBtn?.setAttribute('aria-pressed', (!isStack).toString());
    stackBtn?.setAttribute('aria-pressed', (isStack).toString());
  }
  reflect(saved);

  function apply(next){
    body.classList.toggle('layout-stack', next === 'stack');
    body.classList.toggle('layout-side',  next === 'side');
    localStorage.setItem('ort.layout', next);
    reflect(next);
    setTimeout(()=>{ window.map?.invalidateSize?.(); }, 60);
  }

  sideBtn?.addEventListener('click', ()=> apply('side'));
  stackBtn?.addEventListener('click', ()=> apply('stack'));
})();

/* === Toggle carte plein écran (persisté) === */
(function initMapFullscreen(){
  const body = document.body;
  const btnFull = document.getElementById('btnMapFull');
  const btnExit = document.getElementById('btnMapExit');

  // I18N tooltip pour le plein écran
  const LANG = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  const FULLSCREEN_HELP = {
    fr: "Vous passez en plein écran. Survolez une étape pour voir son descriptif. Cliquez pour définir l'ordre (1→n). Double-cliquez pour retirer une étape. Utilisez \"Valider\" pour appliquer les changements, ou \"Quitter\" pour annuler.",
    en: "You are entering fullscreen. Hover a step to see its description. Click to set order (1→n). Double-click to remove a step. Use \"Validate\" to apply changes, or \"Exit\" to cancel.",
    it: "Passi a schermo intero. Passa il mouse su una tappa per vederne la descrizione. Clicca per definire l'ordine (1→n). Doppio clic per rimuovere una tappa. Usa \"Conferma\" per applicare le modifiche, o \"Esci\" per annullare.",
    es: "Pasas a pantalla completa. Pasa el ratón sobre una etapa para ver su descripción. Haz clic para definir el orden (1→n). Doble clic para eliminar una etapa. Usa \"Validar\" para aplicar los cambios, o \"Salir\" para cancelar.",
    pt: "Você está entrando em tela cheia. Passe o mouse sobre uma etapa para ver sua descrição. Clique para definir a ordem (1→n). Clique duas vezes para remover uma etapa. Use \"Validar\" para aplicar as alterações ou \"Sair\" para cancelar.",
    ar: "أنت تدخل وضع ملء الشاشة. مرر فوق خطوة لرؤية وصفها. انقر لتحديد الترتيب (1→n). انقر مرتين لإزالة خطوة. استخدم \"تأكيد\" لتطبيق التغييرات، أو \"خروج\" للإلغاء."
  };
  
  if (btnFull) {
    btnFull.title = FULLSCREEN_HELP[LANG] || FULLSCREEN_HELP.fr;
  }

  function applyView(mode){
    // mode: 'map' | 'normal'
    const mapOnly = (mode === 'map');
    body.classList.toggle('view-map-only', mapOnly);
    // on ne touche pas à 'view-itin-only' ici
    if (btnFull) btnFull.style.display = mapOnly ? 'none' : '';
    if (btnExit) btnExit.style.display = mapOnly ? '' : 'none';
localStorage.setItem('ort.view', mapOnly ? 'map' : 'normal');
    
    // Recalcule le sizing Leaflet pour éviter les tuiles "grises"
    // Multiple invalidations avec délais progressifs pour gérer les transitions CSS
    if (window.map?.invalidateSize) {
      // IMPORTANT : Forcer un reflow du DOM avant invalidateSize
      const mapContainer = document.getElementById('map');
      if (mapContainer) {
        // Force le navigateur à recalculer les dimensions CSS
        void mapContainer.offsetHeight;
      }
      
      // Immédiat - démarre le recalcul
      window.map.invalidateSize({pan: false});
      // Après transition CSS initiale (100ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 100);
      // Après transition CSS complète (250ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 250);
      // Final - surtout important en mode côte-à-côte (400ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 400);
      // Extra sécurité (800ms)
      setTimeout(()=> window.map.invalidateSize({pan: false}), 800);
    }
  }

  // Restauration (si l'utilisateur a déjà activé le plein écran)
  const saved = localStorage.getItem('ort.view') || 'normal';
  applyView(saved);

  btnFull?.addEventListener('click', ()=> applyView('map'));
  btnExit?.addEventListener('click', ()=> applyView('normal'));

  // Échap = quitter plein écran carte
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && body.classList.contains('view-map-only')){
      applyView('normal');
    }
  });

  // Revalide la taille à chaque resize (utile en mobile/orientation)
  window.addEventListener('resize', ()=> {
    if (window.map?.invalidateSize) window.map.invalidateSize();
  });

  // ✅ PATCH : Forcer redimensionnement après sortie plein écran
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      console.log('[MAP] Sortie plein écran → recalcul taille forcé');
      if (window.map?.invalidateSize) {
        let count = 0;
        const fixInterval = setInterval(() => {
          window.map.invalidateSize();
          count++;
          if (count >= 6) clearInterval(fixInterval);
        }, 150);
      }
    }
  });
})();
(function waitForLeaflet(){
  if(typeof L!=='undefined'){
    console.log('✅ Leaflet chargé');
    initApp();
  }else{
    console.log('⏳ Attente Leaflet...');
    setTimeout(waitForLeaflet,100);
  }
})();

function initApp(){
// === VÉRIFICATION MODE PARTAGÉ ===
(async function checkShareMode(){
  const shareToken = new URLSearchParams(location.search).get('share');
  if (!shareToken) return;
  
  console.log('[SHARE] Mode partagé détecté, token:', shareToken);
  
  // Afficher indicateur de chargement
  const loadingBanner = document.createElement('div');
  loadingBanner.id = 'shareLoadingBanner';
  loadingBanner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#3b82f6;color:#fff;padding:10px;text-align:center;z-index:10001;font-weight:600';
  loadingBanner.textContent = '⏳ Chargement du voyage partagé...';
  document.body.appendChild(loadingBanner);
  
  try {
    // Attendre Firebase
    await new Promise(resolve => {
      if (window.firebase?.firestore) resolve();
      else setTimeout(resolve, 1000);
    });
    
    if (typeof ORT_SHARE !== 'undefined') {
      const sharedData = await ORT_SHARE.checkSharedAccess();
      if (sharedData) {
        console.log('[SHARE] ✅ Trip chargé, mode:', sharedData.mode);
        
        // Stocker les données pour le chargement
        window._sharedTripData = sharedData;
        
        // Afficher le mode
        loadingBanner.innerHTML = sharedData.mode === 'viewer' 
          ? '👁️ Mode lecture seule' 
          : '✏️ Mode modification';
        loadingBanner.style.background = sharedData.mode === 'viewer' ? '#f59e0b' : '#16a34a';
        
        // Masquer après 3s
        setTimeout(() => loadingBanner.remove(), 3000);
        
        // Désactiver édition si viewer
        if (sharedData.mode === 'viewer') {
          document.body.classList.add('shared-view-only');
          // Masquer boutons d'édition
          setTimeout(() => {
            document.querySelectorAll('#btnSave, #btnAddStep, #btnAddMapStep, .delete-btn, .edit-btn').forEach(el => {
              el.style.display = 'none';
            });
          }, 100);
        }
      } else {
        loadingBanner.innerHTML = '❌ Lien invalide ou expiré';
        loadingBanner.style.background = '#dc2626';
        setTimeout(() => loadingBanner.remove(), 5000);
      }
    }
  } catch(e) {
    console.error('[SHARE] Erreur:', e);
    loadingBanner.remove();
  }
})();

window.closeMapPopup=()=>{
  window.popupLocked = false; // déverrouille si on clique sur ✕
  document.getElementById('mapPopup').classList.remove('show');
};

const $=s=>document.querySelector(s);
const $$=s=>Array.from(document.querySelectorAll(s));
const qs=new URLSearchParams(location.search);
const RT_KEY=qs.get('rtKey')||'';
// Extraire CC depuis cc param, sinon depuis rtKey (format: CC_slug_timestamp)
const CC=(qs.get('cc')||RT_KEY.split('_')[0]||'').toUpperCase();
const ITIN_ID=decodeURIComponent(qs.get('itin')||'');
const TEMP_MODE=qs.get('from')==='temp';
const BUILDER_MODE=qs.get('mode')==='builder' || qs.get('from')==='builder' || qs.get('builder')==='1';
const REQUESTED_DAYS=parseInt(qs.get('jours')||qs.get('days')||qs.get('nbDays')||'0', 10); // Nombre de jours demandé
// Lire la date de départ depuis l'URL (departure=YYYY-MM-DD) ou localStorage
const URL_DEPARTURE = qs.get('departure') || '';

let PHOTOS_CACHE={};
const state={
  title:'Roadtrip', country:'XX', targetNights:0, steps:[],
  _rawItinsObj:null, _rawPlacesObj:null, distanceUnit:'km',
  startDateStr: URL_DEPARTURE || localStorage.getItem('ort.rtStartDate') || '',
  requestedDays: REQUESTED_DAYS // Stocker pour référence
};

let TOTALS={km:0, minutes:0, travelDays:0};

const sumNights = ()=> state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
const fmtKm = (km)=> state.distanceUnit==='mi' ? `${Math.round(km*0.621371)} mi` : `${km} km`;
const fmtDur = (min)=>{ const h=Math.floor(min/60), m=min%60; return `${h} h ${m} min`; };

// === Dates (point de départ + plage par étape)
function getStartDate(){
  const s = (state.startDateStr || '').trim();
  return s ? new Date(s+'T00:00:00') : null;
}
function addDays(d,n){ const x=new Date(d); x.setDate(x.getDate()+n); return x; }
function fmtD(d){
  if(!d) return '—';
  const lang=(document.documentElement.lang||'fr');
  return d.toLocaleDateString(lang, { day:'2-digit', month:'short' });
}
function stepDateRange(idx){
  const base = getStartDate();
  if(!base) return null;
  let offset = 0;
  for(let i=0;i<idx;i++){ offset += Number(state.steps[i]?.nights||0); }
  const n = Number(state.steps[idx]?.nights||0);
  const start = addDays(base, offset);
  const end   = addDays(start, Math.max(0, n-1));
  return {start, end};
}
// Tooltip i18n compact
function dateTipLabel(){
  const lang=(document.documentElement.lang||'fr').slice(0,2);
  const MAP={
    fr:'Première/dernière nuit',
    en:'First/last night',
    it:'Prima/ultima notte',
    es:'Primera/última noche',
    pt:'Primeira/última noite',
    ar:'أول/آخر ليلة'
  };
  return MAP[lang]||MAP.fr;
}

// === CALCUL DISTANCE HAVERSINE ===
function haversineDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}


// === ROUTE BUILDER: Code externalisé dans /js/ort-route-builder.js ===

// === CALCUL AUTOMATIQUE DES NUITS (groupement hôtels) ===
function autoCalculateNights(targetNights) {
  if (!state.steps || state.steps.length === 0) return;
  
  const steps = state.steps;
  const n = steps.length;
  
  // Ratio de compression basé sur les nuits cibles
  const totalSuggested = steps.reduce((s, st) => s + (st._suggestedDays || 1), 0);
  const ratio = targetNights > 0 ? targetNights / totalSuggested : 1;
  
  console.log('[NIGHTS] Calcul automatique - Target:', targetNights, 'Ratio:', ratio.toFixed(2));
  
  // === ÉTAPE 1: Identifier les hubs potentiels ===
  const avgRating = steps.reduce((s, st) => s + (st.rating || 5), 0) / n;
  const sortedByDays = [...steps].sort((a, b) => (b._suggestedDays || 1) - (a._suggestedDays || 1));
  const top30Index = Math.max(0, Math.floor(n * 0.3) - 1);
  const top30Threshold = sortedByDays[top30Index]?._suggestedDays || 1;
  
  const hubs = [];
  steps.forEach((step, idx) => {
    const suggested = step._suggestedDays || 1;
    const rating = step.rating || 5;
    const isHub = suggested >= Math.min(1.5, top30Threshold) && rating >= avgRating;
    step._isHub = isHub;
    step._satellites = [];
    if (isHub) hubs.push(idx);
  });
  
  console.log('[NIGHTS] Hubs identifiés:', hubs.map(i => steps[i].name).join(', '));
  
  // === HUB PAR DÉFAUT SI AUCUN DÉTECTÉ ===
  if(hubs.length === 0 && steps.length > 0){
    let bestIdx = 0;
    let bestRating = steps[0].rating || 0;
    steps.forEach((s, idx) => {
      if((s.rating || 0) > bestRating){
        bestRating = s.rating || 0;
        bestIdx = idx;
      }
    });
    
    steps[bestIdx]._isHub = true;
    steps[bestIdx]._hubGroup = bestIdx;
    steps[bestIdx]._satellites = [];
    hubs.push(bestIdx);
    console.log(`[NIGHTS] ⚠️ Aucun hub naturel → "${steps[bestIdx].name}" promu hub par défaut (rating=${bestRating.toFixed(1)})`);
  }
  
  // === ÉTAPE 2: Fusion des hubs consécutifs (< 30km) ===
  const HUB_MERGE_DISTANCE = 30;
  
  for (let i = 0; i < hubs.length - 1; i++) {
    const hub1 = steps[hubs[i]];
    const hub2 = steps[hubs[i + 1]];
    
    if (hub1.lat && hub1.lon && hub2.lat && hub2.lon) {
      const dist = haversineDistance(hub1.lat, hub1.lon, hub2.lat, hub2.lon);
      
      if (dist < HUB_MERGE_DISTANCE) {
        // Priorité au rating, puis au temps de visite si égalité
        const rating1 = hub1.rating || 3;
        const rating2 = hub2.rating || 3;
        const days1 = hub1._suggestedDays || 1;
        const days2 = hub2._suggestedDays || 1;
        const hub1Wins = rating1 > rating2 || (rating1 === rating2 && days1 >= days2);
        
        if (hub1Wins) {
          hub2._isHub = false;
          hub2._mergedInto = hubs[i];
          console.log(`[NIGHTS] Fusion: "${hub2.name}" (${rating2}★, ${days2}j) → absorbé par "${hub1.name}" (${rating1}★, ${days1}j, ${dist.toFixed(1)}km)`);
        } else {
          hub1._isHub = false;
          hub1._mergedInto = hubs[i + 1];
          console.log(`[NIGHTS] Fusion: "${hub1.name}" (${rating1}★, ${days1}j) → absorbé par "${hub2.name}" (${rating2}★, ${days2}j, ${dist.toFixed(1)}km)`);
        }
      }
    }
  }
  
  // === ÉTAPE 3: Rattachement des satellites adjacents ===
  const PROXIMITY_MAX_KM = 45;
  
  steps.forEach((step, idx) => {
    if (step._isHub || step._mergedInto !== undefined) return;
    
    // Chercher hub PRÉCÉDENT
    let hubBefore = null;
    for (let h = idx - 1; h >= 0; h--) {
      if (steps[h]._mergedInto !== undefined) {
        hubBefore = steps[h]._mergedInto;
        break;
      }
      if (steps[h]._isHub) {
        hubBefore = h;
        break;
      }
    }
    
    // Chercher hub SUIVANT
    let hubAfter = null;
    for (let h = idx + 1; h < n; h++) {
      if (steps[h]._mergedInto !== undefined) {
        hubAfter = steps[h]._mergedInto;
        break;
      }
      if (steps[h]._isHub) {
        hubAfter = h;
        break;
      }
    }
    
    // Calculer distances
    let distBefore = Infinity, distAfter = Infinity;
    if (hubBefore !== null && step.lat && step.lon && steps[hubBefore].lat && steps[hubBefore].lon) {
      distBefore = haversineDistance(step.lat, step.lon, steps[hubBefore].lat, steps[hubBefore].lon);
    }
    if (hubAfter !== null && step.lat && step.lon && steps[hubAfter].lat && steps[hubAfter].lon) {
      distAfter = haversineDistance(step.lat, step.lon, steps[hubAfter].lat, steps[hubAfter].lon);
    }
    
    // Rattacher au plus proche si < seuil
    const minDist = Math.min(distBefore, distAfter);
    if (minDist < PROXIMITY_MAX_KM) {
      const hubIdx = distBefore <= distAfter ? hubBefore : hubAfter;
      
      // NOUVELLE RÈGLE: satellite si < 20km ET <= 2 jours
      const stepRating = step.rating || 3;
      const stepDays = step._suggestedDays || 1;
      const GROUPING_DISTANCE = 30;
      const GROUPING_MAX_DAYS = 2;
      const canBeSatellite = minDist < GROUPING_DISTANCE && stepDays <= GROUPING_MAX_DAYS;
      
      if(!canBeSatellite){
        // Lieu trop important ou trop éloigné → hub indépendant
        step._isHub = true;
        step._satellites = [];
        console.log('[NIGHTS]', step.name, '(', stepRating, '★,', stepDays, 'j) → hub indépendant');
      } else {
        step._isSatellite = true;
        step._hubGroup = hubIdx;
        steps[hubIdx]._satellites.push(idx);
        console.log('[NIGHTS]', step.name, '(', stepDays, 'j) → satellite de', steps[hubIdx].name, '(', minDist.toFixed(1), 'km)');
      }
    }
  });
  
  // === ÉTAPE 3b: Rattachement des étapes TRÈS PROCHES (< 15km) ===
  const VERY_CLOSE_THRESHOLD = 15;
  
  steps.forEach((step, idx) => {
    if (step._isHub || step._isSatellite || step._mergedInto !== undefined) return;
    
    let closestHub = null, closestDist = Infinity;
    
    steps.forEach((h, hIdx) => {
      if (!h._isHub) return;
      if (h.lat && h.lon && step.lat && step.lon) {
        const dist = haversineDistance(step.lat, step.lon, h.lat, h.lon);
        if (dist < closestDist) {
          closestDist = dist;
          closestHub = hIdx;
        }
      }
    });
    
    if (closestHub !== null && closestDist < VERY_CLOSE_THRESHOLD) {
      // NOUVELLE RÈGLE: satellite si < 20km ET <= 2 jours
      const stepRating = step.rating || 3;
      const stepDays = step._suggestedDays || 1;
      const GROUPING_DISTANCE = 30;
      const GROUPING_MAX_DAYS = 2;
      const canBeSatellite = closestDist < GROUPING_DISTANCE && stepDays <= GROUPING_MAX_DAYS;
      
      if(!canBeSatellite){
        // Lieu trop important → hub indépendant
        step._isHub = true;
        step._satellites = [];
        console.log('[NIGHTS]', step.name, '(', stepRating, '★,', stepDays, 'j) → hub indépendant (très proche mais > 2j)');
      } else {
        step._isSatellite = true;
        step._hubGroup = closestHub;
        steps[closestHub]._satellites.push(idx);
        console.log('[NIGHTS]', step.name, '(', stepDays, 'j) → satellite de', steps[closestHub].name, '(très proche:', closestDist.toFixed(1), 'km)');
      }
    }
  });
  
  // === ÉTAPE 4: Calculer les nuits ===
  steps.forEach((step, idx) => {
    const rawDays = (step._suggestedDays || 1) * ratio;
    
    if (step._isSatellite) {
      step.nights = 0;
    } else if (step._isHub) {
      const satellites = step._satellites || [];
      const satelliteDays = satellites.reduce((s, i) => s + (steps[i]._suggestedDays || 1), 0);
      const totalDays = ((step._suggestedDays || 1) + satelliteDays) * ratio;
      step.nights = Math.max(1, Math.ceil(totalDays));
    } else if (step._mergedInto !== undefined) {
      step.nights = 0;
    } else {
      step.nights = Math.max(1, Math.round(rawDays));
    }
  });
  
  // Log résultat
  const totalNightsResult = steps.reduce((s, st) => s + (st.nights || 0), 0);
  console.log('[NIGHTS] Résultat:', totalNightsResult, 'nuits');
  
  return totalNightsResult;
}

// === GROUPEMENT AUTOMATIQUE DES HÔTELS ===

// === MODE PLEIN ÉCRAN LISTE ===
function applyListView(mode) {
  const listOnly = mode === 'list';
  const body = document.body;
  
  if (listOnly) {
    // S'assurer que le mode carte n'est pas actif
    body.classList.remove('view-map-only');
    const btnMapFull = document.getElementById('btnMapFull');
    const btnMapExit = document.getElementById('btnMapExit');
    if (btnMapFull) btnMapFull.style.display = '';
    if (btnMapExit) btnMapExit.style.display = 'none';
    
    // Masquer le header principal
    const mainHeader = document.querySelector('header');
    if (mainHeader) mainHeader.style.display = 'none';
    
    // Créer header compact plein écran
    let fullHeader = document.getElementById('listFullHeader');
    if (!fullHeader) {
      fullHeader = document.createElement('div');
      fullHeader.id = 'listFullHeader';
      fullHeader.style.cssText = 'position:fixed;top:0;left:0;right:0;height:42px;background:linear-gradient(135deg,#113f7a 0%,#1a5298 100%);color:#fff;display:flex;align-items:center;justify-content:space-between;z-index:10001;font-weight:600;font-size:0.95rem;padding:0 16px;box-shadow:0 2px 10px rgba(0,0,0,0.2);';
      document.body.appendChild(fullHeader);
    }
    
    const title = state?.title || 'Itinéraire';
    const stepsCount = state?.steps?.length || 0;
    const totalNights = state?.steps?.reduce((s, x) => s + (x.nights || 0), 0) || 0;
    const totalKm = TOTALS?.km || 0;
    
    fullHeader.innerHTML = `
      <span style="display:flex;align-items:center;gap:12px;">
        <span style="font-weight:800;">${title}</span>
        <span style="opacity:0.85;font-size:0.85rem;">${stepsCount} étapes · ${totalNights} nuits · ${totalKm} km</span>
      </span>
      <button id="btnListExitHeader" style="background:rgba(255,255,255,0.95);color:#113f7a;border:none;padding:8px 16px;font-size:14px;font-weight:700;border-radius:6px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:all 0.2s;">⤡ Réduire</button>
    `;
    fullHeader.style.display = 'flex';
    
    // Handler bouton réduire
    fullHeader.querySelector('#btnListExitHeader')?.addEventListener('click', () => applyListView('normal'));
    
    // Ajuster le padding top de la section
    const section = document.querySelector('.main > section');
    if (section) section.style.paddingTop = '50px';
    
    // Masquer le bouton Liste dans la toolbar
    const btnListFull = document.getElementById('btnListFull');
    if (btnListFull) btnListFull.style.display = 'none';
    
  } else {
    // Restaurer le header principal
    const mainHeader = document.querySelector('header');
    if (mainHeader) mainHeader.style.display = '';
    
    // Masquer le header compact
    const fullHeader = document.getElementById('listFullHeader');
    if (fullHeader) fullHeader.style.display = 'none';
    
    // Restaurer le padding
    const section = document.querySelector('.main > section');
    if (section) section.style.paddingTop = '';
    
    // Réafficher le bouton Liste
    const btnListFull = document.getElementById('btnListFull');
    if (btnListFull) btnListFull.style.display = '';
  }
  
  body.classList.toggle('view-itin-only', listOnly);
  
  // Réordonner les lignes pour affichage colonne par colonne
  const rows = document.querySelectorAll('#rows .step-row');
  const n = rows.length;
  const half = Math.ceil(n / 2);
  
  rows.forEach((row, i) => {
    if (listOnly && n > 1) {
      // Colonne par colonne : 1,2,3... en col1 puis n/2+1,n/2+2... en col2
      if (i < half) {
        row.style.order = i * 2;
      } else {
        row.style.order = (i - half) * 2 + 1;
      }
    } else {
      row.style.order = '';
    }
  });
  
  localStorage.setItem('ort.listView', listOnly ? 'list' : 'normal');
  
  // Recalcule Leaflet quand on quitte le plein écran liste
  if (!listOnly && window.map?.invalidateSize) {
    setTimeout(() => window.map.invalidateSize({pan: false}), 100);
    setTimeout(() => window.map.invalidateSize({pan: false}), 300);
  }
  
  console.log('[LIST] Mode:', mode);
}

// Échap = quitter plein écran liste
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && document.body.classList.contains('view-itin-only')) {
    applyListView('normal');
  }
});

window.applyListView = applyListView;
window.haversineDistance = haversineDistance;
window.autoCalculateNights = autoCalculateNights;

async function loadPhotosJSON(){
  try{
    const r=await fetch('./data/photos-json/photos_lieux.json',{cache:'no-store'});
    if(r.ok) PHOTOS_CACHE=await r.json()||{};
  }catch(e){console.error('Photos:',e)}
}

function getPhotosForPlace(pid){return (PHOTOS_CACHE[pid]||{}).photos||[]}

// Récupère les photos pour une étape en priorisant les photos utilisateur
function getPhotosForStep(stepIndex, pid) {
  // 1. Priorité aux photos utilisateur si ORT_TRIP_DATA est disponible
  if (window.ORT_TRIP_DATA) {
    const userPhotos = ORT_TRIP_DATA.getStepPhotos(stepIndex);
    if (userPhotos && userPhotos.length > 0) {
      // Combiner: userPhotos d'abord, puis compléter avec photos catalogue
      const catalogPhotos = getPhotosForPlace(pid) || [];
      const combined = [...userPhotos];
      // Ajouter les photos catalogue qui ne sont pas déjà présentes
      catalogPhotos.forEach(p => {
        if (!combined.includes(p)) combined.push(p);
      });
      return combined;
    }
  }
  // 2. Fallback: photos du catalogue
  return getPhotosForPlace(pid) || [];
}

// Convertir un nom en slug pour matcher les place_id (format CC::nom-en-slug)
function toSlug(name) {
  if (!name) return '';
  return name
    .toLowerCase()
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .replace(/['']/g, '-')
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9-]/g, '')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

// Trouver les photos pour un lieu (essaie plusieurs formats de clé)
function findPhotosForPlace(name, cc) {
  if (!name || !PHOTOS_CACHE) return [];
  
  const slug = toSlug(name);
  const ccUp = (cc || '').toUpperCase();
  
  const keys = [
    `${ccUp}::${slug}`,
    `${ccUp}::${name.toLowerCase()}`,
    slug,
    name.toLowerCase()
  ];
  
  for (const key of keys) {
    if (PHOTOS_CACHE[key]?.photos?.length) {
      return PHOTOS_CACHE[key].photos;
    }
  }
  
  // Recherche partielle par nom
  const found = Object.keys(PHOTOS_CACHE).find(k => {
    const kName = k.split('::').pop() || k;
    return kName === slug || kName.includes(slug) || slug.includes(kName);
  });
  
  if (found && PHOTOS_CACHE[found]?.photos?.length) {
    return PHOTOS_CACHE[found].photos;
  }
  
  return [];
}

// Navigation du carrousel de photos
function carouselNav(carouselId, direction) {
  const carousel = document.getElementById(carouselId);
  if (!carousel) return;
  
  const slides = carousel.querySelectorAll('.carousel-slide');
  const dots = carousel.querySelectorAll('.carousel-dot');
  const counter = carousel.querySelector('.carousel-counter');
  const total = parseInt(carousel.dataset.total) || slides.length;
  let current = parseInt(carousel.dataset.current) || 0;
  
  // Cacher la slide actuelle
  slides[current]?.classList.remove('active');
  dots[current]?.classList.remove('active');
  
  // Calculer la nouvelle position
  current = (current + direction + total) % total;
  carousel.dataset.current = current;
  
  // Afficher la nouvelle slide
  slides[current]?.classList.add('active');
  dots[current]?.classList.add('active');
  
  // Mettre à jour le compteur
  if (counter) counter.textContent = `${current + 1}/${total}`;
}
window.carouselNav = carouselNav;

// Navigation du carrousel popup
function carouselNavPopup(direction) {
  const carousel = document.getElementById('popup-carousel');
  if (!carousel) return;
  
  const slides = carousel.querySelectorAll('.carousel-slide');
  const dots = carousel.querySelectorAll('.carousel-dot');
  const counter = carousel.querySelector('.carousel-counter');
  const total = parseInt(carousel.dataset.total) || slides.length;
  let current = parseInt(carousel.dataset.current) || 0;
  
  slides[current]?.classList.remove('active');
  dots[current]?.classList.remove('active');
  
  current = (current + direction + total) % total;
  carousel.dataset.current = current;
  
  slides[current]?.classList.add('active');
  dots[current]?.classList.add('active');
  
  if (counter) counter.textContent = `${current + 1}/${total}`;
}
window.carouselNavPopup = carouselNavPopup;

// Navigation par clic sur les dots
document.addEventListener('click', (e) => {
  if (e.target.classList.contains('carousel-dot')) {
    const carousel = e.target.closest('.step-photos-carousel') || e.target.closest('#popup-carousel');
    if (!carousel) return;
    
    const targetIdx = parseInt(e.target.dataset.index);
    const current = parseInt(carousel.dataset.current) || 0;
    const diff = targetIdx - current;
    
    if (diff !== 0) {
      // Popup carousel
      if (carousel.id === 'popup-carousel') {
        carouselNavPopup(diff);
      } else {
        // Step details carousel
        carouselNav(carousel.id, diff);
      }
    }
  }
});

// Cache des traductions pour éviter les appels API répétés
let TRANSLATIONS_CACHE = {};
try {
  const cached = localStorage.getItem('ort.translations_cache');
  if (cached) {
    TRANSLATIONS_CACHE = JSON.parse(cached);
    console.log('[TRANSLATIONS] Cache chargé:', Object.keys(TRANSLATIONS_CACHE).length, 'traductions');
  }
} catch(e) {
  console.warn('[TRANSLATIONS] Erreur chargement cache:', e);
  TRANSLATIONS_CACHE = {};
}

// Fonction helper pour générer une clé de cache unique
function getTranslationCacheKey(text, fromLang, toLang) {
  // Hash simple du texte + langues pour créer une clé unique
  const str = `${text}::${fromLang}::${toLang}`;
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return `tr_${Math.abs(hash)}`;
}

// Fonction helper pour sauvegarder le cache
function saveTranslationCache() {
  try {
    // Limiter la taille du cache (garder les 500 traductions les plus récentes)
    const entries = Object.entries(TRANSLATIONS_CACHE);
    if (entries.length > 500) {
      // Garder seulement les 500 dernières
      const recent = entries.slice(-500);
      TRANSLATIONS_CACHE = Object.fromEntries(recent);
    }
    localStorage.setItem('ort.translations_cache', JSON.stringify(TRANSLATIONS_CACHE));
  } catch(e) {
    console.warn('[TRANSLATIONS] Erreur sauvegarde cache:', e);
  }
}

// --- DEBUG POPUP PHOTOS ---
async function ensurePhotos(place) {
  console.log('[ensurePhotos] place', place);
  const cache = (window.photosLieux = window.photosLieux || {});
  const hit = cache[place.place_id]?.photos || [];
  if (hit.length >= 2) {
    console.log('[ensurePhotos] cache hit', hit.length);
    return hit;
  }

  try {
    const q = new URLSearchParams({
      country: (place.place_id || '').split('::')[0],
      place_id: place.place_id,
      name: place.name || place.title || (place.place_id || '').split('::').pop()
    });
    const apiUrl = (localStorage.ORT_PHOTOS_API || 'http://localhost:8057') + '/photos/place?' + q.toString();
    console.log('[ensurePhotos] fetch', apiUrl);
    const r = await fetch(apiUrl, { cache: 'no-store' });
    const d = await r.json().catch(e => {
      console.error('[ensurePhotos] JSON parse error', e);
      return { ok: false };
    });
    console.log('[ensurePhotos] response', d);

    if (d.ok && Array.isArray(d.photos) && d.photos.length >= 2) {
      cache[place.place_id] = { name: place.name || '', photos: d.photos };
      return d.photos;
    }
    return hit;
  } catch (err) {
    console.error('[ensurePhotos] fetch failed', err);
    return hit;
  }
}

async function renderPopup(place) {
  try {
    const step = place; // normalise: les blocs "visits/activities" lisent `step`
    console.log('[renderPopup] start', place);
    let photos = (window.photosLieux && window.photosLieux[place.place_id]?.photos) || [];
    if (photos.length < 2) photos = await ensurePhotos(place);
    console.log('[renderPopup] photos', photos);
    fillPhotos(photos);
  } catch (e) {
    console.error('[renderPopup] error', e);
  }
}


async function loadJSON(path){
  try{
    const r=await fetch(path,{cache:'no-store'});
    if(!r.ok) return null;
    const ct = r.headers.get('content-type')||'';
    if(!ct.includes('application/json')) {
      console.warn('[loadJSON] Not JSON:', path, 'content-type:', ct);
      return null;
    }
    return await r.json();
  }catch(e){console.error('[loadJSON] Error:',path,e);return null}
}

function isComposedId(id){return typeof id==='string'&&id.startsWith('COMPOSED::')}
function parseComposedIds(id){if(!isComposedId(id))return[];return id.replace('COMPOSED::','').split('+').map(decodeURIComponent).filter(Boolean)}
// Détection du mode tactile
const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints>0);

let PLACES_INDEX=null;
// === Expose globals pour les scripts header (date de départ etc.)
window.state = state;

// === Fonction helper pour charger avec fallback langue ===
async function loadWithLangFallback(baseUrl, lang) {
  // Essayer dans l'ordre : langue demandée → EN → FR → ancien format
  const langOrder = [lang, 'en', 'fr'].filter((v, i, a) => a.indexOf(v) === i); // unique
  
  for (const tryLang of langOrder) {
    const url = baseUrl.replace('.json', `-${tryLang}.json`);
    const result = await loadJSON(url);
    if (result) {
      console.log(`[LOAD] ✅ Chargé: ${url}`);
      return { data: result, lang: tryLang };
    }
  }
  
  // Fallback: ancien format sans suffixe
  const result = await loadJSON(baseUrl);
  if (result) {
    console.log(`[LOAD] ⚠️ Fallback ancien format: ${baseUrl}`);
    return { data: result, lang: 'fr' };
  }
  
  return null;
}

async function ensurePlacesIndex(additionalCountries = []){
  const mainCC = (CC || state.cc || state.country || '').toUpperCase();
  const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
  
  // Collecter tous les pays à charger
  const countriesToLoad = new Set();
  if (mainCC) countriesToLoad.add(mainCC);
  
  // Ajouter les pays des steps
  if (state.steps && state.steps.length > 0) {
    state.steps.forEach(step => {
      if (step.cc) countriesToLoad.add(step.cc.toUpperCase());
    });
  }
  
  // Ajouter les pays supplémentaires (ex: depuis Route Builder)
  additionalCountries.forEach(cc => {
    if (cc) countriesToLoad.add(cc.toUpperCase());
  });
  
  PLACES_INDEX = {};
  
  for (const cc of countriesToLoad) {
    if (!cc) continue;
    const basePath = `./data/Roadtripsprefabriques/countries/${cc.toLowerCase()}/${cc.toLowerCase()}.places.master.json`;
    const result = await loadWithLangFallback(basePath, lang);
    
    if (result && result.data) {
      const obj = result.data;
      const arr = Array.isArray(obj) ? obj : (obj.places || []);
      let count = 0;
      arr.forEach(pl => {
        const pid = pl.place_id || pl.id;
        if (!pid) return;
        // Ne pas écraser si déjà présent
        if (PLACES_INDEX[pid]) return;
        const visits = Array.isArray(pl.visits) ? pl.visits.map(v => (typeof v === 'string' ? {text:v} : v)) : [];
        const activities = Array.isArray(pl.activities) ? pl.activities.map(a => (typeof a === 'string' ? {text:a} : a)) : [];
        PLACES_INDEX[pid] = {
          lat: Number(pl.lat) || null,
          lon: Number(pl.lon) || Number(pl.lng) || null,
          name: pl.name || pl.title || '',
          rating: Number(pl.rating) || 0,
          suggested_days: Number(pl.suggested_days) || 1,
          visits,
          activities,
          cc: cc
        };
        count++;
      });
      if (count > 0) console.log(`[PLACES] ✅ ${cc}: ${count} lieux chargés`);
    }
  }
  
  console.log(`[PLACES] Total: ${Object.keys(PLACES_INDEX).length} lieux dans l'index`);
  
  // Injecter les ratings dans les steps existants
  if (state.steps && state.steps.length > 0) {
    state.steps.forEach(step => {
      if (step.place_id && PLACES_INDEX[step.place_id]) {
        step.rating = PLACES_INDEX[step.place_id].rating || 0;
      }
    });
  }
}
function coordsFromMaster(pid){
  if(!PLACES_INDEX||!pid) return {lat:null,lon:null,name:''};
  const m=PLACES_INDEX[pid];
  return m?{lat:m.lat,lon:m.lon,name:m.name}:{lat:null,lon:null,name:''};
}


async function loadItin(){
  const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
  const basePath = `./data/Roadtripsprefabriques/countries/${CC.toLowerCase()}/${CC}.itins.modules.json`;
  const result = await loadWithLangFallback(basePath, lang);
  
  if(!result || !result.data) return null;
  
  const j = result.data;
  console.log(`[ITIN] Chargé en ${result.lang}`);
  
  // Stocker la langue du fichier source pour "Écrire source"
  state._sourceLanguage = result.lang;
  
  const itins=(j.itineraries||j.modules||[]).map(x=>({ ...x, __id:x.itin_id||x.id||x.slug||'', __title:x.title||x.name||'Roadtrip', __lang: x.language || result.lang }));
  if(isComposedId(ITIN_ID)){
    const ids=parseComposedIds(ITIN_ID);
    const found=ids.map(id=>itins.find(x=>x.__id===id)).filter(Boolean);
    if(!found.length)return null;
    let days_plan=[],places=[],titleParts=[];
    for(const it of found){
      titleParts.push(it.__title||'RT');
      if(Array.isArray(it.days_plan)&&it.days_plan.length)days_plan=days_plan.concat(it.days_plan);
      else if(Array.isArray(it.places)&&it.places.length)places=places.concat(it.places);
    }
    return{__id:`COMPOSED::${ids.join('+')}`,__title:titleParts.join(' + '),title:titleParts.join(' + '),days_plan:days_plan.length?days_plan:undefined,places:(!days_plan.length&&places.length)?places:undefined};
  }
  return itins.find(x=>x.__id===ITIN_ID)||null;
}

async function initFromItin(it){
  await ensurePlacesIndex();
  
  // Récupérer estimated_days_base de l'itinéraire
  const estimatedDaysBase = it.estimated_days_base || 0;
  state._estimatedDaysBase = estimatedDaysBase;
  console.log(`[INIT] 📅 estimated_days_base: ${estimatedDaysBase}, requestedDays: ${REQUESTED_DAYS}`);
  
  let steps=[];
  if(Array.isArray(it.days_plan)&&it.days_plan.length){
    for(const d of it.days_plan){
      const pid=d.night?.place_id||'';
      const coords=d.night?.coords||[];
      let lat=coords[0]??null;
      let lon=coords[1]??null;

      // Fallback : si pas de coords dans l’itin, on prend celles du master
      if((lat==null||lon==null) && pid){
        const c=coordsFromMaster(pid);
        if(c.lat!=null && c.lon!=null){ lat=c.lat; lon=c.lon; }
      }

      let name='';
      if(pid){
        const parts=pid.split('::');
        name=parts[1]?parts[1].replace(/-/g,' ').replace(/\b\w/g,l=>l.toUpperCase()):pid;
      }
      const visits=Array.isArray(d.visits)?d.visits.map(v=>typeof v==='string'?{text:v}:v):[];
      const activities=Array.isArray(d.activities)?d.activities.map(a=>typeof a==='string'?{text:a}:a):[];
      
      // Récupérer le rating ET suggested_days depuis ITIN puis PLACES_INDEX
      const masterData = PLACES_INDEX[pid] || {};
      const rating = d.rating || masterData.rating || 0;
      const suggestedDays = d.suggested_days || masterData.suggested_days || 1;
      
      steps.push({
        place_id:pid,name,lat,lon,nights:1,visits,activities,
        rating,
        _suggestedDays: suggestedDays,
        _driveMinToNext: d.to_next_leg?.drive_min || 0,
        _distanceKmToNext: d.to_next_leg?.distance_km || 0,
        images:getPhotosForPlace(pid),
        description:visits.map(v=>v.text||v).join('. ')
      });
    }
  }else if(Array.isArray(it.places)&&it.places.length){
    steps=it.places.map(p=>{
      const pid=p.place_id||p.id||p.slug||'';
      const masterData = PLACES_INDEX[pid] || {};
      const rating = p.rating || masterData.rating || 0;
      const suggestedDays = p.suggested_days || masterData.suggested_days || 1;
      return{
        place_id:pid,
        name:p.name||p.title||'',
        lat:Number(p.lat)||null,
        lon:Number(p.lon)||null,
        nights:1,
        rating,
        _suggestedDays: suggestedDays,
        visits:p.visits||[],
        activities:p.activities||[],
        images:getPhotosForPlace(pid),
        description:''
      };
    });
  }
  
  // === FUSION DES ÉTAPES CONSÉCUTIVES IDENTIQUES ===
  // DÉSACTIVÉ - chaque jour du JSON = une étape distincte
  
  state.steps=steps;
  
  // === FONCTION DISTANCE HAVERSINE ===
  function haversineDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Rayon de la Terre en km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }
  
  // === CALCUL DES NUITS PAR PLACE_ID ===
  // Logique simple : regrouper les nuits sur la première étape d'un même lieu consécutif
  // Exemple : Tokyo jour 1-5 → première étape Tokyo = 5 nuits, autres = 0
  
  let currentPlaceId = null;
  let currentGroupStart = 0;
  let currentGroupCount = 0;
  
  for (let i = 0; i <= steps.length; i++) {
    const step = steps[i];
    const placeId = step?.place_id || step?.night?.place_id || `step_${i}`;
    
    if (i === steps.length || placeId !== currentPlaceId) {
      // Fin du groupe précédent - assigner les nuits
      if (currentGroupCount > 0 && currentPlaceId !== null) {
        // Première étape du groupe = toutes les nuits du groupe
        steps[currentGroupStart].nights = currentGroupCount;
        steps[currentGroupStart]._isGroupHead = true;
        steps[currentGroupStart]._groupSize = currentGroupCount;
        
        // Autres étapes du groupe = 0 nuit
        for (let j = currentGroupStart + 1; j < currentGroupStart + currentGroupCount; j++) {
          steps[j].nights = 0;
          steps[j]._isGroupMember = true;
          steps[j]._groupHead = currentGroupStart;
        }
        
        if (currentGroupCount > 1) {
          console.log(`[NIGHTS] 🏨 ${steps[currentGroupStart].name}: ${currentGroupCount} nuits (${currentGroupCount} jours au même lieu)`);
        }
      }
      
      // Démarrer nouveau groupe
      if (i < steps.length) {
        currentPlaceId = placeId;
        currentGroupStart = i;
        currentGroupCount = 1;
      }
    } else {
      // Même lieu - continuer le groupe
      currentGroupCount++;
    }
  }
  
  // Dernière étape = 0 nuit si c'est un aéroport ou point de départ
  const lastStep = steps[steps.length - 1];
  if (lastStep && (lastStep.place_id?.includes('airport') || lastStep.name?.toLowerCase().includes('aéroport') || lastStep.name?.toLowerCase().includes('airport'))) {
    lastStep.nights = 0;
    console.log(`[NIGHTS] ✈️ ${lastStep.name}: 0 nuit (départ)`);
  }
  
  const finalTotal = steps.reduce((s, x) => s + x.nights, 0);
  console.log(`[INIT] ✅ Final: ${finalTotal} nuits pour ${steps.length} étapes`);
  
  // Marquer que le calcul des nuits a été fait par initFromItin
  state._nightsCalculatedByInit = true;
  state.targetNights = finalTotal;
  console.log(`[INIT] 🛏️ Target nuits: ${state.targetNights}`);
  state.title=it.title||it.name||'Roadtrip';
  // Stocker l'ID original pour la sauvegarde source
  // Fallback: utiliser l'ID de l'URL si pas d'ID dans les données
  const urlItinId = new URLSearchParams(location.search).get('itin') || '';
  state._originalItinId = it.__id || it.id || it.itin_id || it.slug || urlItinId || null;
  console.log('[INIT] ID original stocké:', state._originalItinId, '(depuis:', it.__id ? 'data' : 'URL', ')');
  
  // Stocker source_url, created_at et language originaux pour la sauvegarde
  state._originalSourceUrl = it.source_url || null;
  state._originalCreatedAt = it.created_at || null;
  // Priorité: langue de l'itinéraire > langue du fichier chargé
  if (it.language || it.__lang) {
    state._sourceLanguage = it.language || it.__lang;
    console.log('[INIT] 🌐 Langue détectée depuis itinéraire:', state._sourceLanguage);
  }
  
  // Vérifier si l'ajustement des nuits n'a pas pu être complet
  if(state._pendingNightsAdjustment && state._pendingNightsAdjustment.diff > 0){
    setTimeout(() => showNightsAdjustmentAlert(state._pendingNightsAdjustment), 600);
  }
}

// === Alerte i18n : Nombre de nuits impossible à atteindre ===
function showNightsAdjustmentAlert(adjustment){
  const { diff, targetNights, allocated, candidates } = adjustment;
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2).toLowerCase();
  
  const t = {
    title: {
      fr: '⚠️ Nombre de nuits difficile à respecter',
      en: '⚠️ Difficult to meet nights target',
      it: '⚠️ Difficile rispettare il numero di notti',
      es: '⚠️ Difícil respetar el número de noches',
      pt: '⚠️ Difícil respeitar o número de noites',
      ar: '⚠️ صعوبة في الالتزام بعدد الليالي'
    },
    message: {
      fr: `Le nombre de nuits demandé (${targetNights}) est difficile à respecter compte tenu du nombre d'étapes. Actuellement : ${allocated} nuits.`,
      en: `The requested nights (${targetNights}) is difficult to achieve given the number of stops. Currently: ${allocated} nights.`,
      it: `Il numero di notti richiesto (${targetNights}) è difficile da rispettare dato il numero di tappe. Attualmente: ${allocated} notti.`,
      es: `El número de noches solicitado (${targetNights}) es difícil de respetar dado el número de etapas. Actualmente: ${allocated} noches.`,
      pt: `O número de noites solicitado (${targetNights}) é difícil de respeitar dado o número de etapas. Atualmente: ${allocated} noites.`,
      ar: `عدد الليالي المطلوب (${targetNights}) صعب التحقيق نظراً لعدد المحطات. حالياً: ${allocated} ليالي.`
    },
    forceZero: {
      fr: `Forcer ${diff} passage(s) sans nuit`,
      en: `Force ${diff} stop(s) without overnight`,
      it: `Forzare ${diff} tappa/e senza pernottamento`,
      es: `Forzar ${diff} parada(s) sin noche`,
      pt: `Forçar ${diff} paragem(ns) sem pernoite`,
      ar: `فرض ${diff} توقف بدون مبيت`
    },
    keepNights: {
      fr: `Garder ${allocated} nuits (recommandé)`,
      en: `Keep ${allocated} nights (recommended)`,
      it: `Mantenere ${allocated} notti (consigliato)`,
      es: `Mantener ${allocated} noches (recomendado)`,
      pt: `Manter ${allocated} noites (recomendado)`,
      ar: `الإبقاء على ${allocated} ليالي (موصى به)`
    },
    warning: {
      fr: `Étapes concernées : ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      en: `Affected stops: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      it: `Tappe interessate: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      es: `Etapas afectadas: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      pt: `Etapas afetadas: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`,
      ar: `المحطات المتأثرة: ${candidates.slice(0, 3).join(', ')}${candidates.length > 3 ? '...' : ''}`
    }
  };
  
  const overlay = document.createElement('div');
  overlay.id = 'nightsAlertOverlay';
  overlay.style.cssText = `
    position:fixed; inset:0; z-index:13000;
    background:rgba(0,0,0,.6); display:flex;
    align-items:center; justify-content:center;
    backdrop-filter:blur(4px);
  `;
  
  overlay.innerHTML = `
    <div style="background:#fff; color:#113f7a; border-radius:16px; padding:24px; max-width:420px; width:90%; box-shadow:0 12px 40px rgba(0,0,0,.3);">
      <h3 style="margin:0 0 16px; font-size:1.2rem;">${t.title[lang] || t.title.fr}</h3>
      <p style="margin:0 0 12px; line-height:1.5;">${t.message[lang] || t.message.fr}</p>
      <p style="margin:0 0 20px; font-size:0.9rem; color:#64748b;">${t.warning[lang] || t.warning.fr}</p>
      <div style="display:flex; flex-direction:column; gap:10px;">
        <button id="alertForceZero" style="padding:12px; border-radius:10px; border:1px solid #dc2626; background:#fee2e2; color:#dc2626; font-weight:600; cursor:pointer;">
          ${t.forceZero[lang] || t.forceZero.fr}
        </button>
        <button id="alertKeepNights" style="padding:12px; border-radius:10px; border:none; background:#113f7a; color:#fff; font-weight:600; cursor:pointer;">
          ${t.keepNights[lang] || t.keepNights.fr}
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(overlay);
  
  // Forcer les passages (0 nuits)
  document.getElementById('alertForceZero').onclick = () => {
    let remaining = diff;
    const sortedSteps = [...state.steps]
      .filter(s => s.nights === 1 && !s._isHub && !s._isSatellite)
      .sort((a, b) => {
        const pa = (a.rating || 1) * (a._suggestedDays || 1);
        const pb = (b.rating || 1) * (b._suggestedDays || 1);
        return pa - pb;
      });
    
    for(const step of sortedSteps){
      if(remaining <= 0) break;
      step.nights = 0;
      remaining--;
      console.log(`[NIGHTS] Forcé passage: ${step.name} → 0 nuit`);
    }
    
    delete state._pendingNightsAdjustment;
    renderRows();
    refreshCounters();
    toast(`✅ ${diff} passage(s) sans nuit`);
    overlay.remove();
  };
  
  // Garder les nuits calculées
  document.getElementById('alertKeepNights').onclick = () => {
    delete state._pendingNightsAdjustment;
    toast(`✅ ${allocated} nuits conservées`);
    overlay.remove();
  };
}

function refreshCounters(){
  const total = state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
  const delta = total - state.targetNights;

  const curEl = document.querySelector('#currentNights');
  const tarEl = document.querySelector('#targetNights');
  const delEl = document.querySelector('#deltaNights');

  if (curEl) { curEl.textContent = String(total); curEl.className = `counter ${delta===0?'ok':'bad'}`; }
  if (tarEl) { tarEl.textContent = String(state.targetNights); }
  if (delEl) { delEl.textContent = (delta>0?'+':'')+delta; delEl.className = `counter ${delta===0?'ok':'bad'}`; }

  // Toujours tenir à jour le pavé compact
  updateQuickStats();
}

async function recomputeTotals(){
  if (!Array.isArray(state.steps) || state.steps.length<2){ TOTALS={km:0,minutes:0,travelDays:0}; updateHelpPop(); return; }
  const pairs=[];
  for(let i=0;i<state.steps.length-1;i++){
    const a=state.steps[i], b=state.steps[i+1];
    if(Number.isFinite(a.lat)&&Number.isFinite(a.lon)&&Number.isFinite(b.lat)&&Number.isFinite(b.lon)){
      pairs.push(calculateDistance(a,b));
    }
  }
  try{
    const res=await Promise.all(pairs);
    const km = res.reduce((s,r)=> s+(r?.km||0), 0);
    const minutes = res.reduce((s,r)=> s+(r?.minutes||0), 0);
    // Nouvelle logique: calcul des jours de trajet par segment
    let travelDays = 0;
    for(const r of res){
      const segKm = r?.km || 0;
      const segMin = r?.minutes || 0;
      if(segKm >= 600){
        // Vol: +1 jour
        travelDays += 1;
      } else if(segMin >= 300){
        // Longue route (5h+): +0.5 jour
        travelDays += 0.5;
      }
      // Sinon: trajet normal → 0
    }
    TOTALS = { km: Math.round(km), minutes: Math.round(minutes), travelDays: travelDays };
  }catch{
    TOTALS = { km: 0, minutes: 0, travelDays: 0 };
  }
  updateHelpPop();
  updateQuickStats();
}

function updateHelpPop(){
  const box = document.getElementById('helpPop');
  if(!box) return;
  const initN = Number(state.targetNights||0);
  const currN = sumNights();
  const delta = currN - initN;
  const deltaSign = delta>0? '+' : '';
  const travelDays = TOTALS.travelDays || 0;
  const travelDaysInfo = travelDays > 0 
    ? `<div class="row"><span>${t('travelDaysLegend')}</span><strong>+${travelDays}j</strong></div>`
    : '';
  box.innerHTML = `
    <div class="mut">${t('legendTitle')}</div>
    <div class="row"><span>${t('initialNights')}</span><strong>${initN}</strong></div>
    <div class="row"><span>${t('currentNights')}</span><strong>${currN}</strong></div>
    <div class="row"><span>${t('delta')}</span><strong>${deltaSign}${delta}</strong></div>
    ${travelDaysInfo}
    <hr style="border:none;border-top:1px solid #e5e7eb;margin:8px 0">
    <div class="row"><span>${t('totalKm')}</span><strong>${fmtKm(TOTALS.km)}</strong></div>
    <div class="row"><span>${t('totalTime')}</span><strong>${fmtDur(TOTALS.minutes)}</strong></div>
    <div class="mut" style="margin-top:6px">${t('travelDaysNote')}</div>
  `;
}

function updateQuickStats(){
  const initN = Number(state.targetNights||0);
  const currN = state.steps.reduce((s,x)=>s+Number(x.nights||0),0);
  const delta = currN - initN;
  const qsN = document.getElementById('qsNights');
  const qsD = document.getElementById('qsDelta');
  const qsK = document.getElementById('qsKm');
  const qsT = document.getElementById('qsTime');
  const qsTD = document.getElementById('qsTravelDays');
  if(qsN) qsN.textContent = tNights(currN);
  if(qsD) qsD.textContent = `Δ ${delta>0?'+':''}${delta}`;
  if(qsK) qsK.textContent = (state.distanceUnit==='mi')
    ? `${Math.round(TOTALS.km*0.621371)} mi`
    : `${TOTALS.km} km`;
  if(qsT) {
    const h = Math.floor(TOTALS.minutes/60), m = TOTALS.minutes%60;
    qsT.textContent = `${h} h ${m} min`;
  }
  if(qsTD) {
    const td = TOTALS.travelDays || 0;
    qsTD.textContent = td > 0 ? `+${td}j trajet` : '';
    qsTD.style.display = td > 0 ? '' : 'none';
  }
}

let copyModeActive = false;
let copySourceIdx = null;

function startCopyMode(sourceIdx) {
  copyModeActive = true;
  copySourceIdx = sourceIdx;
  
  // Pop-up d'instruction
  const popup = document.createElement('div');
  popup.id = 'copyModePopup';
  popup.style.cssText = `
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: #3b82f6;
    color: #fff;
    padding: 16px 24px;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 15000;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 12px;
  `;
  popup.innerHTML = `
    📋 Cliquez sur l'étape au-dessus de laquelle vous souhaitez insérer la copie
    <button onclick="cancelCopyMode()" style="background:#fff;color:#3b82f6;border:none;padding:6px 12px;border-radius:6px;cursor:pointer;font-weight:700">✕ Annuler</button>
  `;
  document.body.appendChild(popup);
  
  // Rendre les rows cliquables
  document.querySelectorAll('.step-row').forEach(row => {
    row.style.cursor = 'copy';
    row.addEventListener('click', handleCopyClick, { once: true });
  });
  
  console.log('[COPY] Mode copie activé pour étape', sourceIdx);
}

function handleCopyClick(e) {
  if (!copyModeActive) return;
  
  const targetRow = e.currentTarget;
  const targetIdx = parseInt(targetRow.dataset.index);
  
  // Copier l'étape
  const sourcStep = state.steps[copySourceIdx];
  const copiedStep = JSON.parse(JSON.stringify(sourcStep)); // deep clone
  
  // Nouveau UUID pour la copie
  copiedStep._uuid = 'uuid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  
  // Insérer avant targetIdx
  state.steps.splice(targetIdx, 0, copiedStep);
  
  console.log('[COPY] Étape', copySourceIdx, 'copiée avant', targetIdx);
  
  cancelCopyMode();
  renderRows();
  
  if (typeof scheduleAutosave === 'function') {
    scheduleAutosave();
  }
}

function cancelCopyMode() {
  copyModeActive = false;
  copySourceIdx = null;
  
  const popup = document.getElementById('copyModePopup');
  if (popup) popup.remove();
  
  document.querySelectorAll('.step-row').forEach(row => {
    row.style.cursor = '';
    row.removeEventListener('click', handleCopyClick);
  });
  
  console.log('[COPY] Mode copie annulé');
}

// Rendre la fonction accessible globalement
window.cancelCopyMode = cancelCopyMode;


// === CONVERSION RATING EN ÉTOILES COLORÉES ===
function ratingToStars(rating) {
  if (!rating || rating === 0) return { stars: 0, color: '#94a3b8', textColor: '#fff' };
  if (rating >= 8.8) return { stars: 5, color: '#1E88E5', textColor: '#fff' };  // Bleu
  if (rating >= 7.6) return { stars: 4, color: '#2E7D32', textColor: '#fff' };  // Vert foncé
  if (rating >= 6.1) return { stars: 3, color: '#A5D6A7', textColor: '#333' };  // Vert clair
  if (rating >= 3.1) return { stars: 2, color: '#FB8C00', textColor: '#fff' };  // Orange
  return { stars: 1, color: '#FDD835', textColor: '#333' };  // Jaune (< 3.1)
}


// === RECALCUL AUTOMATIQUE DES GROUPES (seulement quand nombre d'étapes change) ===
window._lastStepsCount = null;
window._initialNightsCalculated = false; // Flag pour savoir si le calcul initial a été fait
window._groupsCalculating = false; // Mutex pour éviter les recalculs en cascade


function renderRows(){
  
  const box=$('#rows');box.innerHTML='';
  const steps = (window.state?.steps && window.state.steps.length > 0) ? window.state.steps : state.steps;
  steps.forEach((s,idx)=>{
    // Créer un wrapper contenant la row + le panneau détails
    const wrapper = document.createElement('div');
    wrapper.className = 'step-wrapper';
    wrapper.dataset.stepIdx = idx;
    
    const row = renderRow(s, idx);
    wrapper.appendChild(row);
    
    // Créer le panneau détails (activités, visites, etc.)
    const panel = createStepDetailsPanel(s, idx);
    wrapper.appendChild(panel);
    
    box.appendChild(wrapper);
  });
  
  // === AJOUTER LES MODALES DE RÉSERVATIONS ===
  if (typeof renderBookingsModal === 'function' && typeof globalBookingManager !== 'undefined' && globalBookingManager) {
    let modalsContainer = document.getElementById('bookingsModalsContainer');
    if (!modalsContainer) {
      modalsContainer = document.createElement('div');
      modalsContainer.id = 'bookingsModalsContainer';
      document.body.appendChild(modalsContainer);
    }
    
    // Créer une modale pour chaque étape
    modalsContainer.innerHTML = '';
    state.steps.forEach((step, idx) => {
      const modalHTML = renderBookingsModal(idx, step.name || step.place_id, globalBookingManager);
      if (modalHTML) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = modalHTML;
        modalsContainer.appendChild(tempDiv.firstElementChild);
      }
    });
  }
  
  enableDnD();
  drawMap();
  /* AJOUT */
  if (window.map && window.map.invalidateSize) {
    setTimeout(()=>map.invalidateSize(), 60);
  }
  refreshCounters();
  recomputeTotals();      // met à jour km/temps
  updateQuickStats();     // met à jour le pavé compact
  renderTripBookings();   // Affiche les réservations du voyage (NEW)
  // scheduleAutosave(); // SUPPRIMÉ - ne pas sauvegarder au simple affichage, seulement sur modification utilisateur

}
window.renderRows = renderRows;

// === AFFICHER LES RÉSERVATIONS DU VOYAGE (vols, voitures, etc.) ===
function renderTripBookings() {
  const container = document.getElementById('tripBookingsContainer');
  if (!container) {
    console.warn('[TRIP-BOOKINGS] Container non trouvé');
    return;
  }
  
  // Collecter toutes les réservations voyage
  const tripBookings = [];
  
  // 1. Depuis globalBookingManager (résas par étape avec catégorie voyage)
  if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
    Object.entries(globalBookingManager.bookings).forEach(([stepIdx, bookings]) => {
      bookings.forEach(booking => {
        if (booking.category && ['flight', 'car', 'train', 'restaurant', 'other'].includes(booking.category)) {
          tripBookings.push(booking);
        }
      });
    });
  }
  
  // 2. Depuis window.state.travelBookings (nouvelles résas via ORT_TRIP_DATA)
  if (window.state?.travelBookings && Array.isArray(window.state.travelBookings)) {
    window.state.travelBookings.forEach(booking => {
      // Éviter les doublons (par ID)
      if (!tripBookings.find(b => b.id === booking.id)) {
        tripBookings.push(booking);
      }
    });
  }
  
  if (tripBookings.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  // Grouper par catégorie
  const grouped = {};
  tripBookings.forEach(booking => {
    const cat = booking.category || booking.type || 'other';
    if (!grouped[cat]) grouped[cat] = [];
    grouped[cat].push(booking);
  });
  
  // Afficher
  let html = '<div style="margin-bottom:16px"><h3 style="color:#113f7a;font-size:1.1rem;margin:0 0 12px 0">📋 Réservations du voyage</h3>';
  
  Object.entries(grouped).forEach(([cat, bookings]) => {
    const icon = getCategoryIconForCell(cat);
    const getCatLabel = (category) => {
      const lang = window.ORT_getLang ? window.ORT_getLang() : (localStorage.getItem('lang') || 'fr').slice(0, 2);
      const categoryMap = {
        flight: 'flights',
        car: 'bookingCategoryVehicles',
        train: 'bookingCategoryTrains',
        restaurant: 'bookingCategoryRestaurants',
        hotel: 'bookingCategoryHotels',
        other: 'bookingCategoryOther'
      };
      const i18nKey = categoryMap[category];
      return window.ORT_I18N?.[i18nKey]?.[lang] || window.ORT_I18N?.[i18nKey]?.fr || category;
    };
    const catLabel = getCatLabel(cat);
    
    html += `<div style="margin-bottom:12px;padding:10px;background:#f8fafc;border-left:4px solid #113f7a;border-radius:6px">
      <div style="font-weight:700;color:#113f7a;margin-bottom:8px;font-size:0.95rem">${icon} ${catLabel}</div>`;
    
    bookings.forEach(booking => {
      html += `
        <div style="padding:8px;background:#fff;border-radius:4px;margin-bottom:6px;border:1px solid #e2e8f0;font-size:0.9rem">
          <div style="font-weight:600;color:#1f2937">${booking.name || 'N/A'}</div>
          ${booking.confirmationNumber ? `<div style="color:#666;font-size:0.85rem">N°: ${booking.confirmationNumber}</div>` : ''}
          ${booking.date_start ? `<div style="color:#666;font-size:0.85rem">📅 ${booking.date_start}</div>` : ''}
          ${booking.price ? `<div style="color:#047857;font-weight:600;margin-top:4px">€ ${booking.price}</div>` : ''}
        </div>`;
    });
    
    html += '</div>';
  });
  
  html += '</div>';
  container.innerHTML = html;
}

function renderRow(step,idx){
  // I18N local pour les tooltips
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  const ROW_I18N = {
    viewPhotos: { fr:'Voir les photos', en:'View photos', es:'Ver fotos', it:'Vedi foto', pt:'Ver fotos', ar:'عرض الصور' },
    copyStep: { fr:'Copier cette étape', en:'Copy this step', es:'Copiar esta etapa', it:'Copia questa tappa', pt:'Copiar esta etapa', ar:'نسخ هذه المرحلة' },
    chooseHotel: { fr:'Voir les hôtels', en:'See hotels', es:'Ver hoteles', it:'Vedi hotel', pt:'Ver hotéis', ar:'عرض الفنادق' }
  };
  const t = (key) => ROW_I18N[key]?.[lang] || ROW_I18N[key]?.fr || key;

  const row=document.createElement('div');
  row.className='step-row';
  row.draggable=true;
  row.dataset.index=idx;

  // ⚙️ SID unique garanti (indépendant de l'index)
  const sid = ensureSid(step);
  row.dataset.stepId = sid;


  const handle=document.createElement('div');

  handle.className='cell';

handle.innerHTML=`
  <div style="display:flex;align-items:center;gap:6px">
    <span class="step-num">${idx+1}</span>
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
      <path d="M9 5h2v2H9V5zm0 4h2v2H9V9zm0 4h2v2H9v-2zm0 4h2v2H9v-2zm4-12h2v2h-2V5zm0 4h2v2h-2V9zm0 4h2v2h-2v-2zm0 4h2v2h-2v-2z" fill="#64748b"/>
    </svg>
  </div>`;
row.appendChild(handle);
  
  const place=document.createElement('div');
place.className='cell';

// Récupérer le rating depuis step ou PLACES_INDEX
let stepRating = step.rating || 0;
if (!stepRating && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step.place_id]) {
  stepRating = PLACES_INDEX[step.place_id].rating || 0;
}

// Étoiles colorées
let starsHTML = '';
if (stepRating > 0) {
  const starInfo = ratingToStars(stepRating);
  const starsDisplay = '★'.repeat(starInfo.stars);
  starsHTML = `<div style="font-size:0.85rem;color:${starInfo.color};margin-top:2px;font-weight:700">${starsDisplay}</div>`;
}

// Temps de visite conseillé
let visitTimeHTML = '';
const visitDays = step.adjustedDays || step._suggestedDays || 0;
if (visitDays > 0) {
  const displayTime = visitDays >= 1 ? `${visitDays} jour${visitDays > 1 ? 's' : ''}` : `${visitDays} jour`;
  visitTimeHTML = `<div style="font-size:0.75rem;color:#666;margin-top:1px">⏱ ${displayTime}</div>`;
}

// Badge de compteur réservations
let bookingsBadgeHTML = '';
if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
  const count = globalBookingManager.getBookings(idx)?.length || 0;
  if (count > 0) {
    bookingsBadgeHTML = `<span style="position: absolute; top: -5px; right: -2px; background: #ef4444; color: white; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold;">${count}</span>`;
  }
}

place.innerHTML=`
  <div style="display:flex;align-items:center;gap:8px">
    <button class="step-expand-toggle" data-i18n-title="viewDetails" title="Voir les détails">▶</button>
    <button class="iconbtn copy-btn" title="${t('copyStep')}" data-step="${idx}">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2-2v1"></path>
      </svg>
    </button>
    <div>
      <a href="#" class="step-name-link" data-step="${idx}" style="font-weight:600;color:#113f7a;text-decoration:none">${safe(step.name||step.place_id)}</a>
      ${starsHTML}
      ${visitTimeHTML}
    </div>
  </div>`;

   row.appendChild(place);

// Handler pour le toggle
(function(){
  const toggleBtn = place.querySelector('.step-expand-toggle');
  if(!toggleBtn) return;
  toggleBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const wrapper = row.closest('.step-wrapper');
    const panel = wrapper?.querySelector('.step-details-panel');
    if(panel){
      panel.classList.toggle('open');
      toggleBtn.classList.toggle('open');
    }
  });
})();




   // Nom cliquable → ouverture directe si connecté + tooltip
  (function(){
    const nameLink = place.querySelector('.step-name-link');
    if(!nameLink) return;
    
    const tooltip = document.getElementById('stepTooltip');
    
    // Textes I18N
    const tooltipTexts = {
      fr: "Cliquer pour voir les activités et visites",
      en: "Click to view activities and visits",
      es: "Haga clic para ver actividades y visitas",
      it: "Clicca per vedere attività e visite",
      pt: "Clique para ver atividades e visitas",
      ar: "انقر لعرض الأنشطة والزيارات"
    };
    
    const lang = localStorage.getItem('lang') || document.documentElement.lang || 'fr';
    const tooltipText = tooltipTexts[lang] || tooltipTexts.fr;
    
  // Hover : montrer tooltip (Nom complet + message)
nameLink.addEventListener('mouseenter', (e) => {
  const rect = nameLink.getBoundingClientRect();
  const fullName = String(step.name || step.place_id)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;');   // escape minimal
  tooltip.innerHTML = `<div class="tt-fullname">${fullName}</div><div>${tooltipText}</div>`;
  tooltip.style.left = (rect.right + 12) + 'px';
  tooltip.style.top = (rect.top + rect.height / 2) + 'px';
  tooltip.style.transform = 'translateY(-50%)';
  tooltip.classList.add('show');
});

    nameLink.addEventListener('mouseleave', () => {
      tooltip.classList.remove('show');
    });
    
    // Clic : toggle le panneau détails (plus d'ouverture page step)
    nameLink.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      tooltip.classList.remove('show');
      
      // Toggle le panneau détails
      const wrapper = row.closest('.step-wrapper');
      const panel = wrapper?.querySelector('.step-details-panel');
      const toggle = wrapper?.querySelector('.step-expand-toggle');
      if(panel && toggle){
        panel.classList.toggle('open');
        toggle.classList.toggle('open');
      }
    });
  })();
  
  // Bouton copier
  (function(){
    const copyBtn = place.querySelector('.copy-btn');
    if(!copyBtn) return;
    copyBtn.addEventListener('click', (e)=>{
      e.stopPropagation();
      startCopyMode(idx);
    });
  })();

  

    
  // Distance vers prochaine étape
  const distCell=document.createElement('div');
  distCell.className='cell mut';
  distCell.innerHTML='<div data-dist="loading">' + t('calculating') + '</div>';
  row.appendChild(distCell);
  
  // Calculer distance en arrière-plan
  if(idx<state.steps.length-1){
    const nextStep=state.steps[idx+1];
    calculateDistance(step,nextStep).then(dist=>{
  const el=row.querySelector('[data-dist]');
  if(el&&dist){
    const isMi = state.distanceUnit==='mi';
    const val = isMi ? Math.round(dist.km*0.621371) : dist.km;
    const unit = isMi ? 'mi' : 'km';
    el.innerHTML=`<div style="font-weight:600">${val} ${unit}</div><div style="font-size:.8rem">${dist.minutes} min</div>`;
  }else if(el){
    el.textContent='—';
  }
});

  }else{
    const el=row.querySelector('[data-dist]');
    if(el) el.textContent='—';
  }
  
// === Compteur de nuits (+ aide au survol) ===
const nights=document.createElement('div');
nights.className='cell';
nights.innerHTML=`
  <input class="input" type="number" min="0" max="30"
         value="${Number(step.nights||0)}"
         style="width:60px"
         data-idx="${idx}"
         title="Définir le nombre de nuits (si 0, il s’agit juste d’un passage)"
         data-i18n-title="nightsTooltip"/>
`;
row.appendChild(nights);

// === Dates (2 lignes) calculées à partir de la date de départ globale ===
(function(){
const dateCell = document.createElement('div');
dateCell.className='cell';
// (supprimé) dateCell.style.width = '90px';
dateCell.style.lineHeight='1.1';
dateCell.style.textAlign='left';



  // Tooltip i18n 6 langues
  const lang = (document.documentElement.lang||'fr').slice(0,2);
  const TIP = {
    fr:'Première/dernière nuit',
    en:'First/last night',
    it:'Prima/ultima notte',
    es:'Primera/última noche',
    pt:'Primeira/última noite',
    ar:'أول/آخر ليلة'
  };
  dateCell.title = TIP[lang] || TIP.fr;

  // Si pas de date globale définie, on affiche un tiret
  const startStr = (state.startDateStr||'').trim();
  if(!startStr){
    dateCell.innerHTML = `<div class="mut">—</div>`;
    row.appendChild(dateCell);
    return;
  }

  // Calcule la date de début de l'étape courante en cumulant les nuits précédentes
  const base = new Date(startStr+'T00:00:00');
  let offset = 0;
  for(let i=0;i<idx;i++){
    offset += Number(state.steps[i]?.nights||0);
  }
   const nightsCount = Number(step.nights||0);

  const start = new Date(base);
  start.setDate(start.getDate()+offset);

  const end = new Date(start);
  end.setDate(end.getDate()+Math.max(0, nightsCount - 1)); // dernière nuit = start + (nuits-1)

  // Format compact par langue (JJ MMM)
  const fmt = (d)=>{

    try {
      const l = (document.documentElement.lang||'fr');
      return d.toLocaleDateString(l, { day:'2-digit', month:'short' });
    } catch(_){
      const dd = String(d.getDate()).padStart(2,'0');
      const mm = String(d.getMonth()+1).padStart(2,'0');
      return `${dd}/${mm}`;
    }
  };

  dateCell.innerHTML = `
    <div style="line-height:1.1">
      <div>${fmt(start)}</div>
      <div>${fmt(end)}</div>
    </div>
  `;
  row.appendChild(dateCell);
})();


// === Colonne "Hôtel" toujours présente (aligne les colonnes)
//    → visible seulement si nuits > 0, sinon placeholder masqué
{
  const hotel = document.createElement('div');
  hotel.className = 'cell hotel-cell';
  hotel.dataset.stepIdx = idx;
  
  if (Number(step.nights||0) > 0) {
    if (step.lat && step.lon) {
      hotel.innerHTML = `
        <button class="btn-hotel-choose" data-step-idx="${idx}" 
          title="${t('chooseHotel')}"
          style="background:#113f7a;color:#fff;border:none;border-radius:6px;padding:5px 10px;cursor:pointer;font-size:0.85rem;display:flex;align-items:center;gap:4px">
          🏨 ${t('chooseHotel').split(' ')[0]}
        </button>`;
      
      // Handler pour ouvrir la carte
      setTimeout(() => {
        const btn = hotel.querySelector('.btn-hotel-choose');
        if (btn) {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openStay22MapForStep(step, idx);
          });
        }
      }, 0);
    } else {
      hotel.innerHTML = '<div style="color:#94a3b8;font-size:0.85rem">🏨 —</div>';
    }
  } else {
    hotel.innerHTML = '&nbsp;';
    hotel.style.visibility = 'hidden';
  }
  row.appendChild(hotel);
}

// === COLONNE RÉSERVATIONS (à côté des hôtels) ===
{
  const bookingsCell = document.createElement('div');
  bookingsCell.className = 'cell bookings-cell';
  bookingsCell.dataset.stepIdx = idx;
  bookingsCell.style.cursor = 'pointer';
  bookingsCell.style.padding = '8px';
  bookingsCell.style.borderRadius = '6px';
  bookingsCell.style.transition = 'background 0.2s';
  
  let hasBookings = false;
  
  // Récupérer les réservations de cette étape depuis ORT_TRIP_DATA
  let stepBookings = [];
  if (window.ORT_TRIP_DATA) {
    stepBookings = ORT_TRIP_DATA.getStepBookings(idx) || [];
  } else if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
    // Fallback sur ancien système
    stepBookings = globalBookingManager.getBookings(idx) || [];
  }
  
  hasBookings = stepBookings.length > 0;
  
  if (stepBookings.length > 0) {
    const categoryGroups = {};
    
    // Grouper par catégorie
    stepBookings.forEach(booking => {
      const cat = booking.category || 'other';
      if (!categoryGroups[cat]) {
        categoryGroups[cat] = [];
      }
      categoryGroups[cat].push(booking);
    });
    
    // Afficher un résumé
    let html = '<div style="font-size:0.8rem;line-height:1.4;font-weight:600">';
    Object.entries(categoryGroups).forEach(([cat, bookings]) => {
      const icon = getCategoryIconForCell(cat);
      html += `<div style="margin:2px 0;color:#555">${icon} ${bookings.length}</div>`;
    });
    html += '</div>';
    
    bookingsCell.innerHTML = html;
    bookingsCell.style.backgroundColor = '#f0f9ff';
    bookingsCell.style.border = '1px solid #93c5fd';
  } else {
    bookingsCell.innerHTML = '<div style="color:#999;font-size:0.85rem">—</div>';
  }
  
  // Ajouter onclick pour ouvrir la modale
  bookingsCell.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (typeof openBookingsModal === 'function') {
      openBookingsModal(idx, step.name || step.place_id);
    } else if (typeof openStepBookingsModal === 'function') {
      openStepBookingsModal(idx, step.name || step.place_id);
    } else {
      console.warn('[BOOKINGS] Aucune fonction modale disponible');
    }
  });
  
  // Hover effect
  bookingsCell.addEventListener('mouseenter', () => {
    bookingsCell.style.backgroundColor = '#e0f2fe';
  });
  bookingsCell.addEventListener('mouseleave', () => {
    bookingsCell.style.backgroundColor = hasBookings ? '#f0f9ff' : 'transparent';
  });
  
  row.appendChild(bookingsCell);
}

  
  const del=document.createElement('div');
  del.className='cell';
  del.innerHTML=`<button class="iconbtn btn danger" data-delete="${idx}">✕</button>`;
  // ... création bouton supprimer (del)

  row.appendChild(del);
  del.querySelector('button').addEventListener('click', () => {
    if(confirm('Supprimer cette étape ?')) {
      state.steps.splice(idx, 1);
      renderRows(); // recalcul complet (km, nuits, totaux)
    }
  });

  
// [Y.2] Rouge + grossi sans casser le translate Leaflet
row.addEventListener('mouseenter', ()=>{
  const sid = row.dataset.stepId;
  const mm = (markers||[]).find(m=>m.stepId===sid);
  const el = mm?.getElement();
  el?.querySelector('.marker-num')?.classList.add('num-boost'); // grossit le chiffre
  el?.classList.add('marker-red');                               // cercle rouge
});
row.addEventListener('mouseleave', ()=>{
  const sid = row.dataset.stepId;
  const mm = (markers||[]).find(m=>m.stepId===sid);
  const el = mm?.getElement();
  el?.querySelector('.marker-num')?.classList.remove('num-boost');
  el?.classList.remove('marker-red');
});

  return row;
}

// === PANNEAU DÉTAILS ÉTAPE (activités, visites, actions) ===
function createStepDetailsPanel(step, idx) {
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  
  // Textes I18N pour tooltips
  const I18N = {
    visits: { fr:'Visites prévues', en:'Planned visits', es:'Visitas previstas', it:'Visite previste', pt:'Visitas previstas', ar:'الزيارات المخططة' },
    activities: { fr:'Activités', en:'Activities', es:'Actividades', it:'Attività', pt:'Atividades', ar:'الأنشطة' },
    addVisit: { fr:'Ajouter une visite...', en:'Add a visit...', es:'Añadir una visita...', it:'Aggiungi una visita...', pt:'Adicionar uma visita...', ar:'إضافة زيارة...' },
    addActivity: { fr:'Ajouter une activité...', en:'Add an activity...', es:'Añadir una actividad...', it:'Aggiungi un\'attività...', pt:'Adicionar uma atividade...', ar:'إضافة نشاط...' },
    add: { fr:'+', en:'+', es:'+', it:'+', pt:'+', ar:'+' },
    proposePhoto: { fr:'Proposer une photo libre de droit', en:'Suggest a royalty-free photo', es:'Proponer una foto libre de derechos', it:'Proponi una foto royalty-free', pt:'Propor uma foto livre de direitos', ar:'اقتراح صورة مجانية' },
    reportError: { fr:'Signaler une erreur sur ce lieu', en:'Report an error on this place', es:'Reportar un error en este lugar', it:'Segnala un errore su questo luogo', pt:'Reportar um erro neste lugar', ar:'الإبلاغ عن خطأ في هذا المكان' },
    bookActivity: { fr:'Activités & tours', en:'Activities & tours', es:'Actividades y tours', it:'Attività e tour', pt:'Atividades e tours', ar:'الأنشطة والجولات' },
    bookTickets: { fr:'Visites & billets', en:'Visits & tickets', es:'Visitas y entradas', it:'Visite e biglietti', pt:'Visitas e bilhetes', ar:'الزيارات والتذاكر' },
    bookShows: { fr:'Spectacles', en:'Shows', es:'Espectáculos', it:'Spettacoli', pt:'Espetáculos', ar:'العروض' },
    bookGuide: { fr:'Réserver un guide (bientôt)', en:'Book a guide (coming soon)', es:'Reservar un guía (próximamente)', it:'Prenota una guida (prossimamente)', pt:'Reservar um guia (em breve)', ar:'حجز مرشد (قريباً)' },
    noVisits: { fr:'Aucune visite prévue', en:'No visits planned', es:'Sin visitas previstas', it:'Nessuna visita prevista', pt:'Nenhuma visita prevista', ar:'لا توجد زيارات مخططة' },
    noActivities: { fr:'Aucune activité', en:'No activities', es:'Sin actividades', it:'Nessuna attività', pt:'Nenhuma atividade', ar:'لا توجد أنشطة' }
  };
  const t = (key) => I18N[key]?.[lang] || I18N[key]?.fr || key;
  
  const panel = document.createElement('div');
  panel.className = 'step-details-panel';
  panel.dataset.stepIdx = idx;
  
  // Récupérer visits et activities
  const visits = Array.isArray(step.visits) ? step.visits : [];
  const activities = Array.isArray(step.activities) ? step.activities : [];
  
  // Générer les items d'une liste
  const renderList = (items, type) => {
    if(!items.length) return `<div style="color:#94a3b8;font-size:0.85rem;padding:4px 0">${t(type === 'visits' ? 'noVisits' : 'noActivities')}</div>`;
    return `<ul class="step-details-list">
      ${items.map((item, i) => {
        const text = typeof item === 'string' ? item : (item.text || item.name || '');
        return `<li data-type="${type}" data-item-idx="${i}">
          <span class="item-text" contenteditable="true">${safe(text)}</span>
          <button class="item-del" title="✕">✕</button>
        </li>`;
      }).join('')}
    </ul>`;
  };
  
  // Email pour proposer une photo
  const placeName = step.name || step.place_id || 'Lieu';
  const placeId = step.place_id || '';
  const emailSubject = encodeURIComponent(`[OneRoadTrip] Photo pour ${placeName}`);
  const emailBody = encodeURIComponent(`Bonjour,\n\nJe souhaite proposer une photo libre de droit pour le lieu suivant :\n\nNom : ${placeName}\nID : ${placeId}\n\n[Joindre votre photo ou insérer un lien]\n\nCordialement`);
  const mailtoLink = `mailto:contact@oneroadtrip.com?subject=${emailSubject}&body=${emailBody}`;
  
  // Email pour signaler une erreur
  const errorSubject = encodeURIComponent(`[OneRoadTrip] Erreur sur ${placeName}`);
  const errorBody = encodeURIComponent(`Bonjour,\n\nJe souhaite signaler une erreur sur le lieu suivant :\n\nNom : ${placeName}\nID : ${placeId}\n\nDescription de l'erreur :\n[Décrivez l'erreur ici]\n\nCordialement`);
  const errorMailtoLink = `mailto:contact@oneroadtrip.com?subject=${errorSubject}&body=${errorBody}`;
  
  panel.innerHTML = `
    <div class="step-booking-cta" style="display:flex;flex-wrap:wrap;gap:10px;margin-bottom:18px;padding:14px;background:linear-gradient(135deg,#f0f7ff 0%,#e8f4f8 100%);border-radius:14px;border:2px solid #113f7a;">
      <button onclick="openGygModal(state.steps[${idx}], ${idx})" style="
        flex:1;min-width:140px;display:flex;align-items:center;justify-content:center;gap:8px;
        padding:14px 12px;
        background:linear-gradient(135deg,#ff5533 0%,#ff7744 100%);
        color:#fff;border:none;border-radius:12px;
        font-size:0.95rem;font-weight:700;cursor:pointer;
        box-shadow:0 4px 15px rgba(255,85,51,0.35);
        transition:all 0.2s;
      " onmouseover="this.style.transform='scale(1.05)';this.style.boxShadow='0 6px 20px rgba(255,85,51,0.5)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 4px 15px rgba(255,85,51,0.35)'">
        🎫 ${t('bookActivity')}
      </button>
      <button onclick="openTiqetsModal(state.steps[${idx}], ${idx})" style="
        flex:1;min-width:140px;display:flex;align-items:center;justify-content:center;gap:8px;
        padding:14px 12px;
        background:linear-gradient(135deg,#00a0e3 0%,#0077b6 100%);
        color:#fff;border:none;border-radius:12px;
        font-size:0.95rem;font-weight:700;cursor:pointer;
        box-shadow:0 4px 15px rgba(0,119,182,0.35);
        transition:all 0.2s;
      " onmouseover="this.style.transform='scale(1.05)';this.style.boxShadow='0 6px 20px rgba(0,119,182,0.5)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 4px 15px rgba(0,119,182,0.35)'">
        🎟️ ${t('bookTickets')}
      </button>
      <button onclick="openTicketmasterModal(state.steps[${idx}], ${idx})" style="
        flex:1;min-width:140px;display:flex;align-items:center;justify-content:center;gap:8px;
        padding:14px 12px;
        background:linear-gradient(135deg,#026cdf 0%,#0653b6 100%);
        color:#fff;border:none;border-radius:12px;
        font-size:0.95rem;font-weight:700;cursor:pointer;
        box-shadow:0 4px 15px rgba(2,108,223,0.35);
        transition:all 0.2s;
      " onmouseover="this.style.transform='scale(1.05)';this.style.boxShadow='0 6px 20px rgba(2,108,223,0.5)'" onmouseout="this.style.transform='scale(1)';this.style.boxShadow='0 4px 15px rgba(2,108,223,0.35)'">
        🎭 ${t('bookShows')}
      </button>
    </div>
    
    <div class="step-details-section">
      <h4><span class="section-icon" title="Photos">📸</span> Photos</h4>
      <div class="photos-list" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px;margin-bottom:12px;">
        ${(step.images || []).map((img, i) => `
          <div style="aspect-ratio:1/1;border-radius:8px;overflow:hidden;background:#f1f5f9;border:2px solid #e2e8f0;">
            <img src="${safe(img)}" style="width:100%;height:100%;object-fit:cover;cursor:pointer;" 
                 alt="Photo ${i+1}" title="Cliquez pour agrandir">
          </div>
        `).join('')}
      </div>
      ${(!step.images || step.images.length === 0) ? `
        <div style="color:#94a3b8;font-size:0.85rem;padding:8px;text-align:center;background:#f8fafc;border-radius:6px;">
          Aucune photo trouvée
        </div>
      ` : ''}
    </div>
    
    <div class="step-details-section">
      <h4><span class="section-icon" title="${t('visits')}">👁</span> ${t('visits')}</h4>
      <div class="visits-list">${renderList(visits, 'visits')}</div>
      <div class="step-add-item" data-type="visits">
        <input type="text" placeholder="${t('addVisit')}">
        <button title="${t('add')}">${t('add')}</button>
      </div>
    </div>
    
    <div class="step-details-section">
      <h4><span class="section-icon" title="${t('activities')}">🎯</span> ${t('activities')}</h4>
      <div class="activities-list">${renderList(activities, 'activities')}</div>
      <div class="step-add-item" data-type="activities">
        <input type="text" placeholder="${t('addActivity')}">
        <button title="${t('add')}">${t('add')}</button>
      </div>
    </div>
    
    <div class="step-actions-icons">
      <a href="${mailtoLink}" class="action-icon" title="${t('proposePhoto')}" target="_blank">📷</a>
      <a href="${errorMailtoLink}" class="action-icon" title="${t('reportError')}" target="_blank" style="color:#dc2626;">⚠</a>
      <span class="action-icon disabled" title="${t('bookGuide')}">🧑‍🏫</span>
    </div>
  `;
  
  // Handlers pour édition et ajout
  setTimeout(() => {
    // Suppression d'item
    panel.querySelectorAll('.item-del').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const li = btn.closest('li');
        const type = li.dataset.type;
        const itemIdx = parseInt(li.dataset.itemIdx);
        if(type === 'visits' && Array.isArray(step.visits)){
          step.visits.splice(itemIdx, 1);
        } else if(type === 'activities' && Array.isArray(step.activities)){
          step.activities.splice(itemIdx, 1);
        }
        renderRows();
        if(typeof scheduleAutosave === 'function') scheduleAutosave();
      });
    });
    
    // Édition inline
    panel.querySelectorAll('.item-text[contenteditable]').forEach(span => {
      span.addEventListener('blur', () => {
        const li = span.closest('li');
        const type = li.dataset.type;
        const itemIdx = parseInt(li.dataset.itemIdx);
        const newText = span.textContent.trim();
        if(type === 'visits' && Array.isArray(step.visits) && step.visits[itemIdx]){
          if(typeof step.visits[itemIdx] === 'string'){
            step.visits[itemIdx] = newText;
          } else {
            step.visits[itemIdx].text = newText;
          }
        } else if(type === 'activities' && Array.isArray(step.activities) && step.activities[itemIdx]){
          if(typeof step.activities[itemIdx] === 'string'){
            step.activities[itemIdx] = newText;
          } else {
            step.activities[itemIdx].text = newText;
          }
        }
        if(typeof scheduleAutosave === 'function') scheduleAutosave();
      });
      span.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          span.blur();
        }
      });
    });
    
    // Ajout d'item
    panel.querySelectorAll('.step-add-item').forEach(addRow => {
      const type = addRow.dataset.type;
      const input = addRow.querySelector('input');
      const btn = addRow.querySelector('button');
      
      const doAdd = () => {
        const text = input.value.trim();
        if(!text) return;
        if(type === 'visits'){
          if(!Array.isArray(step.visits)) step.visits = [];
          step.visits.push({ text });
        } else if(type === 'activities'){
          if(!Array.isArray(step.activities)) step.activities = [];
          step.activities.push({ text });
        }
        input.value = '';
        renderRows();
        // Ré-ouvrir le panneau après re-render
        setTimeout(() => {
          const wrapper = document.querySelector(`.step-wrapper[data-step-idx="${idx}"]`);
          const newPanel = wrapper?.querySelector('.step-details-panel');
          const toggle = wrapper?.querySelector('.step-expand-toggle');
          if(newPanel) newPanel.classList.add('open');
          if(toggle) toggle.classList.add('open');
        }, 50);
        if(typeof scheduleAutosave === 'function') scheduleAutosave();
      };
      
      btn.addEventListener('click', doAdd);
      input.addEventListener('keydown', (e) => {
        if(e.key === 'Enter'){
          e.preventDefault();
          doAdd();
        }
      });
    });
  }, 0);
  
  return panel;
}

// === ROUTING HELPERS (chunking + OSRM + Mapbox) ===

/**
 * Divise waypoints en chunks pour OSRM/Mapbox (max 20 waypoints par chunk)
 */
function chunkWaypoints(waypoints) {
  const CHUNK_SIZE = 20;
  const OVERLAP = 1;
  
  if (waypoints.length <= CHUNK_SIZE) return [waypoints];
  
  const chunks = [];
  for (let i = 0; i < waypoints.length; i += CHUNK_SIZE - OVERLAP) {
    const end = Math.min(i + CHUNK_SIZE, waypoints.length);
    chunks.push(waypoints.slice(i, end));
  }
  console.log(`[CHUNK] ${waypoints.length} pts → ${chunks.length} chunks`);
  return chunks;
}

/**
 * Assemble les résultats de chunks (remove doublons à jonctions)
 */
function combineChunkResults(chunks) {
  const combined = {
    coordinates: [],
    distance: 0,
    duration: 0
  };
  
  chunks.forEach((chunk, idx) => {
    if (idx === 0) {
      combined.coordinates = [...chunk.coordinates];
    } else {
      combined.coordinates = [...combined.coordinates, ...chunk.coordinates.slice(1)];
    }
    combined.distance += chunk.distance || 0;
    combined.duration += chunk.duration || 0;
  });
  
  console.log(`[COMBINE] ${chunks.length} chunks → ${combined.coordinates.length} coords, ${Math.round(combined.distance/1000)}km`);
  return combined;
}

/**
 * Appel OSRM pour 1 chunk (20 pts max)
 */
async function callOSRMChunk(waypoints, profile = 'car', attempt = 1) {
  const coordsStr = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/${profile}/${coordsStr}?overview=full&geometries=geojson`;
  
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s au lieu de 8s
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    
    if (res.status === 429 && attempt < 3) {
      // Rate limited - attendre et réessayer
      console.warn(`[OSRM-CHUNK] ⏳ Rate limited, retry ${attempt}/3 dans 2s...`);
      await new Promise(r => setTimeout(r, 2000 * attempt));
      return callOSRMChunk(waypoints, profile, attempt + 1);
    }
    
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    if (data.code === 'Ok' && data.routes?.[0]) {
      const route = data.routes[0];
      return {
        coordinates: route.geometry.coordinates.map(c => [c[1], c[0]]),
        distance: route.distance,
        duration: route.duration
      };
    }
    throw new Error(`OSRM code: ${data.code}`);
  } catch (e) {
    console.warn(`[OSRM-CHUNK] ❌ ${e.message}`);
    return null;
  }
}

/**
 * Appel Netlify backend pour route (fonctionne en prod, et en local avec netlify dev)
 */
async function callNetlifyRoute(waypoints, mode = 'driving') {
  // Ne fonctionne qu'en prod ou avec netlify dev
  const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
  
  // En local sans netlify dev, skip
  if (isLocal && !window._netlifyDevDetected) {
    // Tester une fois si netlify dev est actif
    if (window._netlifyDevTested === undefined) {
      try {
        const test = await fetch('/.netlify/functions/route?mode=driving&start=2.35,48.85&end=2.36,48.86', { 
          signal: AbortSignal.timeout(2000) 
        });
        window._netlifyDevDetected = test.ok;
        window._netlifyDevTested = true;
        console.log(`[NETLIFY] ${test.ok ? '✅ netlify dev détecté' : '❌ pas de netlify dev'}`);
      } catch {
        window._netlifyDevDetected = false;
        window._netlifyDevTested = true;
        console.log('[NETLIFY] ❌ pas de netlify dev');
      }
    }
    if (!window._netlifyDevDetected) return null;
  }
  
  // Construire l'URL avec start et end seulement (pas de waypoints intermédiaires supportés)
  if (waypoints.length !== 2) {
    console.warn('[NETLIFY-ROUTE] ⚠️ Seulement 2 points supportés');
    return null;
  }
  
  const start = waypoints[0]; // [lat, lon]
  const end = waypoints[waypoints.length - 1];
  const url = `/.netlify/functions/route?mode=${mode}&start=${start[1]},${start[0]}&end=${end[1]},${end[0]}&geometry=true`;
  
  try {
    console.log(`[NETLIFY-ROUTE] ⏳ Appel backend...`);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);
    const res = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);
    
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    
    if (data.ok && data.km) {
      const distance = data.km * 1000;
      const duration = data.minutes * 60;
      
      // Si geometry disponible, l'utiliser
      if (data.geometry?.coordinates?.length > 0) {
        console.log(`[NETLIFY-ROUTE] ✅ ${data.km}km (avec geometry)`);
        return {
          coordinates: data.geometry.coordinates.map(c => [c[1], c[0]]), // [lon,lat] → [lat,lon]
          distance,
          duration
        };
      }
      
      // Sinon, générer une ligne droite avec la bonne distance
      console.log(`[NETLIFY-ROUTE] ✅ ${data.km}km (ligne droite interpolée)`);
      const numPoints = Math.max(20, Math.ceil(data.km / 40));
      const coords = [];
      for (let i = 0; i <= numPoints; i++) {
        const t = i / numPoints;
        coords.push([
          start[0] + t * (end[0] - start[0]), // lat
          start[1] + t * (end[1] - start[1])  // lon
        ]);
      }
      return { coordinates: coords, distance, duration };
    }
    throw new Error(data.error || 'No data');
  } catch (e) {
    console.warn(`[NETLIFY-ROUTE] ❌ ${e.message}`);
    return null;
  }
}

/**
 * Appel Mapbox pour 1 chunk (25 pts max) - tous modes
 */
async function callMapboxChunk(waypoints, profile = 'driving') {
  const token = window.ORT_CONFIG?.MAPBOX_ACCESS_TOKEN;
  if (!token) return null;
  
  const coordsStr = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
  const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordsStr}?overview=full&geometries=geojson&access_token=${token}`;
  
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    
    const data = await res.json();
    if (data.routes?.[0]) {
      const route = data.routes[0];
      return {
        coordinates: route.geometry.coordinates.map(c => [c[1], c[0]]),
        distance: route.distance,
        duration: route.duration
      };
    }
    throw new Error('No routes');
  } catch (e) {
    console.warn(`[MAPBOX-CHUNK] ❌ ${e.message}`);
    return null;
  }
}

/**
 * Calcul route avec chunking (OSRM parallèle → Mapbox séquentiel → fallback)
 */
async function routeWithChunking(waypoints, profile = 'car', mapboxProfile = 'driving') {
  if (waypoints.length <= 25) {
    console.log(`[ROUTE] 📍 ${waypoints.length} pts: appel direct`);
    
    let result = await callOSRMChunk(waypoints, profile);
    if (result) {
      console.log(`[ROUTE] ✅ OSRM OK: ${Math.round(result.distance/1000)}km`);
      return result;
    }
    
    result = await callMapboxChunk(waypoints, mapboxProfile);
    if (result) {
      console.log(`[ROUTE] ✅ Mapbox OK: ${Math.round(result.distance/1000)}km`);
      return result;
    }
    
    // Fallback Netlify (seulement 2 points)
    if (waypoints.length === 2) {
      result = await callNetlifyRoute(waypoints, mapboxProfile);
      if (result) {
        console.log(`[ROUTE] ✅ Netlify OK: ${Math.round(result.distance/1000)}km`);
        return result;
      }
    }
    
    console.warn(`[ROUTE] ⚠️ Fallback haversine`);
    return null;
  }
  
  console.log(`[ROUTE] 🔀 ${waypoints.length} pts: découpage + chunking`);
  const chunks = chunkWaypoints(waypoints);
  
  console.log(`[ROUTE] ⏳ OSRM parallèle (${chunks.length} chunks)...`);
  const osrmResults = [];
  const MAX_PARALLEL = 3;
  
  for (let i = 0; i < chunks.length; i += MAX_PARALLEL) {
    const batch = chunks.slice(i, i + MAX_PARALLEL);
    const batchResults = await Promise.all(batch.map((chunk, idx) => callOSRMChunk(chunk, profile)));
    osrmResults.push(...batchResults);
  }
  
  if (osrmResults.every(r => r)) {
    const combined = combineChunkResults(osrmResults);
    console.log(`[ROUTE] ✅ OSRM chunked OK: ${Math.round(combined.distance/1000)}km`);
    return combined;
  }
  
  console.warn(`[ROUTE] ❌ OSRM chunked failed, essai Mapbox...`);
  
  const mapboxResults = [];
  for (const chunk of chunks) {
    const result = await callMapboxChunk(chunk, mapboxProfile);
    if (!result) {
      console.warn(`[ROUTE] ❌ Mapbox chunk échoué`);
      return null;
    }
    mapboxResults.push(result);
  }
  
  const combined = combineChunkResults(mapboxResults);
  console.log(`[ROUTE] ✅ Mapbox chunked OK: ${Math.round(combined.distance/1000)}km`);
  return combined;
}

// Calcul distance via micro-API ORT (fallback local si erreur)
async function calculateDistance(fromStep, toStep) {
  
  const fallback = () => {
    const R=6371, toRad=d=>d*Math.PI/180;
    const dLat=toRad(toStep.lat-fromStep.lat), dLon=toRad(toStep.lon-fromStep.lon);
    const a=Math.sin(dLat/2)**2+Math.cos(toRad(fromStep.lat))*Math.cos(toRad(toStep.lat))*Math.sin(dLon/2)**2;
    const km=Math.round(R*(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))));
    const minutes=Math.round((km/65)*60);
    return { km, minutes };
  };

  try {
    if (!Number.isFinite(fromStep?.lat) || !Number.isFinite(fromStep?.lon) ||
        !Number.isFinite(toStep?.lat)   || !Number.isFinite(toStep?.lon)) {
      console.warn(`[DIST] Coords invalides`);
      return { km: 0, minutes: 0 };
    }
    if (fromStep.lat === toStep.lat && fromStep.lon === toStep.lon) {
      return { km: 0, minutes: 0 };
    }

    const mode = getTransportMode();
    const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';

    // === LOCAL: OSRM DIRECT ===
    if (isLocal) {
      try {
        const osrmProfile = mode === 'driving' ? 'car' : mode === 'cycling' ? 'bike' : mode === 'walking' ? 'foot' : 'car';
        const osrmUrl = `https://router.project-osrm.org/route/v1/${osrmProfile}/${fromStep.lon},${fromStep.lat};${toStep.lon},${toStep.lat}`;
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const res = await fetch(osrmUrl, { signal: controller.signal });
        clearTimeout(timeoutId);
        
        if (res.ok) {
          const data = await res.json();
          if (data.code === 'Ok' && data.routes?.[0]) {
            const route = data.routes[0];
            const km = Math.round(route.distance / 1000);
            const minutes = Math.round(route.duration / 60);
            console.log(`[DIST] ✅ OSRM: ${km}km, ${minutes}min`);
            return { km, minutes };
          }
        }
      } catch (e) {
        console.warn(`[DIST] ❌ OSRM local: ${e.message}`);
      }
      return fallback();
    }

    // === PROD: NETLIFY → MAPBOX → OSRM ===

    // 1. Essayer backend Netlify (8s timeout)
    try {
      const apiUrl = `/.netlify/functions/route?mode=${mode}&start=${fromStep.lon},${fromStep.lat}&end=${toStep.lon},${toStep.lat}`;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);
      const res = await fetch(apiUrl, { signal: controller.signal });
      clearTimeout(timeoutId);
      
      if (res.ok) {
        const data = await res.json();
        if (data.ok && Number.isFinite(data.km) && Number.isFinite(data.minutes)) {
          return { km: data.km, minutes: data.minutes };
        }
      }
    } catch (e) {
      console.warn(`[DIST] ❌ Backend: ${e.message}`);
    }

    // 2. Fallback Mapbox (tous les modes)
    const mapboxToken = window.ORT_CONFIG?.MAPBOX_ACCESS_TOKEN;
    if (mapboxToken) {
      try {
        const mbUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${fromStep.lon},${fromStep.lat};${toStep.lon},${toStep.lat}?access_token=${mapboxToken}`;
        const res = await fetch(mbUrl);
        
        if (res.ok) {
          const data = await res.json();
          if (data.routes?.[0]) {
            const route = data.routes[0];
            const km = Math.round(route.distance / 1000);
            const minutes = Math.round(route.duration / 60);
            return { km, minutes };
          }
        }
      } catch (e) {
        console.warn(`[DIST] ❌ Mapbox: ${e.message}`);
      }
    }

    // 3. Fallback OSRM (dernier recours)
    try {
      console.log(`[DIST] ⏳ OSRM fallback...`);
      const osrmProfile = mode === 'driving' ? 'car' : mode === 'cycling' ? 'bike' : mode === 'walking' ? 'foot' : 'car';
      const osrmUrl = `https://router.project-osrm.org/route/v1/${osrmProfile}/${fromStep.lon},${fromStep.lat};${toStep.lon},${toStep.lat}`;
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 8000);
      const res = await fetch(osrmUrl, { signal: controller.signal });
      clearTimeout(timeoutId);
      
      if (res.ok) {
        const data = await res.json();
        if (data.code === 'Ok' && data.routes?.[0]) {
          const route = data.routes[0];
          const km = Math.round(route.distance / 1000);
          const minutes = Math.round(route.duration / 60);
          console.log(`[DIST] ✅ OSRM fallback: ${km}km, ${minutes}min`);
          return { km, minutes };
        }
      }
    } catch (e) {
      console.warn(`[DIST] ❌ OSRM fallback: ${e.message}`);
    }

    console.log(`[DIST] 🔴 Tous les services ont échoué`);
    return fallback();
  } catch (e) {
    console.error(`[DIST] 💥 ${e.message}`);
    return fallback();
  }
}

// === STAY22 INTEGRATION ===
const STAY22_CONFIG = {
  aid: 'oneroadtrip',
  lmaID: '692f0c75b2478d16bb9b22fa',
  baseUrlMap: 'https://www.stay22.com/embed/gm',
  maincolor: '113f7a'
};

// Mapping budget ORT → prix Stay22
const BUDGET_TO_PRICE = {
  'budget_0_50':    { min: 0, max: 50 },
  'budget_50_100':  { min: 50, max: 100 },
  'budget_100_150': { min: 100, max: 150 },
  'budget_150_200': { min: 150, max: 200 },
  'budget_200_250': { min: 200, max: 250 },
  'budget_250_300': { min: 250, max: 300 },
  'budget_300_500': { min: 300, max: 500 },
  'budget_500plus': { min: 500, max: null }
};

function getStay22PriceRange() {
  try {
    const budgetStr = localStorage.getItem('ort.budget');
    if (!budgetStr) return { min: 50, max: 150 }; // défaut
    
    const budgets = JSON.parse(budgetStr);
    if (!Array.isArray(budgets) || budgets.length === 0) return { min: 50, max: 150 };
    
    // Extraire les prix de toutes les tranches sélectionnées
    const allPrices = [];
    budgets.forEach(b => {
      const range = BUDGET_TO_PRICE[b];
      if (range) {
        allPrices.push(range.min);
        if (range.max) allPrices.push(range.max);
      }
    });
    
    if (allPrices.length === 0) return { min: 50, max: 150 };
    
    // Prendre min global et max global
    const min = Math.min(...allPrices);
    const max = Math.max(...allPrices.filter(p => p !== null));
    
    return { min, max: max || null };
  } catch (e) {
    console.warn('[STAY22] Erreur lecture budget:', e);
    return { min: 50, max: 150 };
  }
}

function getStay22CheckinDate(stepIdx) {
  // Récupérer la date depuis l'input OU state.startDateStr
  let startStr = (state.startDateStr || '').trim();
  
  // Fallback: lire directement depuis l'input si state pas à jour
  const dateInput = document.getElementById('rtStartDate');
  if (dateInput && dateInput.value) {
    startStr = dateInput.value;
  }
  
  if (!startStr) return null;
  
  try {
    // Calculer le nombre de jours avant cette étape
    let daysOffset = 0;
    for (let i = 0; i < stepIdx; i++) {
      daysOffset += Number(state.steps[i].nights || 0);
    }
    
    const startDate = new Date(startStr);
    startDate.setDate(startDate.getDate() + daysOffset);
    
    // Format YYYY-MM-DD
    return startDate.toISOString().split('T')[0];
  } catch (e) {
    return null;
  }
}

function generateStay22Url(step, idx) {
  if (!step.lat || !step.lon) return null;
  
  const itinId = (state._originalItinId || ITIN_ID || 'unknown').replace(/::/g, '_');
  const campaign = `ort_${itinId}_step${idx + 1}`;
  
  const priceRange = getStay22PriceRange();
  const checkin = getStay22CheckinDate(idx);
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.aid,
    lat: step.lat,
    lng: step.lon,
    campaign: campaign
  });
  
  if (priceRange.min !== undefined) params.set('price_min', priceRange.min);
  if (priceRange.max) params.set('price_max', priceRange.max);
  if (checkin) params.set('checkin', checkin);
  
  return `${STAY22_CONFIG.baseUrlAllez}?${params.toString()}`;
}

function generateStay22MapUrl() {
  // Centre de l'itinéraire
  const pts = (state.steps || []).filter(s => s.lat && s.lon);
  if (pts.length === 0) return null;
  
  const centerLat = pts.reduce((sum, p) => sum + p.lat, 0) / pts.length;
  const centerLng = pts.reduce((sum, p) => sum + p.lon, 0) / pts.length;
  
  const itinId = (state._originalItinId || ITIN_ID || 'unknown').replace(/::/g, '_');
  const campaign = `ort_${itinId}_map`;
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.aid,
    lat: centerLat.toFixed(6),
    lng: centerLng.toFixed(6),
    campaign: campaign,
    maincolor: STAY22_CONFIG.maincolor
  });
  
  // Titre de l'itinéraire comme nom du lieu
  if (state.title) params.set('venue', state.title);
  
  return `${STAY22_CONFIG.baseUrlMap}?${params.toString()}`;
}

function openStay22Map() {
  const url = generateStay22MapUrl();
  if (!url) {
    toast('❌ Aucune étape avec coordonnées');
    return;
  }
  
  // Ouvrir en plein écran (nouvel onglet)
  window.open(url, '_blank');
}

// Ouvrir la carte Stay22 centrée sur une étape spécifique
function openStay22MapForStep(step, idx) {
  if (!step.lat || !step.lon) {
    toast('❌ Coordonnées manquantes');
    return;
  }
  
  const itinId = (state._originalItinId || ITIN_ID || 'unknown').replace(/::/g, '_');
  const campaign = `ort_${itinId}_step${idx + 1}`;
  const checkin = getStay22CheckinDate(idx);
  const checkout = checkin ? (() => {
    const d = new Date(checkin);
    d.setDate(d.getDate() + Math.max(1, Number(step.nights || 1)));
    return d.toISOString().split('T')[0];
  })() : null;
  
  const params = new URLSearchParams({
    aid: STAY22_CONFIG.aid,
    lat: step.lat,
    lng: step.lon,
    campaign: campaign,
    maincolor: STAY22_CONFIG.maincolor
  });
  
  // Nom du lieu pour le titre de la carte
  if (step.name) params.set('venue', step.name);
  if (checkin) params.set('checkin', checkin);
  if (checkout) params.set('checkout', checkout);
  
  const url = `${STAY22_CONFIG.baseUrlMap}?${params.toString()}`;
  
  // Ouvrir en plein écran (nouvel onglet)
  window.open(url, '_blank');
}

function trLabel(lang, key){
  lang = (lang||'fr').slice(0,2).toLowerCase();
  const MAP = {
    visits:     { fr:'Visites',    en:'Visits',     it:'Visite',    es:'Visitas',   pt:'Visitas',   ar:'الزيارات' },
    activities: { fr:'Activités',  en:'Activities', it:'Attività',  es:'Actividades', pt:'Atividades', ar:'الأنشطة' }
  };
  return (MAP[key] && MAP[key][lang]) ? MAP[key][lang] : (MAP[key]?.fr || key);
}

function showStepPreview(step){
  const popup = $('#mapPopup');

  // Titre
  $('#popupTitle').textContent = step?.name || step?.place_id || '';

  // Étoiles (rating)
  const starsEl = $('#popupStars');
  if (starsEl) {
    let rating = step?.rating || 0;
    // Fallback vers PLACES_INDEX si pas de rating
    if (!rating && step?.place_id && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step.place_id]) {
      rating = PLACES_INDEX[step.place_id].rating || 0;
    }
    
    // Convertir rating (1-10) en étoiles avec les seuils normalisés
    let starCount = 0;
    if (rating >= 8.8) starCount = 5;
    else if (rating >= 7.6) starCount = 4;
    else if (rating >= 6.1) starCount = 3;
    else if (rating >= 3.1) starCount = 2;
    else if (rating > 0) starCount = 1;
    
    const fullStars = '★'.repeat(starCount);
    const emptyStars = '☆'.repeat(Math.max(0, 5 - starCount));
    
    if (rating > 0) {
      starsEl.innerHTML = `<span class="star">${fullStars}</span><span class="star-empty">${emptyStars}</span>`;
    } else {
      starsEl.innerHTML = '';
    }
  }

  // Photos - Carrousel
  const photosContainer = $('#popupPhotos');
  photosContainer.innerHTML = '';
  const imgs = Array.isArray(step?.images) ? step.images : [];
  
  if (imgs.length) {
    const carouselId = 'popup-carousel';
    const slides = imgs.map((url, i) => 
      `<div class="carousel-slide ${i === 0 ? 'active' : ''}" data-index="${i}"><img src="${url}" alt="" loading="lazy" onerror="this.parentElement.style.display='none'"></div>`
    ).join('');
    const dots = imgs.length > 1 ? imgs.map((_, i) => 
      `<div class="carousel-dot ${i === 0 ? 'active' : ''}" data-index="${i}"></div>`
    ).join('') : '';
    
    photosContainer.innerHTML = `
      <div id="${carouselId}" data-current="0" data-total="${imgs.length}" style="width:100%;height:100%;position:relative">
        ${slides}
        ${imgs.length > 1 ? `
          <button class="carousel-btn prev" onclick="carouselNavPopup(-1)">❮</button>
          <button class="carousel-btn next" onclick="carouselNavPopup(1)">❯</button>
          <div class="carousel-dots">${dots}</div>
        ` : ''}
        <div class="carousel-counter">1/${imgs.length}</div>
      </div>
    `;
  } else {
    photosContainer.innerHTML = '<div class="no-photo">' + t('noPhoto') + '</div>';
  }

  // Libellés I18N
  const visitsLbl = trLabel(document.documentElement.lang, 'visits');
  const actsLbl   = trLabel(document.documentElement.lang, 'activities');

  // === Normalisation VISITES / ACTIVITÉS ===
  // 1) supporte: tableau d'objets {text:...}, tableau de strings, objet unique, ou fallback description
  function normList(raw, fallbackFromDesc=false){
    if (Array.isArray(raw)) {
      return raw.map(v => (v && typeof v==='object' && 'text' in v) ? v.text : v)
                .map(v => String(v||'').trim())
                .filter(Boolean);
    }
    if (raw && typeof raw==='object' && 'text' in raw) {
      return [String(raw.text||'').trim()].filter(Boolean);
    }
    if (fallbackFromDesc && step?.description) {
      return String(step.description).split(/[\n\.]+/).map(s=>s.trim()).filter(Boolean);
    }
    return [];
  }

  // → certaines sources peuvent déposer visites/activities dans le cache "places master"
  //    on merge prudemment si vide.
  const fromMaster = (function(){
    const pid = step?.place_id;
    try{
      // PLACES_INDEX peut ne pas exister → try/catch
      return (pid && window.PLACES_INDEX && window.PLACES_INDEX[pid]) ? window.PLACES_INDEX[pid] : null;
    }catch(_){ return null; }
  })();

  let visitsArray = normList(step?.visits, true);
  if (!visitsArray.length && fromMaster) {
    visitsArray = normList(fromMaster.visits, true);
  }

  let actsArray = normList(step?.activities, false);
  if (!actsArray.length && fromMaster) {
    actsArray = normList(fromMaster.activities, false);
  }

  // Debug minimal (pour comprendre les cas où "visits" était là mais non rendue)
  try{
    console.debug('[POPUP] step=', step?.name || step?.place_id, 'visits.len=', visitsArray.length, 'acts.len=', actsArray.length);
  }catch(_){}

 // === TRADUCTION INTELLIGENTE SYNCHRONE + ASYNCHRONE ===
  
  const targetLang = (document.documentElement.lang || 'fr').toLowerCase();
  
// Fonction de détection améliorée - analyse CHAQUE ligne
  function detectSourceLang(text) {
    if (!text) return 'fr';
    const sample = text.toLowerCase();
    if (/\b(the|and|or|visit|see|explore|discover|museum|park|tower|panorama|day|morning|afternoon|evening|night|hiking|walking|ride|beach|sunset)\b/.test(sample)) return 'en';
    if (/\b(el|la|los|las|visita|museo|parque|día|mañana|tarde|noche|playa)\b/.test(sample)) return 'es';
    if (/\b(o|a|os|as|visita|museu|parque|dia|manhã|tarde|noite|praia)\b/.test(sample)) return 'pt';
    if (/\b(il|lo|la|i|gli|le|visita|museo|parco|giorno|mattina|pomeriggio|sera|spiaggia)\b/.test(sample)) return 'it';
    return 'fr';
  }
  
  // Traduction UNE ligne avec cache
  async function translateSingleLine(line, targetLang) {
    // NOTE: Les données sont maintenant pré-traduites, pas besoin d'API
    return line || '';
  }
  
// === VISITES ===
  let visitsHTML = '';
  if (visitsArray.length) {
    const v = visitsArray.slice(0,8).map(t=>`• ${safe(t)}`).join('<br>');
    visitsHTML = `<p><strong>🏛️ ${visitsLbl}:</strong><br>${v}</p>`;
    
 setTimeout(async () => {
      const translated = [];
      for (const line of visitsArray.slice(0,8)) {
        const result = await translateSingleLine(line, targetLang);
        translated.push(result);
      }

      const v = translated.map(t=>`• ${safe(t)}`).join('<br>');
      const div = document.getElementById('descVisits');
      if(div) div.innerHTML = `<p><strong>🏛️ ${visitsLbl}:</strong><br>${v}</p>`;
    }, 0);
  } else {
    visitsHTML = `<p><strong>🏛️ ${visitsLbl}:</strong><br>—</p>`;
  }
  
// === ACTIVITÉS ===
  let actsHTML = '';
  if (actsArray.length) {
    const a = actsArray.slice(0,8).map(t=>`• ${safe(t)}`).join('<br>');
    actsHTML = `<p><strong>🎯 ${actsLbl}:</strong><br>${a}</p>`;
    
    setTimeout(async () => {
      const translated = [];
      for (const line of actsArray.slice(0,8)) {
        translated.push(await translateSingleLine(line, targetLang));
      }
      const a = translated.map(t=>`• ${safe(t)}`).join('<br>');
      const div = document.getElementById('descActivities');
      if(div) div.innerHTML = `<p><strong>🎯 ${actsLbl}:</strong><br>${a}</p>`;
    }, 0);
  } else {
    actsHTML = `<p><strong>🎯 ${actsLbl}:</strong><br>—</p>`;
  }

  
  // Injecter le HTML (déjà traduit si en cache, ou avec placeholder)
  const base = `
    <div id="descVisits">${visitsHTML}</div>
    <div id="descActivities">${actsHTML}</div>
  `;
  
 $('#popupDesc').innerHTML = base;
  
  popup.classList.add('show');
}

let map,layer,markers=[],groupLabels=[],mapClickMode=false,popupLocked=false,popupCloseTimer=null;

// Expose un getter stable vers "markers" sans changer sa gestion interne
window.ORT = window.ORT || {};
Object.defineProperty(window.ORT, 'markers', {
  get(){ return markers; },
  configurable: true
});
Object.defineProperty(window.ORT, 'groupLabels', {
  get(){ return groupLabels; },
  configurable: true
});

// Helper: notifier quand la liste est prête/mise à jour
function __notifyMarkersReady(){
  try{ window.dispatchEvent(new CustomEvent('ort:markers-ready')); }catch(_){}
}

// + autres lieux (hors itinéraire)
let L_OTHER=null, OTHER_MARKERS=[];

function highlightMarker(idx){
  /* ... */
  const rows=$$('.step-row');   // liste de lignes
  if(rows[idx])rows[idx].classList.add('highlight');
}
function unhighlightMarker(idx){
  /* ... */
  const rows=$$('.step-row');   // liste de lignes
  if(rows[idx])rows[idx].classList.remove('highlight');
}

// === Fonctions pour marqueurs modernisés (étoiles/cercles selon rating) ===
function ratingToStars(rating) {
  if (!rating || rating === 0) return { stars: 0, color: '#CFD8DC', textColor: '#fff', radius: 3, isStar: false };
  if (rating >= 8.8) return { stars: 5, color: '#1565C0', textColor: '#fff', radius: 8, isStar: true };  // Étoile bleue
  if (rating >= 7.6) return { stars: 4, color: '#43A047', textColor: '#fff', radius: 6, isStar: false }; // Vert
  if (rating >= 6.1) return { stars: 3, color: '#7CB342', textColor: '#fff', radius: 5, isStar: false }; // Vert clair
  if (rating >= 3.1) return { stars: 2, color: '#78909C', textColor: '#fff', radius: 4, isStar: false }; // Gris-bleu
  return { stars: 1, color: '#B0BEC5', textColor: '#333', radius: 3, isStar: false }; // Gris clair (< 3.1)
}

function createStarIcon(color, size, isSelected = false) {
  const finalColor = isSelected ? '#e11d48' : color;
  return L.divIcon({
    html: `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${finalColor}" stroke="#fff" stroke-width="2">
      <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
    </svg>`,
    className: 'star-marker' + (isSelected ? ' selected' : ''),
    iconSize: [size, size],
    iconAnchor: [size/2, size/2]
  });
}

function drawMap(){
  if(!map){
    if(typeof L==='undefined'){console.error('Leaflet non chargé');return}
  try{
map=L.map('map', {
    center: [0, 0],
    zoom: 2,
    zoomControl: false,
    attributionControl: true
  });
  // === DEBUG/FIX: exposer l'instance Leaflet de façon globale ===
  window.map = map;
  console.log('[MAP] Leaflet prêt → window.map fixé, getCenter? ', typeof window.map?.getCenter);

  // Recalcule automatique si le conteneur change de taille
  const _mapEl = document.getElementById('map');

  if (window.ResizeObserver && _mapEl) {
    const ro = new ResizeObserver(()=> map && map.invalidateSize());
    ro.observe(_mapEl);
  }

  // Détection langue navigateur
  const userLang=(navigator.language||'en').split('-')[0];

      console.log('Langue carte:',userLang);
      
         // Cartodb Voyager : meilleur multilingue gratuit avec noms en anglais
      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',{
        maxZoom:20,
        attribution:'© CARTO © OpenStreetMap'
      }).addTo(map);
      
      map.on('click',async e=>{
        if(!mapClickMode)return;
        const{lat,lng}=e.latlng;
        toast('🔍 Identification.');
        const place=await reverseGeocode(lat,lng);
        if(place){
          const newStep = {
            place_id: place.place_id,
            name: place.name,
            lat: place.lat,
            lon: place.lon,
            nights: 1,
            visits: [],
            activities: [],
            images: getPhotosForPlace(place.place_id)
          };
          // __sid unique dès la création (évite fusion/sélection double)
          newStep.__sid = (typeof ensureSid === 'function')
            ? ensureSid(newStep)
            : (crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2)));

          state.steps.push(newStep);
          renderRows();
          toast(`✅ ${place.name}`);
          mapClickMode=false;
          $('#btnAddMapStep').textContent='📍 ' + t('addOnMap');
          $('#btnAddMapStep').classList.remove('active');
          $('#map').classList.remove('pointer-mode');
        }
      });
      console.log('✅ Carte initialisée');


// [J.3] Centrage global (une seule fois)
document.getElementById('centerRouteBtn')?.addEventListener('click', ()=>{
  const latlngs=[];
  (markers||[]).forEach(m=>{ const ll=m.getLatLng?.(); if(ll) latlngs.push([ll.lat,ll.lng]); });
  if(!latlngs.length){
    (state.steps||[]).forEach(s=>{
      if(Number.isFinite(s.lat)&&Number.isFinite(s.lon)) latlngs.push([s.lat,s.lon]);
    });
  }
  if(!latlngs.length) return;

  const bounds = L.latLngBounds(latlngs);
  const isStack = document.body.classList.contains('layout-stack');
  const popupShown = document.getElementById('mapPopup')?.classList.contains('show');

  // Empilé : padding symétrique (vrai centre visuel)
  if (isStack && !popupShown) {
    map.fitBounds(bounds, { padding:[40,40] });
  } else {
    // Côté-à-côté OU popup affiché : réserve de l’espace à droite (popup ~380px)
const padRight = popupShown ? 440 : 60; // 420px + marges pour éviter que l’iti passe sous le popup
    map.fitBounds(bounds, {
      paddingTopLeft: [40,40],
      paddingBottomRight: [padRight,40]
    });
  }

  // petite sécurité pour les tuiles → recalcule après animation
  setTimeout(()=>{ if (map?.invalidateSize) map.invalidateSize(); }, 80);
});

// === Handler bouton Recalculer les nuits ===
document.getElementById('btnRecalcNights')?.addEventListener('click', () => {
  const lang = (document.documentElement.lang || 'fr').slice(0, 2);
  const confirmMsg = {
    fr: 'Recalculer les nuits automatiquement ?\n\nCela va écraser vos modifications manuelles des nuits.',
    en: 'Recalculate nights automatically?\n\nThis will overwrite your manual night changes.',
    it: 'Ricalcolare le notti automaticamente?\n\nQuesto sovrascriverà le tue modifiche manuali.',
    es: '¿Recalcular las noches automáticamente?\n\nEsto sobrescribirá sus cambios manuales.',
    pt: 'Recalcular as noites automaticamente?\n\nIsso substituirá suas alterações manuais.',
    ar: 'إعادة حساب الليالي تلقائياً؟\n\nسيؤدي ذلك إلى استبدال تغييراتك اليدوية.'
  };
  
  if (!confirm(confirmMsg[lang] || confirmMsg.fr)) return;
  
  // Fermer le popup
  document.getElementById('toolsPop')?.classList.remove('show');
  
  // Nettoyer les groupes existants
  state.steps.forEach(step => {
    delete step.groupName;
    delete step.groupColor;
    delete step._isHub;
    delete step._isSatellite;
    delete step._hubGroup;
    delete step._satellites;
    delete step._mergedInto;
  });
  
  // Recalculer les nuits ET les groupes
  const targetNights = state.targetNights || state.steps.reduce((s, st) => s + (st._suggestedDays || 1), 0);
  if (typeof autoCalculateNights === 'function') autoCalculateNights(targetNights);
  
  // Re-render
  if (typeof renderRows === 'function') renderRows();
  
  const successMsg = {
    fr: '🔢 Nuits recalculées !',
    en: '🔢 Nights recalculated!',
    it: '🔢 Notti ricalcolate!',
    es: '🔢 ¡Noches recalculadas!',
    pt: '🔢 Noites recalculadas!',
    ar: '🔢 تم إعادة حساب الليالي!'
  };
  
  if (typeof toast === 'function') {
    toast(successMsg[lang] || successMsg.fr);
  }
  
  console.log('[NIGHTS] Nuits recalculées manuellement');
});


// === Handler supprimé: clustering removed ===


// === Handler supprimé: clustering removed ===


// === Handler bouton Plein écran liste ===
const _btnListFull = document.getElementById('btnListFull');
console.log('[LIST] Bouton btnListFull trouvé:', !!_btnListFull);
if (_btnListFull) {
  _btnListFull.addEventListener('click', () => {
    console.log('[LIST] Clic sur btnListFull');
    applyListView('list');
  });
  console.log('[LIST] Handler ajouté');
}

window.addEventListener('resize', ()=> {
  if (window.map?.invalidateSize) {
    window.map.invalidateSize();
  }
});      

/// === POI UNESCO & Parcs — calques + popups (photos + descriptif) ===
let L_UNESCO = null;
let L_PARKS  = null;
let POI_DESC = {}, POI_IMG = {};
let POI_LOADED = false; // Flag pour savoir si les données sont chargées

// Initialiser les cluster groups (doit être appelé après que Leaflet et le clustering soient chargés)
function initPOILayers(){
  if(L_UNESCO && L_PARKS) return;
  
  // Utiliser des featureGroup simples au lieu de clustering
  // Les marqueurs s'affichent directement sans groupement visuel
  L_UNESCO = L.featureGroup();
  L_PARKS = L.featureGroup();
}

async function loadPoiMeta(){
  try{
    const r1 = await fetch(`./data/poi_desc.fr.json`);
    POI_DESC = r1.ok ? (await r1.json()) : {};
  }catch{ POI_DESC = {}; }
  try{
    const r2 = await fetch(`./data/poi_img.json`);
    POI_IMG = r2.ok ? (await r2.json()) : {};
  }catch{ POI_IMG = {}; }
}

// URLs images sûres
function imgFrom(raw){
  if(typeof raw!=='string') return null;
  const s = raw.trim();
  if (/^(https?:)?\/\//i.test(s)) return s;
  if (s.startsWith('/') || s.startsWith('./') || s.startsWith('../')) return s;
  if (s.startsWith('data:image/')) return s;
  return null;
}

function poiIcon(color){
  return L.divIcon({
    className: "poi-marker",
    html: `<div style="color:${color};font-size:18px;font-weight:bold;line-height:18px">!</div>`,
    iconSize: [18,18]
  });
}

function addPoiMarker(p, layer){
  const color = (p.kind==='unesco') ? '#d9534f' : '#5cb85c';
  const m = L.marker([p.lat, p.lon], { icon: poiIcon(color) }).addTo(layer);

  const desc = (POI_DESC[p.id]?.short || POI_DESC[p.id]?.long) || '';
  const img  = imgFrom(POI_IMG[p.id]);
  const html = `
    <div><strong>${p.name || p.title || p.id}</strong></div>
    ${desc ? `<div style="margin-top:4px">${desc}</div>` : ``}
    ${img  ? `<img src="${img}" alt="" style="width:220px;height:150px;object-fit:cover;border-radius:6px;margin-top:6px;border:1px solid #e5e7eb">` : ``}
  `;
  m.bindPopup(html, { maxWidth: 260 });
}

async function loadStaticPOIs(){
  if (POI_LOADED) return; // Évite les chargements multiples
  
  initPOILayers(); // Initialiser les cluster groups
  
  await loadPoiMeta();
  try{
    const [ru, rp] = await Promise.all([
      fetch(`./data/unesco.fr.json`),
      fetch(`./data/parks.fr.json`)
    ]);
    const unesco = (ru.ok ? await ru.json() : []).filter(x=>Number.isFinite(x.lat)&&Number.isFinite(x.lon));
    const parks  = (rp.ok ? await rp.json() : []).filter(x=>Number.isFinite(x.lat)&&Number.isFinite(x.lon));

    L_UNESCO.clearLayers();
    L_PARKS.clearLayers();
unesco.forEach(u => addPoiMarker({ ...u, kind:'unesco' }, L_UNESCO));
parks.forEach(p => addPoiMarker({ ...p, kind:'parks'  }, L_PARKS));
    
    POI_LOADED = true;
    console.log(`✅ POI chargés: ${unesco.length} UNESCO, ${parks.length} Parcs`);
    
    // Restaurer l'état sauvegardé APRÈS le chargement
    const savedPOI = JSON.parse(localStorage.getItem('ort.poiLayers') || '{}');
    const chkU = document.getElementById('chkUnesco');
    const chkP = document.getElementById('chkParks');
    
    if (savedPOI.unesco && chkU) {
      chkU.checked = true;
      map.addLayer(L_UNESCO);
    }
    if (savedPOI.parks && chkP) {
      chkP.checked = true;
      map.addLayer(L_PARKS);
    }
    
  }catch(e){ 
    console.error('❌ Erreur chargement POI:', e);
  }
}

// === Boutons directs pour activer/désactiver Parcs et UNESCO ===
const poiCtl = L.control({ position: 'topleft' });
poiCtl.onAdd = function() {
  const div = L.DomUtil.create('div', 'leaflet-control');
  div.style.cssText = 'background:transparent;border:none;box-shadow:none';
  div.innerHTML = `
    <label style="display:flex;align-items:center;gap:6px;padding:8px 10px;background:#fff;border:2px solid #cfd6e4;border-radius:8px;margin-bottom:6px;cursor:pointer;font:600 13px/1 system-ui;box-shadow:0 2px 4px rgba(0,0,0,.1)">
      <input id="chkUnesco" type="checkbox" style="cursor:pointer;width:16px;height:16px"> <span data-i18n="unesco">UNESCO</span>
    </label>
    <label style="display:flex;align-items:center;gap:6px;padding:8px 10px;background:#fff;border:2px solid #cfd6e4;border-radius:8px;cursor:pointer;font:600 13px/1 system-ui;box-shadow:0 2px 4px rgba(0,0,0,.1)">
      <input id="chkParks" type="checkbox" style="cursor:pointer;width:16px;height:16px"> <span data-i18n="parks">Parcs</span>
    </label>`;
  L.DomEvent.disableClickPropagation(div);
  return div;
};

poiCtl.addTo(map);

// Appliquer les traductions aux nouveaux éléments
if(typeof applyI18N === 'function') applyI18N();

// Gestion des changements de checkbox
document.addEventListener('change', async (e) => {
  if (e.target.id === 'chkUnesco' || e.target.id === 'chkParks') {
    // Charger les données si pas encore fait
    if (!POI_LOADED) {
      await loadStaticPOIs();
    }
    
    const isU = e.target.id === 'chkUnesco';
    const checked = e.target.checked;
    
    try {
      if (isU) {
        if (checked) {
          if (!map.hasLayer(L_UNESCO)) map.addLayer(L_UNESCO);
        } else {
          if (map.hasLayer(L_UNESCO)) map.removeLayer(L_UNESCO);
        }
      } else {
        if (checked) {
          if (!map.hasLayer(L_PARKS)) map.addLayer(L_PARKS);
        } else {
          if (map.hasLayer(L_PARKS)) map.removeLayer(L_PARKS);
        }
      }
      
      // Sauvegarder l'état
      localStorage.setItem('ort.poiLayers', JSON.stringify({
        unesco: document.getElementById('chkUnesco')?.checked || false,
        parks:  document.getElementById('chkParks')?.checked || false
      }));
    } catch(err) {
      console.error('Erreur toggle POI:', err);
    }
  }
});

// Lancer le chargement en arrière-plan (sans bloquer)
loadStaticPOIs();


/* === [OTHER-PLACES] Calque + bouton à cocher (unique) === */
// L_OTHER sera initialisé comme cluster au premier usage dans renderOtherPlaces()

// ⇦ Passe en haut-GAUCHE pour ne plus recouvrir le layers-control
const OtherCtl = L.control({position:'topleft'});
OtherCtl.onAdd = function(){
  const div = L.DomUtil.create('div','leaflet-control');
  div.style.cssText = 'background:transparent;border:none;box-shadow:none';
  div.innerHTML = `
    <label style="display:flex;align-items:center;gap:6px;padding:8px 10px;font:600 13px/1 system-ui;background:#fff;border:2px solid #cfd6e4;border-radius:8px;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,.1)">
      <input id="toggleOtherPlaces" type="checkbox" style="margin:0;cursor:pointer;width:16px;height:16px">
      <span data-i18n="otherPlaces">Autres lieux</span>
    </label>`;
  L.DomEvent.disableClickPropagation(div);
  return div;
};

OtherCtl.addTo(map);

// Bouton "Centrer sur l'itinéraire"
const CenterCtl = L.control({position:'topleft'});
CenterCtl.onAdd = function(){
  const div = L.DomUtil.create('div','leaflet-control');
  div.style.cssText = 'background:transparent;border:none;box-shadow:none';
  div.innerHTML = `
    <button id="btnCenterItinerary" title="Centrer sur l'itinéraire" style="display:flex;align-items:center;justify-content:center;width:36px;height:36px;background:#fff;border:2px solid #cfd6e4;border-radius:8px;cursor:pointer;box-shadow:0 2px 4px rgba(0,0,0,.1);font-size:18px">
      🎯
    </button>`;
  L.DomEvent.disableClickPropagation(div);
  return div;
};
CenterCtl.addTo(map);

document.getElementById('btnCenterItinerary')?.addEventListener('click', () => {
  if (window.state?.steps?.length > 1) {
    const bounds = [];
    window.state.steps.forEach(s => {
      if (s.lat && (s.lon || s.lng)) bounds.push([s.lat, s.lon || s.lng]);
    });
    if (bounds.length > 0) {
      map.fitBounds(bounds, { padding: [50, 50], maxZoom: 12 });
    }
  }
});

// Appliquer les traductions aux nouveaux éléments
if(typeof applyI18N === 'function') applyI18N();

// Charge le master si nécessaire AVANT d'afficher les points
const $togOther = document.getElementById('toggleOtherPlaces');
$togOther?.addEventListener('change', async (e) => {
  if (e.target.checked) {
    // Collecter tous les pays des steps
    const countriesFromSteps = [];
    if (state.steps && state.steps.length > 0) {
      state.steps.forEach(s => {
        if (s.cc) countriesFromSteps.push(s.cc.toUpperCase());
      });
    }
    
    // Recharger les places avec tous les pays
    await ensurePlacesIndex(countriesFromSteps);
    console.log('[OTHER] places dans master =', Object.keys(PLACES_INDEX || {}).length);
    renderOtherPlaces();
  } else {
    clearOtherPlaces();
  }
});


/* === [OTHER-PLACES] Rendu / hover / click === */
function clearOtherPlaces(){
  try{ L_OTHER?.clearLayers(); }catch(_){}	
  OTHER_MARKERS = [];
}

// Popup HTML au survol d’un “autre lieu”
function otherHoverHTML(p){
  // On NE fait pas d’appel réseau ici (hover doit être instantané).
  const photos = getPhotosForPlace(p.pid) || [];
  const img = photos[0] || null;
  const safe = (v)=>String(v||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  return `
    <div style="font:600 13px/1.2 system-ui;color:#0b3b6f">${safe(p.name||p.pid)}</div>
    ${img ? `<img src="${safe(img)}" alt="" style="display:block;width:220px;height:140px;object-fit:cover;border-radius:6px;margin-top:6px;border:1px solid #e5e7eb">` : ``}
    <div style="margin-top:6px;color:#475569;font:12px system-ui">
      <em>Place master (hors itinéraire)</em>
    </div>
  `;
}

// ouverture du panneau latéral existant avec bouton “Ajouter à l’itinéraire”
function openOtherPlaceDetails(p){
  const popup  = document.getElementById('mapPopup');
  const photos = document.getElementById('popupPhotos');
  const title  = document.getElementById('popupTitle');
  const desc   = document.getElementById('popupDesc');

  // 1) Titre / Photos
  if (title)  title.textContent = p.name || p.pid || '';
  if (photos) {
    photos.innerHTML = '';
    (getPhotosForPlace(p.pid)||[]).slice(0,4).forEach(u=>{
      const img=new Image(); img.src=u; img.loading='lazy';
      img.onerror=()=>img.style.display='none';
      photos.appendChild(img);
    });
  }

  // 2) Contenus + bouton
  const visitsLbl = trLabel(document.documentElement.lang,'visits');
  const actsLbl   = trLabel(document.documentElement.lang,'activities');
  const v = (p.visits||[]).map(x=>safe(x.text||x)).slice(0,8).map(t=>'• '+t).join('<br>') || '—';
  const a = (p.activities||[]).map(x=>safe(x.text||x)).slice(0,8).map(t=>'• '+t).join('<br>') || '—';

  if (desc) {
    // vider puis injecter → évite les handlers “fantômes”
    desc.textContent = '';
    desc.insertAdjacentHTML('afterbegin', `
      <p class="mut" style="margin:6px 0 10px">Lieu hors trajet (places master)</p>
      <p><strong>🏛️ ${visitsLbl}:</strong><br>${v}</p>
      <p><strong>🎯 ${actsLbl}:</strong><br>${a}</p>
      <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end">
        <button id="btnAddOther" class="btn" type="button">+ Ajouter à l’itinéraire</button>
      </div>
    `);

    const addBtn = desc.querySelector('#btnAddOther');
    if (addBtn) {
      addBtn.addEventListener('click', ()=>{
        const newStep = {
          place_id: p.pid,
          name: p.name,
          lat: p.lat,
          lon: p.lon,
          nights: 1,
          visits: Array.isArray(p.visits)? p.visits : [],
          activities: Array.isArray(p.activities)? p.activities : [],
          images: getPhotosForPlace(p.pid),
          description: (p.visits||[]).map(v=>v.text||v).join('. ')
        };
        // __sid unique dès la création
        newStep.__sid = (typeof ensureSid === 'function') ? ensureSid(newStep) : (crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2)));
        state.steps.push(newStep);
        renderRows();
        popup?.classList.remove('show');
        toast(`✅ ${p.name} ajouté`);
      }, { once: true }); // évite les doublons au re-clic
    }
  }

  // 3) Ouvrir le panneau
  if (popup) popup.classList.add('show');
}

// [OTHER] Résolution robuste du code pays courant + cache process
function getCurrentCC(){
  // 0) cache process-wide
  if (typeof window.__CC_CACHE === 'string') return window.__CC_CACHE;

  // 1) depuis l'état courant (ordre: state.cc > state.country > CC global)
  const fromState = (window.state?.cc || window.state?.country || window.CC || '').toString().trim().toUpperCase();
  if (/^[A-Z]{2}$/.test(fromState)) return (window.__CC_CACHE = fromState);

  // 2) depuis le voyage sauvegardé (ex: savedTrip.country = 'FR')
  const fromSaved = (window.savedTrip?.country || '').toString().trim().toUpperCase();
  if (/^[A-Z]{2}$/.test(fromSaved)) return (window.__CC_CACHE = fromSaved);

  // 3) depuis la première étape du trip (prefixe "CC::slug")
  const pid = window.state?.steps?.find(s => typeof s?.place_id === 'string')?.place_id || '';
  const ccFromPid = (pid.split('::')[0] || '').toUpperCase();
  if (/^[A-Z]{2}$/.test(ccFromPid)) return (window.__CC_CACHE = ccFromPid);

  // 4) fallback: tenter une étape présente dans le master (si le pid existe)
  if (Array.isArray(window.state?.steps) && window.PLACES_INDEX) {
    for (const s of window.state.steps) {
      const pid2 = s?.place_id || '';
      if (pid2 && window.PLACES_INDEX[pid2]) {
        const cc2 = (pid2.split('::')[0] || '').toUpperCase();
        if (/^[A-Z]{2}$/.test(cc2)) return (window.__CC_CACHE = cc2);
      }
    }
  }

  // 5) échec → valeur neutre
  return (window.__CC_CACHE = 'XX');
}

function renderOtherPlaces(){
  clearOtherPlaces();
  
  // Initialiser L_OTHER comme feature group simple (sans clustering)
  if(!L_OTHER){
    L_OTHER = L.featureGroup().addTo(map);
  }
  
  if(!PLACES_INDEX || !Object.keys(PLACES_INDEX).length){
    console.warn('[OTHER] PLACES_INDEX vide – rien à afficher');
    return;
  }

// set des place_id déjà dans l'itinéraire
  const inTrip = new Set((state.steps||[]).map(s=>s.place_id));

  // Collecter TOUS les pays du voyage (pas juste le CC principal)
  const ccSet = new Set();
  const mainCC = getCurrentCC();
  if (mainCC && mainCC !== 'XX') ccSet.add(mainCC.toUpperCase());
  
  // Ajouter les pays de toutes les étapes
  (state.steps || []).forEach(s => {
    if (s.cc) ccSet.add(s.cc.toUpperCase());
  });
  
  // Ajouter les pays présents dans PLACES_INDEX
  Object.values(PLACES_INDEX).forEach(p => {
    if (p.cc) ccSet.add(p.cc.toUpperCase());
  });

  // si aucun pays trouvé, retry
  if (ccSet.size === 0 && !window.__OTHER_RETRY_LOCK__) {
    window.__OTHER_RETRY_LOCK__ = true;
    setTimeout(() => { window.__CC_CACHE = undefined; renderOtherPlaces(); }, 0);
    return;
  }
  window.__OTHER_RETRY_LOCK__ = false;

  const list = [];
  for(const pid in PLACES_INDEX){
    const placeCC = pid.split('::')[0];
    if (!ccSet.has(placeCC.toUpperCase())) continue;
    if(inTrip.has(pid)) continue;
    const m = PLACES_INDEX[pid];
    if(!Number.isFinite(m.lat)||!Number.isFinite(m.lon)) continue;
    list.push({
      pid, lat:m.lat, lon:m.lon,
      name:m.name||pid.split('::')[1],
      visits: m.visits || [],
      activities: m.activities || []
    });
  }

  console.log('[OTHER] Pays:', Array.from(ccSet).join(', '), '| Lieux:', list.length);


  // (optionnel) limiter l’affichage brut
  const MAX = 1500;
  const items = list.slice(0, MAX);

   items.forEach(p=>{
    // Récupérer rating pour couleur
    const rating = PLACES_INDEX[p.pid]?.rating || 0;
    const starInfo = ratingToStars(rating);
    
    let ico;
    if (starInfo.isStar) {
      // Étoile pour les incontournables (5★)
      ico = L.marker([p.lat, p.lon], {
        icon: createStarIcon(starInfo.color, 20)
      });
      ico.starInfo = starInfo;
    } else {
      // Cercle pour les autres
      ico = L.circleMarker([p.lat, p.lon], {
        radius: starInfo.radius + 2,
        weight: 1.5,
        color: '#fff',
        fillColor: starInfo.color,
        fillOpacity: 0.85
      });
      ico.starInfo = starInfo;
    }
    ico.addTo(L_OTHER);

    // Survol: tooltip sticky (fiable, disparaît à la sortie)
    ico.bindTooltip(otherHoverHTML(p), {
      sticky: true, direction: 'top', opacity: 1, className: 'ort-hover'
    });
    ico.on('mouseover', ()=> ico.openTooltip());
    ico.on('mouseout',  ()=> ico.closeTooltip());

    // Clic: ouvre le panneau latéral avec bouton d’ajout
    ico.on('click', ()=> openOtherPlaceDetails(p));
    OTHER_MARKERS.push(ico);
  });

}
    }catch(e){ console.error('Carte:', e); return; }
  }
  
  // Curseur pointeur en mode ajout
  if(mapClickMode){
    $('#map').classList.add('pointer-mode');
  }else{
    $('#map').classList.remove('pointer-mode');
  }
  
  // Nettoyer tous les éléments de la carte
  markers.forEach(m=>m.remove());
  markers = [];
  
  // Nettoyer les mini-marqueurs de groupe
  groupLabels.forEach(gl => { try { gl.remove(); } catch(_) {} });
  groupLabels = [];
  
  // Nettoyer l'ancienne polyline/route
  if (layer) { 
    try { map.removeLayer(layer); } catch(_) {} 
    layer = null; 
  }
  
  // Nettoyer TOUTES les polylines orphelines (sécurité anti-doublons)
  map.eachLayer(l => {
    if (l instanceof L.Polyline && !(l instanceof L.Polygon)) {
      try { map.removeLayer(l); } catch(_) {}
    }
  });
  
  // Version unique pour ce drawMap (annule les calculs précédents)
  window._drawMapVersion = (window._drawMapVersion || 0) + 1;
  const thisVersion = window._drawMapVersion;
  
  console.log('[MAP] 🧹 Nettoyage effectué (markers, groupLabels, layer) - version:', thisVersion);

  // Utiliser window.state.steps si restauré via fallback, sinon state.steps
  const stepsForMap = (window.state?.steps && window.state.steps.length > 0) ? window.state.steps : state.steps;
  const pts=stepsForMap.filter(s=>s.lat!=null&&s.lon!=null);
  if(!pts.length){map.setView([48.8566,2.3522],5);return}
// [PATCH-GROUP-LABELS] START
// === Regrouper les étapes très proches (grille ~100–150 m) & labels communs ===
const grouped = {};
pts.forEach((p, idx) => {
  const key = `${p.lat.toFixed(3)},${p.lon.toFixed(3)}`; // tolérance ~100-150 m
  if (!grouped[key]) grouped[key] = [];
  grouped[key].push(idx);
});

Object.entries(grouped).forEach(([key, indices]) => {
  const [gLat, gLon] = key.split(',').map(Number);

  // 1) Marqueurs pile sur leur coord (aucun offset)
  indices.forEach((i) => {
    const step = pts[i];
    
    // Récupérer rating pour couleur
    let stepRating = step.rating || 0;
    if (!stepRating && typeof PLACES_INDEX !== 'undefined' && PLACES_INDEX && PLACES_INDEX[step.place_id]) {
      stepRating = PLACES_INDEX[step.place_id].rating || 0;
    }
    const starInfo = ratingToStars(stepRating);
    
    // Drapeau pour les hubs (étapes avec nuits d'hôtel)
    const isHub = step._isHub || (step.nights && step.nights > 0);
    const flagHtml = isHub ? '<span class="hub-flag">🚩</span>' : '';
    
    const iconHtml = `<div class="marker-num">${(i + 1)}${flagHtml}</div>`;
    const icon = L.divIcon({ html: iconHtml, className: 'step-marker', iconSize: [24, 24] });
        const m = L.marker([step.lat, step.lon], {
      draggable: true,
      icon,
      riseOnHover: true,
      riseOffset: 1000
    }).addTo(map);
    
    // Appliquer couleur basée sur le rating
    setTimeout(() => {
      const el = m.getElement();
      if (el) {
        el.style.setProperty('background', starInfo.color, 'important');
        if (starInfo.textColor === '#333') {
          el.style.setProperty('color', '#333', 'important');
        }
      }
    }, 10);

    // ID stable et unique (pas basé sur l'index courant)
    m.stepId = (typeof ensureSid === 'function') ? ensureSid(step) : (step.__sid || (step.__sid = crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2))));
    markers.push(m);


    // hover
  // 🎯 HOVER pour desktop
    m.on('mouseover', () => {
      const row = document.querySelector(`.step-row[data-step-id="${m.stepId}"]`);
      if(row){ row.classList.add('highlight'); row.scrollIntoView({block:'nearest'}); }
      m.getElement()?.querySelector('.marker-num')?.classList.add('num-boost');
      m.setZIndexOffset?.(1500);
      
      // Annuler le timer de fermeture si on repasse sur le marqueur
      if(popupCloseTimer) {
        clearTimeout(popupCloseTimer);
        popupCloseTimer = null;
      }
      
      // En mode plein écran carte : afficher le popup informatif (non verrouillé)
      // MAIS PAS en mode réorganisation pour éviter le blocage
      const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
      if(document.body.classList.contains('view-map-only') && !window.popupLocked && !reorgActive){
        showStepPreview(step);
      }
    });
    
    m.on('mouseout', () => {
      const row = document.querySelector(`.step-row[data-step-id="${m.stepId}"]`);
      if(row) row.classList.remove('highlight');
      m.getElement()?.querySelector('.marker-num')?.classList.remove('num-boost');
      m.setZIndexOffset?.(0);
      
      // En mode plein écran carte : masquer le popup avec délai (debounce)
      // pour éviter que la modale qui recouvre le marqueur ne déclenche mouseout
      const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
      if(document.body.classList.contains('view-map-only') && !window.popupLocked && !reorgActive){
        popupCloseTimer = setTimeout(() => {
          document.getElementById('mapPopup')?.classList.remove('show');
          popupCloseTimer = null;
        }, 200); // 200ms de délai pour laisser le curseur atteindre la modale
      }
    });

    // 📱 TAP LONG pour mobile/tablette (afficher preview en mode plein écran)
    let tapTimer = null;
    let touchMoved = false;
    
    m.on('touchstart', (e) => {
      touchMoved = false;
      const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
      
      // En mode plein écran : tap long = preview
      if(document.body.classList.contains('view-map-only') && !reorgActive){
        tapTimer = setTimeout(() => {
          if(!touchMoved){
            window.popupLocked = true; // Verrouiller pour éviter la fermeture
            showStepPreview(step);
            m.getElement()?.querySelector('.marker-num')?.classList.add('num-boost');
          }
        }, 500); // 500ms = tap long
      }
    });
    
    m.on('touchmove', () => {
      touchMoved = true;
      if(tapTimer){ clearTimeout(tapTimer); tapTimer = null; }
    });
    
    m.on('touchend', () => {
      if(tapTimer){ clearTimeout(tapTimer); tapTimer = null; }
    });

       // dragend (MAJ immédiate des coords, reverse en arrière-plan)
    m.on('dragend', async e => {
      const ll = e.target.getLatLng();

      // 1) MAJ immédiate → recalcul instantané des segments/compteurs
      step.lat = ll.lat;
      step.lon = ll.lng;
      renderRows(); // redessine markers, polyline, distances, totaux

      // 2) Résolution place_id/name sans bloquer l'UI
      try{
        const place = await reverseGeocode(ll.lat, ll.lng);
        if(place){
          Object.assign(step, {
            lat: place.lat,
            lon: place.lon,
            place_id: place.place_id,
            name: place.name,
            images: getPhotosForPlace(place.place_id)
          });
          renderRows();
          toast(`✅ ${place.name}`);
        }else{
          toast('✅ Position mise à jour');
        }
      }catch(_){
        toast('✅ Position mise à jour');
      }
    });

    // CLICK: ouvrir étape (si connecté) / pop-up I18N (si non connecté) — hors mode réorganisation
    m.on('click', (e) => {
      const panelShown = document.getElementById('reorgPanel')?.classList.contains('show');
      const reorgMode  = document.body.classList.contains('reorg-active') || panelShown;
      
      // En mode réorganisation : déclencher la sélection dans le panneau
      if (reorgMode) {
        const sid = m.stepId;
        if(sid && typeof window.handleStepClick === 'function'){
          console.log('[MAP] Mode réorg - clic sur marqueur, sid:', sid);
          window.handleStepClick(sid);
        }
        return;
      }
      
      // Toujours highlight et scroll vers la ligne correspondante dans le panneau
      const row = document.querySelector(`.step-row[data-step-id="${m.stepId}"]`);
      if(row){
        // Enlever highlight des autres
        document.querySelectorAll('.step-row.highlight').forEach(r => r.classList.remove('highlight'));
        row.classList.add('highlight');
        row.scrollIntoView({block:'nearest', behavior:'smooth'});
      }
      
      // En mode ajout carte, on ne navigue pas - juste sélection
      if(mapClickMode){
        console.log('[MAP] Mode ajout - étape sélectionnée:', step.name);
        return;
      }
      
      const iconEl = m.getElement() || document.body; // ancre visuelle pour le popover
      // retrouver l'index réel dans stepsForMap via __sid (index pts ≠ index steps possibles)
      const sid = m.stepId;
      const realIdx = (sid)
        ? (stepsForMap || []).findIndex(s => (typeof ensureSid==='function'?ensureSid(s):(s.__sid)) === sid)
        : (stepsForMap || []).indexOf(step);
      const u = (typeof currentUser === 'function') ? currentUser() : null;
      if (u) {
        openStepPage(step, Math.max(0, realIdx));
      } else {
        showGoPopover(iconEl, step, Math.max(0, realIdx));
      }
    });
  });


  /// 2) Ajoute des mini-marqueurs individuels pour chaque sous-étape
  if (indices.length > 1) {
    indices.forEach((stepIndex, subIndex) => {
      const step = stepsForMap[stepIndex];
      const sid  = (typeof ensureSid === 'function') ? ensureSid(step) : (step.__sid || (step.__sid = crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2))));
      const stepNumber = stepIndex + 1;

      const angle = (subIndex / (indices.length - 1)) * Math.PI - Math.PI / 2;
      const radius = 0.0015;
      const offsetLat = step.lat + (Math.sin(angle) * radius);
      const offsetLon = step.lon + (Math.cos(angle) * radius);

      const miniMarker = L.marker([offsetLat, offsetLon], {
        icon: L.divIcon({
          html: `<div class="mini-step-marker" data-step-id="${sid}">
                   <div class="mini-step-num">${stepNumber}</div>
                 </div>`,
          className: '',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        }),
        interactive: true,
        zIndexOffset: 100 + subIndex
      }).addTo(map);

      // Stocker le stepId sur le marqueur
      miniMarker.stepId = sid;
      miniMarker.isMiniMarker = true;
      
      // Événements hover pour agrandir
      // Événements hover pour agrandir ET afficher le popup
      miniMarker.on('mouseover', function() {
        const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
        if (el) {
          el.classList.add('mini-step-marker-hover');
        }
        
        // Afficher le popup informatif en mode plein écran carte (hors réorganisation)
        const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
        if (document.body.classList.contains('view-map-only') && !window.popupLocked && !reorgActive) {
          showStepPreview(step);
          document.getElementById('mapPopup')?.classList.add('show');
        }
      });
      
      miniMarker.on('mouseout', function() {
        const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
        if (el) {
          el.classList.remove('mini-step-marker-hover');
        }
        
        // Masquer le popup si non verrouillé
        const reorgActive = document.getElementById('reorgPanel')?.classList.contains('show');
        if (document.body.classList.contains('view-map-only') && !window.popupLocked && !reorgActive) {
          document.getElementById('mapPopup')?.classList.remove('show');
        }
      });
      
      // Stocker dans groupLabels pour pouvoir les gérer en mode réorg
      groupLabels.push(miniMarker);
    });
  }
});
// [PATCH-GROUP-LABELS] END

// ===== FONCTIONS DE CALCUL D'ITINÉRAIRE =====

/**
 * Calcule un itinéraire selon le mode de transport
 */
async function calculateRoute(waypoints, mode = 'driving') {
  console.log('[ROUTE] 🗺️ Calcul itinéraire:', mode, waypoints.length, 'points');
  
  const modeConfig = TRANSPORT_MODES[mode];
  if (!modeConfig) {
    console.error('[ROUTE] Mode inconnu:', mode);
    return { type: 'fallback', coordinates: waypoints };
  }
  
  if (modeConfig.api === 'osrm') {
    return calculateOSRMRoute(waypoints, mode);
  }
  
  if (modeConfig.api === 'mapbox') {
    return calculateMapboxRoute(waypoints, mode);
  }
  
  return { type: 'fallback', coordinates: waypoints };
}

/**
 * Calcul route OSRM (voiture, vélo, pieds) avec fallback Mapbox
 */
async function calculateOSRMRoute(waypoints, mode) {
  console.log(`[OSRM-ROUTE] ${waypoints.length} pts, mode=${mode}`);
  
  const osrmProfile = mode === 'driving' ? 'car' : mode === 'cycling' ? 'bike' : 'foot';
  const mapboxProfile = mode === 'driving' ? 'driving' : mode === 'cycling' ? 'cycling' : 'walking';
  
  const result = await routeWithChunking(waypoints, osrmProfile, mapboxProfile);
  
  if (result) {
    const color = mode === 'cycling' ? '#00bcd4' : mode === 'walking' ? '#4caf50' : '#113f7a';
    return {
      type: 'osrm', mode, coordinates: result.coordinates,
      distance: result.distance, duration: result.duration, color
    };
  }
  
  console.warn('[OSRM-ROUTE] 🔴 Fallback ligne droite');
  return { type: 'fallback', coordinates: waypoints };
}

/**
 * Calcul route Mapbox (train, métro, bus, voiture)
 */
async function calculateMapboxRoute(waypoints, mode) {
  try {
    const accessToken = window.ORT_CONFIG?.MAPBOX_ACCESS_TOKEN;
    const baseUrl = window.ORT_CONFIG?.MAPBOX_BASE_URL || 'https://api.mapbox.com/directions/v5/mapbox';
    
    if (!accessToken) {
      console.warn('[MAPBOX] ⚠️ Token manquant');
      toast('⚠️ Mapbox : token requis (voir ort-config.js)', 4000);
      return { type: 'fallback', coordinates: waypoints, color: '#ff5722', dashArray: '10, 5' };
    }
    
    // Mode Mapbox : driving-traffic / walking / cycling / driving
    // Pour transit, on utilise un profil spécial ou on combine
    const mapboxProfile = mode === 'transit' ? 'driving' : mode;
    
    console.log('[MAPBOX] 🗺️ Profil:', mapboxProfile);
    
    // Mapbox limite à 25 waypoints par requête
    if (waypoints.length > 25) {
      console.warn('[MAPBOX] ⚠️ Trop de waypoints (', waypoints.length, '), simplification...');
      // Garder seulement les points importants (début, fin, et quelques intermédiaires)
      const step = Math.ceil(waypoints.length / 24);
      const simplified = waypoints.filter((_, i) => i === 0 || i === waypoints.length - 1 || i % step === 0);
      waypoints = simplified;
      console.log('[MAPBOX] ✅ Simplifié à', waypoints.length, 'waypoints');
    }
    
    // Format Mapbox : lon,lat;lon,lat;...
    const coordsStr = waypoints.map(wp => `${wp[1]},${wp[0]}`).join(';');
    
    // URL Mapbox Directions
    const mapboxUrl = `${baseUrl}/${mapboxProfile}/${coordsStr}?geometries=geojson&overview=full&access_token=${accessToken}`;
    
    console.log('[MAPBOX] 🚀 Requête:', mapboxUrl.substring(0, 120) + '...');
    
    const response = await fetch(mapboxUrl);
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) {
      throw new Error('Aucune route trouvée');
    }
    
    const route = data.routes[0];
    const coordinates = route.geometry.coordinates.map(c => [c[1], c[0]]); // [lon,lat] → [lat,lon]
    
    console.log('[MAPBOX] ✅ Route calculée:', {
      distance: (route.distance / 1000).toFixed(1) + ' km',
      duration: (route.duration / 3600).toFixed(1) + ' h',
      points: coordinates.length
    });
    
    // Couleur selon le mode
    let color = '#113f7a'; // Bleu par défaut (voiture)
    let dashArray = null;
    
    if (mode === 'transit') {
      color = '#ff5722'; // Rouge pour train
      dashArray = '10, 5'; // Pointillés
    } else if (mode === 'cycling') {
      color = '#00bcd4'; // Cyan pour vélo
    } else if (mode === 'walking') {
      color = '#4caf50'; // Vert pour pieds
    }
    
    return {
      type: 'mapbox',
      mode: mode,
      coordinates: coordinates,
      distance: route.distance, // mètres
      duration: route.duration, // secondes
      color: color,
      weight: 3,
      dashArray: dashArray
    };
    
  } catch (error) {
    console.error('[MAPBOX] ❌ Erreur:', error);
    toast('❌ Erreur Mapbox : ' + error.message, 3000);
    return { 
      type: 'fallback', 
      coordinates: waypoints, 
      color: '#ff5722', 
      dashArray: '10, 5' 
    };
  }
}
// ===== FIN FONCTIONS DE CALCUL =====

  // supprimer l'ancienne polyline si présente
  if (layer) { try { map.removeLayer(layer); } catch(_) {} layer = null; }

  const latlngs = pts.map(p => [p.lat, p.lon]);
  
  // ===== CALCUL DE ROUTE SELON LE MODE =====
  const transportMode = getTransportMode();
  console.log('[MAP] 🗺️ Mode de transport actif:', transportMode);
  
  // Afficher ligne temporaire pendant calcul
  const tempLayer = L.polyline(latlngs, { 
    color: '#113f7a', 
    weight: 2, 
    opacity: 0.3, 
    dashArray: '5, 10' 
  }).addTo(map);
  
  // Calculer la route
  calculateRoute(latlngs, transportMode).then(result => {
    // Supprimer ligne temporaire
    try { map.removeLayer(tempLayer); } catch(_) {}
    
    // Vérifier si cette version est toujours la courante (sinon ignorer)
    if (window._drawMapVersion !== thisVersion) {
      console.log('[MAP] ⏭️ Route ignorée (version obsolète:', thisVersion, 'vs', window._drawMapVersion, ')');
      return;
    }
    
    if (result.type === 'fallback') {
      // Fallback : ligne droite
      console.log('[MAP] ⚠️ Fallback: ligne droite');
      layer = L.polyline(result.coordinates, { 
        color: result.color || '#113f7a', 
        weight: 3, 
        opacity: 0.8,
        dashArray: result.dashArray || null
      }).addTo(map);
    } else {
      // Route calculée
      console.log('[MAP] ✅ Route affichée:', result.type);
      layer = L.polyline(result.coordinates, { 
        color: result.color || '#113f7a', 
        weight: result.weight || 3, 
        opacity: 0.8,
        dashArray: result.dashArray || null
      }).addTo(map);
      
      // Afficher les infos dans un toast
      if (result.distance && result.duration) {
        const distKm = (result.distance / 1000).toFixed(1);
        const durationH = (result.duration / 3600).toFixed(1);
        toast(`📍 ${distKm} km • 🕐 ${durationH}h`, 3000);
      }
    }
  }).catch(error => {
    console.error('[MAP] ❌ Erreur calcul route:', error);
    try { map.removeLayer(tempLayer); } catch(_) {}
    
    // Vérifier la version avant fallback
    if (window._drawMapVersion !== thisVersion) return;
    
    layer = L.polyline(latlngs, { color: '#113f7a', weight: 3, opacity: 0.8 }).addTo(map);
  });
  
  // ===== FIN CALCUL DE ROUTE =====


// Centrage adaptatif selon le layout
  const isStack = document.body.classList.contains('layout-stack');
  const popupVisible = document.getElementById('mapPopup')?.classList.contains('show');
  
  // Padding symétrique par défaut pour bien voir tout l'itinéraire
  let fitOptions = { padding: [50, 50] };
  
  // Si layout côte-à-côte ET pas en mode empilé : petit décalage seulement
  if (!isStack) {
    fitOptions = { paddingTopLeft: [60, 40], paddingBottomRight: [60, 40] };
  }
  
  // Si popup visible : réserver de l'espace à droite
  if (popupVisible) {
    fitOptions = isStack 
      ? { padding: [50, 50] }
      : { paddingTopLeft: [60, 40], paddingBottomRight: [440, 40] };
  }
  
  map.fitBounds(L.latLngBounds(latlngs), fitOptions);
  
  // Force le recalcul de la taille du conteneur APRÈS fitBounds
  setTimeout(() => {
    if (map && map.invalidateSize) {
      map.invalidateSize();
      // Re-fit après recalcul avec les mêmes options
      map.fitBounds(L.latLngBounds(latlngs), fitOptions);
    }
  }, 150);  
  // Notifier que les marqueurs sont prêts  // Notifier que les marqueurs sont prêts
  __notifyMarkersReady();
}

async function reverseGeocode(lat,lon){
  try{
    // IMPORTANT : forcer la langue anglaise pour Nominatim
    const nomUrl=`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&accept-language=en&zoom=10`;
    const nomRes=await fetch(nomUrl,{headers:{'User-Agent':'OneRoadTrip/1.0'}});
    const nomData=await nomRes.json();
    
    if(!nomData||!nomData.address){
      toast('❌ Lieu non identifié');
      return null;
    }
    
    console.log('Nominatim data:',nomData);
    
    const addr=nomData.address;
    // Essayer plusieurs champs pour trouver le nom de la ville
    const cityRaw=addr.city||addr.town||addr.village||addr.municipality||addr.county||addr.state;
    const country=addr.country_code?.toUpperCase()||'XX';
    
    if(!cityRaw){
      toast('❌ Ville non trouvée');
      return null;
    }
    
    console.log('Nominatim city (EN):',cityRaw,country);
    
    // Le nom anglais de Nominatim devrait correspondre à ce qu'on voit sur la carte CARTO
    // Pas besoin de recherche supplémentaire si on a un bon résultat
    const slug=cityRaw.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
    
    // Vérifier avec l'API Search pour avoir des coordonnées précises
try{
  const searchUrl = `${SEARCH_API}/citysearch?q=${encodeURIComponent(cityRaw)}&country=${country}&lang=en&limit=10`;
  console.log('API Search:',searchUrl);
  const searchRes=await fetch(searchUrl);

      
      if(searchRes.ok){
        const searchData=await searchRes.json();
        const items=searchData.items||[];
        console.log('API Results:',items.length,'items');
        
        if(items.length>0){
          // Prendre le premier résultat qui correspond au nom
          const exactMatch=items.find(item=>item.name.toLowerCase()===cityRaw.toLowerCase());
          if(exactMatch&&exactMatch.lat&&exactMatch.lon){
            const slug2=exactMatch.name.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
            console.log('Exact match:',exactMatch.name);
            return{place_id:`${exactMatch.countryCode}::${slug2}`,name:exactMatch.name,lat:exactMatch.lat,lon:exactMatch.lon};
          }
          
          // Sinon chercher le plus proche géographiquement
          let best=null,minDist=Infinity;
          for(const item of items){
            if(!item.lat||!item.lon)continue;
            const dist=Math.sqrt(Math.pow(item.lat-lat,2)+Math.pow(item.lon-lon,2));
            if(dist<minDist){minDist=dist;best=item}
          }
          
          if(best&&minDist<0.5){
            const slug3=best.name.toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/[^a-z0-9]+/g,'-');
            console.log('Best match:',best.name,'distance:',minDist);
            return{place_id:`${best.countryCode}::${slug3}`,name:best.name,lat:best.lat,lon:best.lon};
          }
        }
      }
    }catch(e){
      console.error('API Search error:',e);
    }
    
    // Fallback: nom anglais de Nominatim (devrait correspondre à la carte)
    console.log('Using Nominatim result:',cityRaw);
    return{place_id:`${country}::${slug}`,name:cityRaw,lat:lat,lon:lon};
    
  }catch(err){
    console.error('Geocode error:',err);
    toast('❌ Erreur identification');
    return null;
  }
}

function enableDnD(){
  $$('.step-row').forEach(r=>{
    r.addEventListener('dragstart',e=>{
      r.classList.add('dragging');
      // Marquer aussi le wrapper parent
      const wrapper = r.closest('.step-wrapper');
      if(wrapper) wrapper.classList.add('dragging');
      e.dataTransfer.setData('text/plain',r.dataset.index);
    });
    r.addEventListener('dragend',()=>{
      r.classList.remove('dragging');
      const wrapper = r.closest('.step-wrapper');
      if(wrapper) wrapper.classList.remove('dragging');
    });
  });
  const box=$('#rows');
  box.addEventListener('dragover',e=>{
    e.preventDefault();
    const afterWrapper=getDragAfterWrapper(box,e.clientY);
    const draggingWrapper=$('.step-wrapper.dragging');
    if(!draggingWrapper)return;
    if(afterWrapper==null)box.appendChild(draggingWrapper);else box.insertBefore(draggingWrapper,afterWrapper);
  });
  box.addEventListener('drop',()=>{
    const newOrder=$$('.step-wrapper').map(x=>Number(x.dataset.stepIdx));
    state.steps=newOrder.map(i=>state.steps[i]);
    renderRows();
  });
}

function getDragAfterWrapper(container,y){
  const els=[...container.querySelectorAll('.step-wrapper:not(.dragging)')];
  return els.reduce((closest,child)=>{
    const box=child.getBoundingClientRect();
    const offset=y-box.top-box.height/2;
    if(offset<0&&offset>closest.offset)return{offset,element:child};
    return closest;
  },{offset:Number.NEGATIVE_INFINITY}).element;
}


document.addEventListener('change',e=>{
  if(e.target.matches('input[type="number"]')&&e.target.dataset.idx!==undefined){
    const idx=Number(e.target.dataset.idx);
    const newNights = Math.max(0,Math.min(30,Number(e.target.value||0)));
    state.steps[idx].nights = newNights;
    
    // Si nights = 0, supprimer l'hôtel et les infos de groupe
    if (newNights === 0) {
      delete state.steps[idx].hotel;
      delete state.steps[idx].hotelName;
      delete state.steps[idx].hotelPrice;
      delete state.steps[idx].hotelRating;
      delete state.steps[idx].hotelUrl;
      delete state.steps[idx].hotelPhoto;
      delete state.steps[idx]._isHub;
      delete state.steps[idx].groupName;
      delete state.steps[idx].groupColor;
      console.log(`[NIGHTS] Étape ${idx+1}: 0 nuit → hôtel supprimé`);
    }
    
    renderRows(); // <-- re-render pour injecter/retirer la colonne Hôtel
  }
});

$('#btnAddStep').onclick=()=>{
  const name=prompt('Nom du lieu:');
  if(!name)return;
  
  // Recherche via API pour obtenir les coordonnées
  (async()=>{
    try{
      const searchUrl=`${SEARCH_API}/citysearch?q=${encodeURIComponent(name)}&lang=fr&limit=10`;
      console.log('Recherche:',searchUrl);
      const res=await fetch(searchUrl);
      if(res.ok){
        const data=await res.json();
        console.log('Résultats API:',data);
        if(data.items&&data.items.length>0){
          const item=data.items[0];
          if(item.lat&&item.lon){

// 1) slug d’abord
let slugVar = item.name
  .toLowerCase()
  .normalize('NFD')
  .replace(/\p{Diacritic}/gu, '')
  .replace(/[^a-z0-9]+/g, '-');

const pid = `${item.countryCode}::${slugVar}`;

// 2) push de l’étape (on affiche ce qu’on a déjà en cache)
//    + __sid unique dès l’insertion
{
  const newStep = {
    place_id: pid,
    name: item.name,
    lat: item.lat,
    lon: item.lon,
    nights: 1,
    visits: [],
    activities: [],
    images: getPhotosForPlace(pid)
  };
  newStep.__sid = (typeof ensureSid === 'function') ? ensureSid(newStep) : (crypto?.randomUUID?.() || ('S'+Date.now()+Math.random().toString(36).slice(2)));
  state.steps.push(newStep);
}


// 3) (optionnel) tentative d’auto-photos si absentes — garde-fous >= 2
try {
  if (!PHOTOS_CACHE[pid] || (PHOTOS_CACHE[pid].photos||[]).length < 2) {
    const query = encodeURIComponent(item.name + " France ville");
    const resp = await fetch(`https://api.unsplash.com/search/photos?query=${query}&per_page=8&client_id=YOUR_UNSPLASH_KEY`);
    if (resp.ok) {
      const d = await resp.json();
      const urls = (d.results || [])
        .map(p => p.urls?.small)
        .filter(Boolean)
        .slice(0, 4);
      if (urls.length >= 2) {
        PHOTOS_CACHE[pid] = { photos: urls };
        localStorage.setItem('ort.photos_cache', JSON.stringify(PHOTOS_CACHE));
        // met à jour les images de la ligne ajoutée
        state.steps[state.steps.length-1].images = urls;
        console.log(`📸 ${urls.length} photos ajoutées pour ${item.name}`);
      }
    }
  }
} catch(e) {
  console.warn('auto-photos error:', e);
}
            renderRows();
            toast(`✅ ${item.name} ajouté`);
            return;
          }
        }
      }
      toast('❌ Lieu non trouvé. Essayez sur la carte.');
    }catch(e){
      console.error('Erreur recherche:',e);
      toast('❌ API indisponible. Utilisez la carte.');
    }
  })();
};

$('#btnAddMapStep').onclick=()=>{
  mapClickMode=!mapClickMode;
  const btn=$('#btnAddMapStep');
  if(mapClickMode){
    btn.textContent='❌ ' + t('cancel');
    btn.classList.add('active');
    $('#map').classList.add('pointer-mode');
    toast('📍 ' + t('addOnMap'));
}else{
  btn.textContent='📍 ' + t('addOnMap');
  btn.classList.remove('active');
  $('#map').classList.remove('pointer-mode');
}
};

// === Bouton Modifier l'itinéraire sur la carte ===
$('#btnEditMapRoute').onclick=()=>{
  // Fermer le popup outils
  const toolsPop = document.getElementById('toolsPop');
  if(toolsPop) toolsPop.classList.remove('show');
  
  // Ouvrir la carte en plein écran
  document.body.classList.add('view-map-only');
  
  // Déclencher le mode réorganisation
  const reorgBtn = document.getElementById('reorgFullscreenBtn');
  if(reorgBtn) reorgBtn.click();
};

// === Bouton Proposer d'autres lieux ===
$('#btnShowOtherPlaces')?.addEventListener('click', async ()=>{
  // Fermer le popup outils
  const toolsPop = document.getElementById('toolsPop');
  if(toolsPop) toolsPop.classList.remove('show');
  
  // Ouvrir la carte en plein écran
  document.body.classList.add('view-map-only');
  
  // Activer le toggle "Autres lieux" après un court délai
  setTimeout(()=>{
    const togOther = document.getElementById('toggleOtherPlaces');
    if(togOther && !togOther.checked) {
      togOther.checked = true;
      togOther.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }, 300);
});

// Handler km/mi (bouton supprimé mais garde la logique au cas où)
if($('#unitToggle')) $('#unitToggle').onclick=()=>{
  console.log('Toggle unit clicked');
  state.distanceUnit=state.distanceUnit==='km'?'mi':'km';
  if($('#unitLabel')) $('#unitLabel').textContent=state.distanceUnit;
  toast(`📏 ${state.distanceUnit==='km'?'Kilomètres':'Miles'}`);
  renderRows();
};

// ===== TRANSPORT MODE MULTI-MODAL =====
const getTransportMode = ()=> localStorage.getItem('ort.transportMode') || 'driving';
const setTransportMode = (m)=> localStorage.setItem('ort.transportMode', m);

// Configuration des modes disponibles par pays
const TRANSPORT_MODES = {
  // Modes OSRM (disponibles partout)
  driving: { 
    label: '🚗 Voiture', 
    api: 'osrm', 
    countries: '*' 
  },
  cycling: { 
    label: '🚴 Vélo', 
    api: 'osrm', 
    countries: '*' 
  },
  walking: { 
    label: '🚶 Pieds', 
    api: 'osrm', 
    countries: '*' 
  },
  
  // Modes Navitia (France + Europe uniquement)
  transit: { 
    label: '🚆 Train/Métro', 
    api: 'navitia', 
    countries: ['FR', 'DE', 'BE', 'CH', 'LU', 'NL', 'ES', 'IT', 'GB'] 
  }
};

// Déterminer quels modes sont disponibles selon le pays
function getAvailableModes() {
  const currentCountry = window.state?.cc || state?.country || 'FR';
  console.log('[TRANSPORT] Pays actuel:', currentCountry);
  
  return Object.entries(TRANSPORT_MODES).filter(([key, config]) => {
    if (config.countries === '*') return true;
    return config.countries.includes(currentCountry);
  });
}

// Construire le menu des modes
function buildModeMenu() {
  const menu = document.getElementById('modeMenu');
  if (!menu) return;
  
  menu.innerHTML = '';
  const availableModes = getAvailableModes();
  
  if (availableModes.length === 0) {
    menu.innerHTML = '<div style="padding:8px 12px; color:#666;">' + t('noModeAvailable') + '</div>';
    return;
  }
  
  availableModes.forEach(([key, config]) => {
    const btn = document.createElement('button');
    btn.className = 'mode-option';
    btn.textContent = config.label;
    btn.style.cssText = 'width:100%; text-align:left; padding:8px 12px; border:none; background:none; cursor:pointer; font-size:14px;';
    
    // Marquer le mode actif
    if (key === getTransportMode()) {
      btn.style.background = '#e3f2fd';
      btn.style.fontWeight = '600';
    }
    
    btn.addEventListener('mouseover', () => {
      if (key !== getTransportMode()) btn.style.background = '#f5f5f5';
    });
    btn.addEventListener('mouseout', () => {
      if (key !== getTransportMode()) btn.style.background = 'none';
    });
    
    btn.addEventListener('click', () => {
      setTransportMode(key);
      document.getElementById('modeLabel').textContent = config.label.split(' ')[1];
      menu.classList.remove('show');
      toast(`${config.label}`);
      renderRows(); // Recalcul distances
      
      // Si on passe à un mode transit, avertir l'utilisateur
      if (config.api === 'mapbox') {
        setTimeout(() => {
          toast('💡 Transports en commun : horaires et correspondances affichés', 3000);
        }, 500);
      }
    });
    
    menu.appendChild(btn);
  });
}

// Toggle du menu mode (dans le popup Outils) - bouton supprimé mais garde la logique
const modeToggleBtn = document.getElementById('modeToggle');
if(modeToggleBtn) modeToggleBtn.onclick = (e) => {
  e.stopPropagation();
  const menu = document.getElementById('modeMenu');
  if (!menu) return;
  
  const isVisible = menu.classList.contains('show');
  if (!isVisible) {
    buildModeMenu(); // Reconstruit au cas où le pays a changé
    menu.classList.add('show');
  } else {
    menu.classList.remove('show');
  }
};

// Fermer le menu mode si on clique ailleurs
document.addEventListener('click', (e) => {
  const menu = document.getElementById('modeMenu');
  const toggle = document.getElementById('modeToggle');
  if (menu && toggle && !toggle.contains(e.target) && !menu.contains(e.target)) {
    menu.classList.remove('show');
  }
});

// Initialiser le label (si le bouton existe)
const currentMode = getTransportMode();
const currentConfig = TRANSPORT_MODES[currentMode];
const modeLabelEl = document.getElementById('modeLabel');
if (currentConfig && modeLabelEl) {
  modeLabelEl.textContent = currentConfig.label.split(' ')[1];
}

$('#btnSave').onclick = async ()=>{
  const u = currentUser();
  if(!u){ toast('🔐 Connectez-vous pour sauvegarder'); return; }

  // === AJOUTER LES RÉSERVATIONS À WINDOW.STATE AVANT SAUVEGARDE ===
  if (typeof globalBookingManager !== 'undefined' && globalBookingManager) {
    state.bookings = globalBookingManager.bookings;
    console.log('[BOOKINGS] 💾 Réservations ajoutées à state:', Object.keys(state.bookings).length, 'étapes');
  }

  // == reconstitue le résumé comme dans scheduleAutosave() ==
  const rid = ensureRid();
  const nights = (state.steps||[]).reduce((s,x)=> s + Number(x.nights||0), 0);

  // Titre (déjà traduit dans les données)
  let exportedTitle = state.title || 'Voyage';

  // coords moyennes + chemin
  const stepsCoords = (state.steps||[])
    .map(s => (Number.isFinite(s.lat) && Number.isFinite(s.lon)) ? [s.lat, s.lon] : null)
    .filter(Boolean);
  const coords = stepsCoords.length ? [
    +(stepsCoords.reduce((a,p)=>a+p[0],0)/stepsCoords.length).toFixed(5),
    +(stepsCoords.reduce((a,p)=>a+p[1],0)/stepsCoords.length).toFixed(5)
  ] : null;
  const coordsPath = stepsCoords.length >= 2 ? stepsCoords : null;

  // cover si dispo
  let coverUrl = document.querySelector('#rtCover img, .hero img, .cover img')?.src || null;

  const summary = {
    id: rid,
    tripId: rid,
    title: exportedTitle,
    country: state.country || 'XX',
    nights,
    kms: Number((typeof TOTALS!=='undefined' && TOTALS.km) || 0),
    steps: (state.steps||[]).length,
    pace: (typeof getTransportMode==='function' ? (getTransportMode()==='car'?'auto':'train') : 'auto'),
    tags: Array.from(new Set((state.steps||[]).flatMap(s => s.tags || []))).slice(0, 6),
    detailUrl: location.href,
    coords,
    coordsPath,
    coverUrl
  };
// — Sauvegarde "plein" pour ouverture/partage par rid —
// clé: ort.rt::<uid>::<rid>
try{
  const full = {
    ts: Date.now(),
    rid,
    uid: u.uid,
    state,           // étapes, nuits, etc. (objet complet)
    totals: TOTALS   // km/min recalculés
  };
  localStorage.setItem(`ort.rt::${u.uid}::${rid}`, JSON.stringify(full));
}catch(_){}

// Sauvegarde via State Manager avec flag saved=true
  if (window.ORT_DETAIL_ADAPTER && typeof window.ORT_DETAIL_ADAPTER.saveCurrent === 'function') {
    console.log('[SAVE] Sauvegarde via State Manager');
    await window.ORT_DETAIL_ADAPTER.saveCurrent(true);
  }
  
  ORTSaves.upsert(u, summary);
  toast('✅ Sauvegardé');
  
  // Réinitialiser le flag de modifications non sauvegardées
  if (typeof clearUnsavedChanges === 'function') clearUnsavedChanges();
};

const btnExport = document.getElementById('btnExport');
console.log('[EXPORT] btnExport trouvé:', !!btnExport);
if(btnExport) btnExport.onclick=()=>{
  console.log('[EXPORT] Bouton cliqué, ouverture modal...');
  showExportModal();
};

// === Modal d'export avec choix de formats ===
function showExportModal(){
  // Supprimer modal existante
  document.getElementById('exportModal')?.remove();
  
  const modal = document.createElement('div');
  modal.id = 'exportModal';
  modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:flex;align-items:center;justify-content:center;z-index:9999;';
  
  const box = document.createElement('div');
  box.style.cssText = 'background:#fff;border-radius:12px;padding:24px;max-width:420px;width:90%;box-shadow:0 10px 40px rgba(0,0,0,0.3);';
  
  box.innerHTML = `
    <h3 style="margin:0 0 16px;color:#113f7a;font-size:1.2rem;">${t('exportTitle')}</h3>
    
    <div style="display:flex;flex-direction:column;gap:12px;">
      <button class="export-btn" data-format="json" style="display:flex;align-items:flex-start;gap:12px;padding:12px;border:1px solid #e2e8f0;border-radius:8px;background:#fff;cursor:pointer;text-align:left;transition:all 0.2s;">
        <span style="font-size:1.5rem;">📄</span>
        <div>
          <strong style="color:#113f7a;">JSON</strong>
          <p style="margin:4px 0 0;font-size:0.85rem;color:#64748b;">${t('exportJsonDesc')}</p>
        </div>
      </button>
      
      <button class="export-btn" data-format="gpx" style="display:flex;align-items:flex-start;gap:12px;padding:12px;border:1px solid #e2e8f0;border-radius:8px;background:#fff;cursor:pointer;text-align:left;transition:all 0.2s;">
        <span style="font-size:1.5rem;">🧭</span>
        <div>
          <strong style="color:#113f7a;">GPX</strong>
          <p style="margin:4px 0 0;font-size:0.85rem;color:#64748b;">${t('exportGpxDesc')}</p>
        </div>
      </button>
      
      <button class="export-btn" data-format="kml" style="display:flex;align-items:flex-start;gap:12px;padding:12px;border:1px solid #e2e8f0;border-radius:8px;background:#fff;cursor:pointer;text-align:left;transition:all 0.2s;">
        <span style="font-size:1.5rem;">🌍</span>
        <div>
          <strong style="color:#113f7a;">KML</strong>
          <p style="margin:4px 0 0;font-size:0.85rem;color:#64748b;">${t('exportKmlDesc')}</p>
        </div>
      </button>
    </div>
    
    <button id="exportModalClose" style="margin-top:16px;width:100%;padding:10px;background:#f1f5f9;border:none;border-radius:6px;cursor:pointer;font-weight:600;color:#64748b;">${t('cancel')}</button>
  `;
  
  modal.appendChild(box);
  document.body.appendChild(modal);
  
  // Hover effect
  box.querySelectorAll('.export-btn').forEach(btn => {
    btn.addEventListener('mouseenter', () => { btn.style.borderColor = '#113f7a'; btn.style.background = '#f8fafc'; });
    btn.addEventListener('mouseleave', () => { btn.style.borderColor = '#e2e8f0'; btn.style.background = '#fff'; });
  });
  
  // Handlers
  box.querySelectorAll('.export-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const format = btn.dataset.format;
      const filename = `roadtrip_${state.country || 'trip'}_${Date.now()}`;
      
      if(format === 'json'){
        downloadJSON(`${filename}.json`, { title: state.title, country: state.country, steps: state.steps });
        toast('✅ JSON ' + t('export').replace('📥 ', ''));
      } else if(format === 'gpx'){
        downloadGPX(`${filename}.gpx`, state);
        toast('✅ GPX ' + t('export').replace('📥 ', ''));
      } else if(format === 'kml'){
        downloadKML(`${filename}.kml`, state);
        toast('✅ KML ' + t('export').replace('📥 ', ''));
      }
      modal.remove();
    });
  });
  
  document.getElementById('exportModalClose').onclick = () => modal.remove();
  modal.addEventListener('click', (e) => { if(e.target === modal) modal.remove(); });
}

// === Export GPX ===
function downloadGPX(filename, data){
  const steps = data.steps || [];
  let waypoints = '';
  let trackpoints = '';
  
  steps.forEach((s, i) => {
    if(s.lat && s.lon){
      const name = (s.name || s.place_id || `Point ${i+1}`).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      waypoints += `  <wpt lat="${s.lat}" lon="${s.lon}">
    <name>${name}</name>
    <desc>${s.nights || 0} ${t('nights')}</desc>
  </wpt>\n`;
      trackpoints += `      <trkpt lat="${s.lat}" lon="${s.lon}"><name>${name}</name></trkpt>\n`;
    }
  });
  
  const gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="OneRoadTrip" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${(data.title || 'Road Trip').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</name>
    <time>${new Date().toISOString()}</time>
  </metadata>
${waypoints}
  <trk>
    <name>${(data.title || 'Road Trip').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</name>
    <trkseg>
${trackpoints}    </trkseg>
  </trk>
</gpx>`;
  
  const blob = new Blob([gpx], { type: 'application/gpx+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// === Export KML ===
function downloadKML(filename, data){
  const steps = data.steps || [];
  let placemarks = '';
  let coordinates = '';
  
  steps.forEach((s, i) => {
    if(s.lat && s.lon){
      const name = (s.name || s.place_id || `Point ${i+1}`).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      placemarks += `    <Placemark>
      <name>${name}</name>
      <description>${s.nights || 0} ${t('nights')}</description>
      <Point><coordinates>${s.lon},${s.lat},0</coordinates></Point>
    </Placemark>\n`;
      coordinates += `${s.lon},${s.lat},0 `;
    }
  });
  
  const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${(data.title || 'Road Trip').replace(/&/g,'&amp;').replace(/</g,'&lt;')}</name>
    <description>Exported from OneRoadTrip</description>
    <Style id="routeStyle">
      <LineStyle><color>ff0000ff</color><width>3</width></LineStyle>
    </Style>
${placemarks}
    <Placemark>
      <name>Route</name>
      <styleUrl>#routeStyle</styleUrl>
      <LineString><coordinates>${coordinates.trim()}</coordinates></LineString>
    </Placemark>
  </Document>
</kml>`;
  
  const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

// === Bouton "Écrire source" (admin only en LOCAL) ===
// Note: Cette fonction sera rappelée après l'init Firebase
window.initSaveSourceButton = function(){
  const btn = document.getElementById('btnSaveSource');
  const btnTools = document.getElementById('btnSaveSourceTools');
  const btnOpenItin = document.getElementById('btnOpenItinTools');
  
  if(!btn && !btnTools) return;
  
  // Vérifier si on est en LOCAL et admin
  function checkAdminLocal(){
    // Plusieurs façons de détecter l'environnement LOCAL
    let isLocal = false;
    
    // Méthode 1: window.ortConfig
    if (window.ortConfig?.environment === 'LOCAL') isLocal = true;
    // Méthode 2: window.ORT_CONFIG
    if (window.ORT_CONFIG?.environment === 'LOCAL') isLocal = true;
    // Méthode 3: URL localhost ou 127.0.0.1
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') isLocal = true;
    // Méthode 4: Port de développement
    if (location.port === '8030' || location.port === '8000' || location.port === '3000') isLocal = true;
    
    let user = null;
    let email = null;
    try {
      if(typeof firebase !== 'undefined' && firebase.auth) {
        user = firebase.auth().currentUser;
        email = user?.email;
      }
    } catch(e) {
      console.log('[ADMIN] Erreur auth:', e);
    }
    
    const isAdmin = email === 'marcsorci@free.fr';
    
    // Log uniquement si changement
    const stateKey = `${isLocal}-${email}-${isAdmin}`;
    if (window._lastAdminState !== stateKey) {
      window._lastAdminState = stateKey;
      if (isLocal && isAdmin) console.log('[ADMIN] ✅ Admin mode');
    }
    
    if(isLocal && isAdmin){
      if(btn) btn.style.display = 'inline-flex';
      if(btnTools) btnTools.style.display = 'flex';
      if(btnOpenItin) btnOpenItin.style.display = 'flex';
      const btnDel = document.getElementById('btnDeleteItin');
      if(btnDel) btnDel.style.display = 'inline-flex';
      const btnOpenBottom = document.getElementById('btnOpenItinBottom');
      if(btnOpenBottom) btnOpenBottom.style.display = 'inline-flex';
    } else {
      if(btn) btn.style.display = 'none';
      if(btnTools) btnTools.style.display = 'none';
      if(btnOpenItin) btnOpenItin.style.display = 'none';
      const btnDel = document.getElementById('btnDeleteItin');
      if(btnDel) btnDel.style.display = 'none';
      const btnOpenBottom = document.getElementById('btnOpenItinBottom');
      if(btnOpenBottom) btnOpenBottom.style.display = 'none';
    }
  }
  
  // Vérifier plusieurs fois pour être sûr (Firebase peut être lent)
  checkAdminLocal();
  setTimeout(checkAdminLocal, 2000);
  setTimeout(checkAdminLocal, 5000);
  setTimeout(checkAdminLocal, 10000);
  
  // Et aussi sur changement d'auth
  if(typeof firebase !== 'undefined' && firebase.auth){
    try {
      firebase.auth().onAuthStateChanged(() => {
        setTimeout(checkAdminLocal, 500);
      });
    } catch(e) {}
  }
  
  // Handler commun pour les deux boutons
  async function handleSaveSource(clickedBtn) {
    // Récupérer le chemin de l'itinéraire source avec fallbacks
    let baseRef = state._itinRef || window._itinRef;
    
    // Fallback: construire la référence depuis les données disponibles
    if(!baseRef || !baseRef.country){
      const fallbackCountry = state.cc || state.country || 
        (state._originalItinId && state._originalItinId.split('::')[0]) ||
        new URLSearchParams(location.search).get('cc')?.toUpperCase() ||
        (new URLSearchParams(location.search).get('rtKey') || '').split('_')[0]?.toUpperCase();
      
      if(fallbackCountry && fallbackCountry.length === 2){
        baseRef = {
          country: fallbackCountry,
          itin: state._originalItinId || `${fallbackCountry}::temp_${Date.now()}`
        };
        state._itinRef = baseRef;
        console.log('[SAVE] Référence reconstruite:', baseRef);
      } else {
        toast('❌ Pays non identifié - Vérifiez l\'URL (cc=XX)');
        return;
      }
    }
    
    // Utiliser l'ID original (pas l'ID temporaire de l'URL)
    let originalId = state._originalItinId;
    const country = baseRef.country?.toUpperCase() || 'XX';
    const countryLower = country.toLowerCase();
    
    // Détecter si c'est un ID temporaire
    const isTemp = !originalId || originalId.includes('temp_') || originalId.includes('::temp_');
    
    if (isTemp) {
      // Proposer de créer un nouvel ID
      const slugify = str => str.toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-|-$/g, '');
      
      const suggestedSlug = slugify(state.title || 'nouveau-roadtrip');
      const suggestedId = `${country}::${countryLower}::${suggestedSlug}`;
      
      const newId = prompt(
        `📝 Nouvel itinéraire détecté !\n\nCet itinéraire sera AJOUTÉ au fichier des itinéraires.\n\nID suggéré (format: CC::region::slug):`,
        suggestedId
      );
      
      if (!newId) {
        toast('❌ Sauvegarde annulée');
        return;
      }
      
      // Valider le format
      if (!newId.includes('::')) {
        toast('❌ Format invalide. Utilisez: CC::region::slug');
        return;
      }
      
      originalId = newId;
      console.log('[SAVE SOURCE] 🆕 Nouvel ID créé:', originalId);
    }
    
    // Langue du contenu = langue du fichier source chargé
    const lang = state._sourceLanguage || (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
    
    // Construire le chemin du fichier avec suffixe langue
    // Format: data/Roadtripsprefabriques/countries/fr/FR.itins.modules-fr.json
    const filePath = `data/Roadtripsprefabriques/countries/${countryLower}/${country}.itins.modules-${lang}.json`;
    
    console.log('[SAVE SOURCE] ID:', originalId, isTemp ? '(NOUVEAU)' : '(existant)');
    console.log('[SAVE SOURCE] Fichier:', filePath);
    console.log('[SAVE SOURCE] Country:', country, 'Lang:', lang);
    
    // Convertir les steps en days_plan format ORT (avec place_id, suggested_days = nuits actuelles, rating)
    const days_plan = state.steps.map((s, i) => ({
      day: i + 1,
      slice: 1,
      place_id: s.place_id || '',
      // suggested_days = nuits actuelles (reflète les modifications utilisateur)
      suggested_days: s.nights || s._suggestedDays || 1,
      rating: s.rating || 0,
      region_code: s.region_code || '',
      night: {
        place_id: s.place_id || '',
        coords: [s.lat, s.lon]
      },
      visits: (s.visits || []).map(v => typeof v === 'string' ? { text: v, visit_duration_min: 75 } : v),
      activities: (s.activities || []).map(a => typeof a === 'string' ? { text: a, visit_duration_min: 60 } : a),
      to_next_leg: {
        // Utiliser drive_min du JSON si disponible, sinon estimer depuis distance
        distance_km: s._distanceKmToNext || (s._distanceToNext ? Math.round(s._distanceToNext) : null),
        drive_min: s._driveMinToNext || (s._distanceToNext ? Math.round(s._distanceToNext * 1.2) : null),
        transport_mode: 'car',
        method: s._driveMinToNext ? 'source' : 'heuristic'
      }
    }));
    
    // Calculer estimated_days_base depuis les NUITS ACTUELLES (pas suggested_days)
    // estimated_days = nuits totales + 1 (jour de départ)
    const totalNights = state.steps.reduce((sum, s) => sum + (s.nights || 0), 0);
    const totalTransportBonus = state.steps.reduce((sum, s) => sum + (s._transportBonus || 0), 0);
    const estimatedDays = totalNights + 1;
    console.log('[SAVE SOURCE] 📊 Nuits:', totalNights, '+ bonus transport:', totalTransportBonus.toFixed(1), '→ estimated_days_base:', estimatedDays);
    
    // Construire l'objet itinéraire à sauvegarder (format ORT multi-langues)
    const itinToSave = {
      itin_id: originalId,
      id: originalId,
      language: lang,
      title: state.title,
      country: country,
      estimated_days_base: estimatedDays,
      source_url: state._originalSourceUrl || null,
      created_at: state._originalCreatedAt || new Date().toISOString(),
      pacing_rules: {
        factors: { slow: 1.25, standard: 1.0, fast: 0.75 },
        merge_threshold: 0.85
      },
      days_plan: days_plan
    };
    
    // Confirmation avec message adapté
    const action = isTemp ? '🆕 AJOUTER' : '✏️ MODIFIER';
    const confirmMsg = `${action} l'itinéraire dans :\n${filePath}\n\nID: ${originalId}\nLangue: ${lang.toUpperCase()}\nTitre: ${state.title}\n${days_plan.length} étapes, ${totalNights} nuits → ${estimatedDays} jours\n\nBackup automatique créé.\n\nContinuer ?`;
    if(!confirm(confirmMsg)) return;
    
    // Fermer le popup si ouvert
    document.getElementById('toolsPop')?.classList.remove('show');
    
    try {
      clickedBtn.disabled = true;
      const origText = clickedBtn.textContent;
      clickedBtn.textContent = '⏳ Sauvegarde...';
      
      const response = await fetch('/api/save-itinerary', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json; charset=utf-8' },
        body: JSON.stringify({
          path: filePath,
          data: itinToSave,
          country: country,
          language: lang
        })
      });
      
      const result = await response.json();
      
      if(response.ok && result.success){
        toast(`✅ ${result.message}`);
        console.log('[SAVE SOURCE]', result);
      } else {
        toast(`❌ Erreur: ${result.error || 'Échec sauvegarde'}`);
        console.error('[SAVE SOURCE ERROR]', result);
      }
      
      clickedBtn.disabled = false;
      clickedBtn.textContent = origText;
    } catch(err){
      toast(`❌ Erreur serveur: ${err.message}`);
      console.error('[SAVE SOURCE ERROR]', err);
      clickedBtn.disabled = false;
      clickedBtn.textContent = '🔴 Écrire source';
    }
  }
  
  // Attacher le handler aux deux boutons
  if(btn) btn.onclick = () => handleSaveSource(btn);
  if(btnTools) btnTools.onclick = () => handleSaveSource(btnTools);
  
  // Handler pour "Ouvrir un itin"
  if(btnOpenItin) btnOpenItin.onclick = () => {
    const currentId = state._originalItinId || '';
    const itinId = prompt(
      '🔓 Ouvrir un itinéraire par son ID\n\nFormat: CC::region::slug\nExemple: FR::06::villages-cote-dazur-arriere-pays',
      currentId
    );
    
    if(!itinId || !itinId.trim()) return;
    
    const id = itinId.trim();
    
    // Extraire le country code (premier segment)
    const parts = id.split('::');
    if(parts.length < 2) {
      alert('❌ Format invalide. Utilisez: CC::region::slug');
      return;
    }
    
    const cc = parts[0].toUpperCase();
    const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
    
    // Construire l'URL
    const url = `roadtrip_detail.html?cc=${cc}&itin=${encodeURIComponent(id)}&lang=${lang}&mode=expert`;
    
    // Fermer le popup
    document.getElementById('toolsPop')?.classList.remove('show');
    
    // Rediriger
    window.location.href = url;
  };
  
  // === Handler pour "Supprimer itin" (admin marcsorci@free.fr uniquement) ===
  const btnDeleteItin = document.getElementById('btnDeleteItin');
  if(btnDeleteItin) {
    btnDeleteItin.onclick = async () => {
      const itinId = state._originalItinId;
      if(!itinId) {
        toast('❌ Aucun itinéraire chargé');
        return;
      }
      
      const parts = itinId.split('::');
      const cc = parts[0]?.toUpperCase();
      
      // Confirmation unique
      if(!confirm(`⚠️ SUPPRESSION DÉFINITIVE\n\nItinéraire: ${itinId}\nPays: ${cc}\n\nCet itinéraire sera supprimé de TOUTES les langues.\n\nConfirmer ?`)) {
        return;
      }
      
      btnDeleteItin.disabled = true;
      const origText = btnDeleteItin.textContent;
      btnDeleteItin.textContent = '⏳ Suppression...';
      
      try {
        const resp = await fetch('http://localhost:8030/api/delete-itinerary', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            country: cc, 
            itinId: itinId,
            allLanguages: true,
            confirmedBy: 'marcsorci@free.fr'
          })
        });
        
        const result = await resp.json();
        
        if(result.success) {
          toast(`✅ Itinéraire supprimé de ${result.deletedFrom || 'tous les fichiers'}`);
          document.getElementById('toolsPop')?.classList.remove('show');
          setTimeout(() => {
            window.location.href = `choix_regions.html?cc=${cc}`;
          }, 1500);
        } else {
          toast(`❌ Erreur: ${result.error || 'Échec suppression'}`);
          btnDeleteItin.disabled = false;
          btnDeleteItin.textContent = origText;
        }
      } catch(err) {
        toast(`❌ Erreur serveur: ${err.message}`);
        console.error('[DELETE ITIN ERROR]', err);
        btnDeleteItin.disabled = false;
        btnDeleteItin.textContent = origText;
      }
    };
  }
  
  // === Handler pour "Ouvrir itin" en bas (même logique que celui du header) ===
  const btnOpenItinBottom = document.getElementById('btnOpenItinBottom');
  if(btnOpenItinBottom) {
    btnOpenItinBottom.onclick = () => {
      const currentId = state._originalItinId || '';
      const itinId = prompt(
        '🔓 Ouvrir un itinéraire par son ID\n\nFormat: CC::region::slug\nExemple: FR::06::villages-cote-dazur-arriere-pays',
        currentId
      );
      
      if(!itinId || !itinId.trim()) return;
      
      const id = itinId.trim();
      const parts = id.split('::');
      if(parts.length < 2) {
        alert('❌ Format invalide. Utilisez: CC::region::slug');
        return;
      }
      
      const cc = parts[0].toUpperCase();
      const lang = (typeof LANG !== 'undefined' ? LANG : null) || localStorage.getItem('lang') || 'fr';
      const url = `roadtrip_detail.html?cc=${cc}&itin=${encodeURIComponent(id)}&lang=${lang}&mode=expert`;
      window.location.href = url;
    };
  }
};

// Appeler immédiatement et aussi après un délai
setTimeout(window.initSaveSourceButton, 100);
setTimeout(window.initSaveSourceButton, 3000);

function downloadJSON(filename,obj){
  const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url;
  a.download=filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function toast(msg){
  const t=document.createElement('div');
  t.textContent=msg;
  t.style.cssText='position:fixed;left:50%;transform:translateX(-50%);bottom:20px;z-index:9999;background:#113f7a;color:#fff;border:1px solid #ffffff55;border-radius:10px;padding:10px 14px;box-shadow:0 4px 14px rgba(0,0,0,.2)';
  document.body.appendChild(t);
  setTimeout(()=>t.remove(),3000);
}

// Bouton aide (hover only)
(function initHelpPopover(){
  const btn  = document.getElementById('helpBtn');
  const pop  = document.getElementById('helpPop');
  const wrap = document.querySelector('.help-anchor');
  if(!btn || !pop || !wrap) return;

  const open  = ()=>{ updateHelpPop(); btn.setAttribute('aria-expanded','true'); };
  const close = ()=>{ btn.setAttribute('aria-expanded','false'); };

  // Souris / pointeur : ouvre/ferme au survol de la zone (titre + i + pop)
  wrap.addEventListener('mouseenter', open);
  wrap.addEventListener('mouseleave', close);

  // Clavier (accessibilité) : focus/blur du bouton i
  btn.addEventListener('focus', open);
  btn.addEventListener('blur',  close);
})();


(async function(){
  if(window.__ORT_INIT) { console.log('⚠️ Double init bloqué'); return; }
  window.__ORT_INIT = true;
  console.log('=== Init OneRoadTrip ===');
  console.log('Leaflet:',typeof L!=='undefined'?'✅':'❌');
{ const el=document.getElementById('ccLabel'); if(el) el.textContent=CC||'—'; }

  // Initialiser le label d'unité (si présent)
  const unitLabelEl = document.getElementById('unitLabel');
  if(unitLabelEl) unitLabelEl.textContent=state.distanceUnit;
  
  await loadPhotosJSON();
  
  // === MODE BUILDER: Génération d'itinéraire depuis presentation.html ===
  if(BUILDER_MODE){
    await initRouteBuilder(qs);
    return;
  }
  
  if(TEMP_MODE&&RT_KEY){
const rawItins = localStorage.getItem(`ORT_TEMP_TRIP_${RT_KEY}_itins`);
const rawPlaces = localStorage.getItem(`ORT_TEMP_TRIP_${RT_KEY}_places`);
console.log('🔍 [1] RT_KEY:', RT_KEY);
console.log('🔍 [2] rawItins exists:', !!rawItins);
console.log('🔍 [3] rawItins length:', rawItins?.length);
console.log('🔍 [4] rawItins first 200 chars:', rawItins?.substring(0, 200));
console.log('🔍 [5] rawPlaces exists:', !!rawPlaces);

const itinsObj=safeJSONParse(rawItins);
const placesObj=safeJSONParse(rawPlaces);

console.log('🔍 [6] itinsObj parsed:', !!itinsObj);
console.log('🔍 [7] itinsObj.itins[0]:', !!itinsObj?.itins?.[0]);

console.log('🔍 [15] placesObj parsed:', !!placesObj);
console.log('🔍 [16] itinsObj keys:', Object.keys(itinsObj || {}));
console.log('🔍 [17] itinsObj.itins exists:', 'itins' in (itinsObj || {}));
console.log('🔍 [18] itinsObj.itins[0]:', !!itinsObj?.itins?.[0]);
if(itinsObj){
  state._rawItinsObj=itinsObj;
  state._rawPlacesObj=placesObj;
  let toUse=null;
  if(Array.isArray(itinsObj.days_plan)||Array.isArray(itinsObj.places))toUse=itinsObj;
  else if(itinsObj.itineraries&&itinsObj.itineraries[0])toUse=itinsObj.itineraries[0];
  else if(itinsObj.itins&&itinsObj.itins[0])toUse=itinsObj.itins[0];
  
  console.log('🔍 [8] toUse exists:', !!toUse);
  console.log('🔍 [19] toUse selected:', !!toUse);
  if(toUse){
     console.log('🔍 [20] Entering initFromItin');
        const cc=toUse.itin_id?toUse.itin_id.split('::')[0].toUpperCase():(itinsObj.country||'XX');
        state.country=cc;
{ const el=document.getElementById('ccLabel'); if(el) el.textContent=cc; }
        
        // Extraire métadonnées pour "Écrire source"
        if (toUse.language) {
          state._sourceLanguage = toUse.language;
          console.log('[IMPORT] ✅ Langue source extraite:', toUse.language);
        }
        if (toUse.itin_id) {
          state._originalItinId = toUse.itin_id;
          console.log('[IMPORT] ✅ ID original extrait:', toUse.itin_id);
        }
        if (toUse.source_url) {
          state._originalSourceUrl = toUse.source_url;
        }
        if (toUse.created_at) {
          state._originalCreatedAt = toUse.created_at;
        }
        
await initFromItin(toUse);

        // Afficher le titre (déjà traduit dans les données)
        if (state.title) {
          const titleEl = document.getElementById('rtTitle');
          if (titleEl) {
            titleEl.removeAttribute('data-i18n');
            titleEl.textContent = state.title;
          }
        }

// === ÉDITION DU TITRE ===
(function initTitleEdit(){
  console.log('[TITLE-EDIT] Initialisation...');
  const titleEl = document.getElementById('rtTitle');
  const editBtn = document.getElementById('rtTitleEdit');
  const wrap = document.getElementById('rtTitleWrap');
  console.log('[TITLE-EDIT] Éléments:', { titleEl: !!titleEl, editBtn: !!editBtn, wrap: !!wrap });
  if(!titleEl || !editBtn || !wrap) {
    console.log('[TITLE-EDIT] ⚠️ Éléments manquants, abandon');
    return;
  }
  
  let isEditing = false;
  
  function startEdit(){
    console.log('[TITLE-EDIT] startEdit appelé, isEditing:', isEditing);
    if(isEditing) return;
    
    // Vérifier si utilisateur connecté ou admin
    const user = (typeof currentUser === 'function') ? currentUser() : null;
    const isAdmin = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    
    if(!user && !isAdmin){
      toast('Connectez-vous pour modifier le titre');
      return;
    }
    
    isEditing = true;
    const currentTitle = state.title || '';
    
    // Créer input
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'title-input';
    input.value = currentTitle;
    input.placeholder = 'Titre du voyage';
    
    // Remplacer le titre par l'input
    titleEl.style.display = 'none';
    editBtn.style.display = 'none';
    wrap.insertBefore(input, titleEl);
    input.focus();
    input.select();
    
    // Boutons de confirmation
    const btnWrap = document.createElement('div');
    btnWrap.style.cssText = 'display:flex;gap:4px';
    btnWrap.innerHTML = `
      <button id="titleSaveBtn" style="background:#22c55e;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:14px">✓</button>
      <button id="titleCancelBtn" style="background:#ef4444;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:14px">✕</button>
    `;
    wrap.appendChild(btnWrap);
    
    // Mode admin : bouton pour sauvegarder dans la source
    if(isAdmin){
      const adminBtn = document.createElement('button');
      adminBtn.id = 'titleSaveSourceBtn';
      adminBtn.style.cssText = 'background:#f59e0b;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:12px;margin-left:8px';
      adminBtn.textContent = '💾 Source';
      adminBtn.title = 'Sauvegarder dans le fichier source (admin)';
      btnWrap.appendChild(adminBtn);
      
      adminBtn.onclick = async () => {
        const newTitle = input.value.trim() || 'Mon voyage';
        state.title = newTitle;
        titleEl.textContent = newTitle;
        endEdit();
        
        // Utiliser le bouton "Écrire source" existant pour sauvegarder
        const btnSaveSource = document.getElementById('btnSaveSource');
        if(btnSaveSource && btnSaveSource.style.display !== 'none'){
          btnSaveSource.click();
        } else {
          toast('⚠️ Bouton "Écrire source" non disponible');
        }
      };
    }
    
    function saveTitle(){
      const newTitle = input.value.trim() || 'Mon voyage';
      state.title = newTitle;
      titleEl.textContent = newTitle;
      endEdit();
      toast('✅ Titre modifié');
      scheduleAutosave();
    }
    
    function cancelEdit(){
      endEdit();
    }
    
    function endEdit(){
      isEditing = false;
      input.remove();
      btnWrap.remove();
      titleEl.style.display = '';
      editBtn.style.display = '';
    }
    
    document.getElementById('titleSaveBtn').onclick = saveTitle;
    document.getElementById('titleCancelBtn').onclick = cancelEdit;
    
    input.addEventListener('keydown', (e) => {
      if(e.key === 'Enter') saveTitle();
      if(e.key === 'Escape') cancelEdit();
    });
    
    input.addEventListener('blur', (e) => {
      // Délai pour permettre le clic sur les boutons
      setTimeout(() => {
        if(isEditing && !wrap.contains(document.activeElement)) cancelEdit();
      }, 150);
    });
  }
  
  editBtn.onclick = startEdit;
  titleEl.style.cursor = 'pointer';
  titleEl.onclick = startEdit;
  console.log('[TITLE-EDIT] ✅ Handlers attachés');
})();


// renderRows fera le calcul automatique si nécessaire (pas de groupes existants)
renderRows();
// Charger l’index (pays ou import) avant d’afficher “Autres lieux”
await ensurePlacesIndex().catch(()=>{});

        return;
      }
    }
  }
  
  // Skip si mode DASHBOARD (tripId présent mais cc/itin absents ou null)
  const _tripIdParam = new URLSearchParams(location.search).get('tripId') || new URLSearchParams(location.search).get('id');
  const _ccParam = new URLSearchParams(location.search).get('cc');
  const _itinParam = new URLSearchParams(location.search).get('itin');
  const _isDashboardMode = _tripIdParam && (!_ccParam || _ccParam === 'null' || !_itinParam || _itinParam === 'null');
  
  if (_isDashboardMode) {
    console.log('[INIT] ⏭️ Skip loadItin - Mode DASHBOARD actif');
    return;
  }
  
  if(!CC||!ITIN_ID){
state.title='Aucun roadtrip sélectionné';
setTitleTranslated(state.title);
return;
  }
  
  const it=await loadItin();
  if(!it){
    state.title='Roadtrip introuvable';
setTitleTranslated(state.title);
alert('Itinéraire introuvable');
return;

  }
  
state.country=CC;
   state.cc = CC; // ← AJOUT : pour collectCurrentData()
   
   // INIT ORT_TRIPID - Source de vérité unique pour le tripId
   if (window.ORT_TRIPID) {
     state.tripId = window.ORT_TRIPID.init({ source: 'detail' });
   } else {
     state.tripId = ensureRid(); // Fallback
   }
   
   // Stocker la référence à l'itinéraire de base
   // Créer même si ITIN_ID est temporaire - on a besoin du country pour sauvegarder
   if (CC) {
     state._itinRef = {
       country: CC,
       itin: ITIN_ID || `${CC}::temp_${Date.now()}`
     };
     console.log('[INIT] Référence itinéraire de base stockée:', state._itinRef);
   }
   
   // Initialiser l'adaptateur State Manager avec le tripId
   if (window.ORT_DETAIL_ADAPTER && typeof window.ORT_DETAIL_ADAPTER.init === 'function') {
     window.ORT_DETAIL_ADAPTER.init(state.tripId, state);
     console.log('[INIT] ✅ ORT_DETAIL_ADAPTER initialisé avec tripId:', state.tripId);
   }
   
   await initFromItin(it);

// Fusionne les éditions utilisateur (visites/activités) si dispo
if (window.ORT_STEP_COMMON && typeof window.ORT_STEP_COMMON.loadStepData === 'function') {
  const tripId = (function(){
    const u = new URLSearchParams(location.search);
    const itin = u.get('itin') || '';
 const uid  = localStorage.getItem('ORT_USER_ID') || 'user';
    return `${uid}::${itin}`.replace(/\s/g,'_');
  })();
  if (Array.isArray(state.steps)) {
    for (let i = 0; i < state.steps.length; i++) {
      const d = await window.ORT_STEP_COMMON.loadStepData(tripId, `day_${i+1}`);
      if (d) {
        // ⚠️ Ne pas écraser par des tableaux vides
        if (Array.isArray(d.visits)     && d.visits.length)     state.steps[i].visits     = d.visits;
        if (Array.isArray(d.activities) && d.activities.length) state.steps[i].activities = d.activities;
      }
    }
  }
}

setTitleTranslated(state.title);

// === CHARGER PLACES_INDEX POUR LES RATINGS ===
await ensurePlacesIndex().catch(()=>{});

// Injecter les ratings dans les steps maintenant que PLACES_INDEX est chargé
if (state.steps && state.steps.length > 0 && PLACES_INDEX) {
  state.steps.forEach(step => {
    if (step.place_id && PLACES_INDEX[step.place_id]) {
      step.rating = PLACES_INDEX[step.place_id].rating || step.rating || 0;
    }
  });
  console.log('[INIT] ✅ Ratings injectés depuis PLACES_INDEX');
}


// renderRows fera le calcul automatique des groupes
renderRows();




})();

}
</script>




<div id="mapPopup" class="map-popup">
  <button class="popup-close" onclick="window.closeMapPopup()">✕</button>
  <div class="popup-content">
    <div class="popup-header">
      <div class="popup-title" id="popupTitle"></div>
      <div class="popup-stars" id="popupStars"></div>
    </div>
    <div class="popup-photos" id="popupPhotos"></div>
    <div class="popup-desc" id="popupDesc"></div>
  </div>
</div>

<script>
// === Fiche pays (dépend seulement de CC et de la langue) ===
(function(){
  const btn   = document.getElementById('countryTab');
  const wrap  = document.getElementById('countryDrawer');
  const close = document.getElementById('cdClose');
  const tabs  = document.getElementById('cdTabs');
  const panes = document.getElementById('cdPanes');
  const title = document.getElementById('cdTitle');
  
  console.log('[COUNTRY] Init - wrap:', !!wrap, 'tabs:', !!tabs, 'panes:', !!panes);
  
  // Ne pas exiger btn car il peut être masqué
  if(!wrap || !tabs || !panes) {
    console.log('[COUNTRY] ❌ Éléments manquants, abandon');
    return;
  }

  const qs  = new URLSearchParams(location.search);
  const CC  = (qs.get('cc')||'XX').toUpperCase();
  const ui  = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  
  console.log('[COUNTRY] CC:', CC, 'UI:', ui);
  
  const I18N = {
    fr:{
      "Safety Warning":"Avertissements de sécurité",
      "Best Time to Visit":"Meilleure période",
      "Iconic Places to Visit":"Lieux emblématiques",
      "Best Transportation":"Transports",
      "Daily Budget for Two People":"Budget (2 pers.)",
      "Essential Tips":"Conseils essentiels",
      "Unique Experiences":"Expériences uniques",
      unavailable:"Guide indisponible."
    },
    en:{unavailable:"Guide unavailable."}
  }[ui] || I18N_fallback();
  function I18N_fallback(){return {unavailable:"Guide unavailable."};}

  function boldOnly(s){
    const safe = String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    return safe.replace(/\*\*([\s\S]*?)\*\*/g,'<strong>$1</strong>');
  }
  function parseSections(raw){
    const order = ['Safety Warning','Best Time to Visit','Iconic Places to Visit','Best Transportation','Daily Budget for Two People','Essential Tips','Unique Experiences'];
    const map = new Map(); const t = String(raw||'').replace(/\r\n?/g,'\n');
  const re = /^##\s*(.*?)\s*\n([\s\S]*?)(?=^##\s|(?![\s\S]))/gmi;
    while((m=re.exec(t))){ map.set((m[1]||'').trim(), (m[2]||'').trim()); }
    return {order, map};
  }
  function localizedCountryName(iso2){
    try{ const dn=new Intl.DisplayNames([ui],{type:'region'}); const n=dn.of(iso2); return n||iso2; }catch(_){ return iso2; }
  }

  async function loadGuide(cc){
    const url = `./data/country-guides/${cc}.txt`;
    console.log('[COUNTRY] Chargement:', url);
    try{ 
      const r=await fetch(url,{cache:'no-store'}); 
      console.log('[COUNTRY] Réponse:', r.status, r.ok);
      return r.ok ? await r.text() : ''; 
    }
    catch(e){ 
      console.log('[COUNTRY] Erreur fetch:', e);
      return ''; 
    }
  }

  function render(raw){
    console.log('[COUNTRY] Render, raw length:', raw?.length || 0);
    tabs.innerHTML=''; panes.innerHTML='';
    if(!raw){ panes.innerHTML = `<div class="pane active">${I18N.unavailable}</div>`; return; }
    const {order, map} = parseSections(raw);
    console.log('[COUNTRY] Sections trouvées:', map.size);
    order.forEach((k,i)=>{
      const b=document.createElement('button');
      b.className='tab'+(i===0?' active':''); b.dataset.k=k; b.textContent=I18N[k]||k;
      b.addEventListener('click', ()=>{
        tabs.querySelectorAll('.tab').forEach(x=>x.classList.toggle('active', x===b));
        panes.querySelectorAll('.pane').forEach(p=>p.classList.toggle('active', p.dataset.k===k));
      });
      tabs.appendChild(b);
      const p=document.createElement('div'); p.className='pane'+(i===0?' active':''); p.dataset.k=k;
      p.innerHTML=boldOnly(map.get(k)||'—'); panes.appendChild(p);
    });
  }

  async function openDrawer(){
    console.log('[COUNTRY] openDrawer appelé');
    title.textContent = localizedCountryName(CC);
    wrap.classList.add('show');
    if(!wrap.dataset.loaded){
      const raw = await loadGuide(CC);
      render(raw);
      wrap.dataset.loaded='1';
    }
  }
  function closeDrawer(){ wrap.classList.remove('show'); }
  
  // Exposer globalement pour le menu Outils
  window.openCountryDrawer = openDrawer;
  console.log('[COUNTRY] ✅ openCountryDrawer exposé');

  if(btn) btn.addEventListener('click', openDrawer);
  if(close) close.addEventListener('click', closeDrawer);
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeDrawer(); });
})();
</script>

  <!-- [PATCH-TOOLS-POPUP] START -->
<script>
// === Popup Outils - Handlers additionnels ===
(function(){
  const toolsPop = document.getElementById('toolsPop');
  if(!toolsPop) return;
  
  // Bouton de fermeture
  const closeBtn = document.getElementById('toolsCloseBtn');
  if(closeBtn){
    closeBtn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
    });
  }
  
  // Fermer au clic dehors
  document.addEventListener('click', (e)=>{
    const toolsBtnRow = document.getElementById('toolsBtnRow');
    if(toolsPop.classList.contains('show') && 
       !toolsPop.contains(e.target) && 
       e.target !== toolsBtnRow){
      toolsPop.classList.remove('show');
    }
  });
  
  // Fermer avec Échap
  document.addEventListener('keydown', (e)=>{
    if(e.key==='Escape') toolsPop.classList.remove('show');
  });
  
  // Gestion layout buttons dans le popup
  const layoutSide = document.getElementById('layoutSideBtn');
  const layoutStack = document.getElementById('layoutStackBtn');
  
  if(layoutSide && layoutStack){
    layoutSide.addEventListener('click', ()=>{
      layoutSide.classList.add('active');
      layoutStack.classList.remove('active');
    });
    layoutStack.addEventListener('click', ()=>{
      layoutStack.classList.add('active');
      layoutSide.classList.remove('active');
    });
  }
  
  // Bouton Fiche Pays → ouvre le drawer pays
  const countryBtn = document.getElementById('btnToolsCountry');
  if(countryBtn){
    countryBtn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
      if(typeof window.openCountryDrawer === 'function'){
        window.openCountryDrawer();
      } else {
        const drawer = document.getElementById('countryDrawer');
        if(drawer) drawer.classList.add('show');
      }
    });
  }
  
  // Bouton Signaler une erreur
  const reportBtn = document.getElementById('btnToolsReport');
  if(reportBtn){
    reportBtn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
      const lang = (document.documentElement.lang || 'fr').slice(0,2);
      const tipMsg = {
        fr: 'Signaler une erreur ou amélioration',
        en: 'Report an error or suggestion',
        es: 'Reportar un error o sugerencia',
        it: 'Segnala un errore o suggerimento',
        pt: 'Reportar um erro ou sugestão',
        ar: 'الإبلاغ عن خطأ أو اقتراح'
      }[lang] || 'Report';
      
      const note = prompt(tipMsg + '\n\nÉcrivez votre message :');
      if(!note || !note.trim()) return;
      
      const payload = {
        subject: '[ORT] Signalement — Roadtrip',
        message: `URL: ${location.href}\nLang: ${lang}\nUser: ${(typeof currentUser==='function' && currentUser()?.email) || 'guest'}\n\nNote:\n${note.trim()}`
      };
      
      fetch('https://formsubmit.co/ajax/contact@oneroadtrip.com', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(payload)
      })
      .then(() => toast('✅ Signalement envoyé'))
      .catch(() => toast('❌ Envoi impossible'));
    });
  }
  
  // Bouton Noter le road trip
  const rateBtn = document.getElementById('btnToolsRate');
  if(rateBtn){
    rateBtn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
      // Utilise le même popover que le bouton inline
      if(typeof openRatePopover === 'function'){
        openRatePopover(rateBtn);
      }
    });
  }
  
  // Bouton Partager le voyage
  const shareBtn = document.getElementById('btnShareTrip');
  if(shareBtn){
    shareBtn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
      if(typeof ORT_SHARE !== 'undefined' && ORT_SHARE.showModal){
        // Récupérer le tripId depuis l'URL ou le state
        const params = new URLSearchParams(location.search);
        const tripId = params.get('tripId') || params.get('id') || window.state?.tripId;
        const tripTitle = window.state?.title || document.getElementById('rtTitle')?.textContent || 'Voyage';
        ORT_SHARE.showModal(tripId, tripTitle);
      } else {
        toast('❌ Module de partage non disponible');
      }
    });
  }
  
  // Bouton Carte hébergements Stay22 (désactivé)
  const stay22Btn = document.getElementById('btnStay22Map');
  if(stay22Btn){
    stay22Btn.addEventListener('click', ()=>{
      toolsPop.classList.remove('show');
      if(typeof openStay22Map === 'function') {
        openStay22Map();
      } else {
        toast('❌ Fonction Stay22 non disponible');
      }
    });
  }
  
  console.log('[TOOLS] ✅ Popup Outils initialisé');
})();
</script>
<!-- [PATCH-TOOLS-POPUP] END -->

<!-- [PATCH-REORG-FULLSCREEN] START -->

<!-- Modal d'information réorganisation -->
<div id="reorgInfoModal" role="dialog" aria-modal="true" aria-labelledby="reorgInfoTitle">
  <div class="reorg-info-box">
    <h2 id="reorgInfoTitle">⇄ <span data-i18n="reorganize">Réorganiser l'itinéraire</span></h2>
    <p data-i18n="reorg.info.line1">
      <strong>1er clic simple</strong> sur une étape : démarrage de l'itinéraire
    </p>
    <p data-i18n="reorg.info.line2">
      <strong>2ème clic simple</strong> : seconde étape de votre itinéraire
    </p>
    <p data-i18n="reorg.info.line3">
      <strong>Double-clic</strong> : suppression de l'étape
    </p>
    <p data-i18n="reorg.info.line4">
      <strong>Nouveau double-clic</strong> : réintégration de l'étape
    </p>
    <p data-i18n="reorg.info.line5" style="margin-top:16px;font-style:italic;color:#64748b;">
      ⚠️ Validation nécessaire en fin de réorganisation pour sauvegarder vos changements.
    </p>
    <button class="btn-close-info" data-i18n="understood">J'ai compris</button>
  </div>
</div>

<!-- Panneau latéral de réorganisation -->
<div id="reorgPanel" role="dialog" aria-labelledby="reorgPanelTitle">
  <div class="reorg-panel-header">
    <h3 id="reorgPanelTitle">
      <span data-i18n="reorg.panel.title">🔄 Réorganisation</span>
    </h3>
    <button class="reorg-panel-close" aria-label="Fermer" title="Fermer">✕</button>
  </div>
  
  <div class="reorg-panel-body">
        <div class="reorg-instructions">
      <p style="margin: 0 0 8px 0">
        <strong data-i18n="reorg.panel.inst1">Clic simple</strong> : <span data-i18n="reorg.panel.inst1b">Ajouter au nouvel ordre</span>
      </p>
      <p style="margin: 0">
        <strong data-i18n="reorg.panel.inst2">Double-clic</strong> : <span data-i18n="reorg.panel.inst2b">Supprimer / Réintégrer</span>
      </p>

      <!-- Icônes flottants -->
      <div class="reorg-float-tools">
        <button id="reorgInvertBtn" class="reorg-fab" type="button" aria-label="" title="">
          🔁
          <span class="reorg-tip" data-i18n="reorg.panel.invertHelp">Inverser l’ordre actuel (nouvel ordre si présent, sinon ordre d’origine)</span>
        </button>
        <button id="reorgResetBtn" class="reorg-fab" type="button" aria-label="" title="">
          ⟲
          <span class="reorg-tip" data-i18n="reorg.panel.resetHelp">Annuler toutes les modifications et revenir à l’itinéraire initial</span>
        </button>
      </div>
    </div>
    
    <div id="reorgStepsList">

      <!-- Les étapes seront générées dynamiquement ici -->
    </div>
  </div>
  
 <div class="reorg-panel-footer">
    <button class="reorg-save-btn" id="reorgPreviewBtn">
      <span data-i18n="reorg.panel.preview">👁️ Prévisualiser</span>
    </button>
  </div>
</div>


<!-- Modal de prévisualisation de la réorganisation -->
<div id="reorgPreviewModal" role="dialog" aria-modal="true" aria-labelledby="reorgPreviewTitle" style="display: none;">
  <div class="reorg-preview-box">
    <h2 id="reorgPreviewTitle">
      <span data-i18n="reorg.preview.title">👁️ Prévisualisation du nouvel itinéraire</span>
    </h2>
    
<div id="reorgPreviewContent" style="overflow-y: auto; margin: 16px 0;">

      <!-- Le contenu sera généré dynamiquement -->
    </div>
    
    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 16px;">
      <button class="btn-preview-cancel" style="padding: 10px 20px; border-radius: 8px; border: 1px solid #94a3b8; background: #fff; color: #475569; cursor: pointer; font-weight: 600;">
        <span data-i18n="reorg.preview.cancel">✕ Annuler</span>
      </button>
      <button class="btn-preview-validate" style="padding: 10px 20px; border-radius: 8px; border: none; background: #113f7a; color: #fff; cursor: pointer; font-weight: 600;">
        <span data-i18n="reorg.preview.validate">✓ Valider</span>
      </button>
    </div>
  </div>
</div>

<script>

// === Bouton réorganisation en mode plein écran + Modal d'info ===

(function(){
  console.log('[REORG] Script chargé');
  const btn = document.getElementById('reorgFullscreenBtn');
  const modal = document.getElementById('reorgInfoModal');
const infoCloseBtn = modal?.querySelector('.btn-close-info');
  
  console.log('[REORG] infoCloseBtn:', infoCloseBtn);
  console.log('[REORG] modal:', modal);
  console.log('[REORG] closeBtn:', infoCloseBtn);

  
  if(!btn || !modal) {
    console.error('[REORG] Élément manquant - btn:', !!btn, 'modal:', !!modal);
    return;
  }

  // I18N pour le bouton et la modal
  const LANG = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  console.log('[REORG] Langue détectée:', LANG);  
  const I18N = {
    fr: {
      btnTitle: 'Réorganiser',
      title: 'Réorganiser l\'itinéraire',
      line1: '<strong>1er clic simple</strong> sur une étape : démarrage de l\'itinéraire',
      line2: '<strong>2ème clic simple</strong> : seconde étape de votre itinéraire',
      line3: '<strong>Double-clic</strong> : suppression de l\'étape',
      line4: '<strong>Nouveau double-clic</strong> : réintégration de l\'étape',
      line5: '⚠️ Validation nécessaire en fin de réorganisation pour sauvegarder vos changements.',
      close: 'J\'ai compris'
    },
    en: {
      btnTitle: 'Reorganize',
      title: 'Reorganize the itinerary',
      line1: '<strong>1st simple click</strong> on a step: start of the itinerary',
      line2: '<strong>2nd simple click</strong>: second step of your itinerary',
      line3: '<strong>Double-click</strong>: remove the step',
      line4: '<strong>New double-click</strong>: reintegrate the step',
      line5: '⚠️ Validation required at the end of reorganization to save your changes.',
      close: 'I understand'
    },
    it: {
      btnTitle: 'Riorganizza',
      title: 'Riorganizza l\'itinerario',
      line1: '<strong>1° clic semplice</strong> su una tappa: inizio dell\'itinerario',
      line2: '<strong>2° clic semplice</strong>: seconda tappa del vostro itinerario',
      line3: '<strong>Doppio clic</strong>: rimozione della tappa',
      line4: '<strong>Nuovo doppio clic</strong>: reintegrazione della tappa',
      line5: '⚠️ Convalida necessaria alla fine della riorganizzazione per salvare le modifiche.',
      close: 'Ho capito'
    },
    es: {
      btnTitle: 'Reorganizar',
      title: 'Reorganizar el itinerario',
      line1: '<strong>1er clic simple</strong> en una etapa: inicio del itinerario',
      line2: '<strong>2º clic simple</strong>: segunda etapa de su itinerario',
      line3: '<strong>Doble clic</strong>: eliminación de la etapa',
      line4: '<strong>Nuevo doble clic</strong>: reintegración de la etapa',
      line5: '⚠️ Validación necesaria al final de la reorganización para guardar los cambios.',
      close: 'Entendido'
    },
    pt: {
      btnTitle: 'Reorganizar',
      title: 'Reorganizar o itinerário',
      line1: '<strong>1º clique simples</strong> numa etapa: início do itinerário',
      line2: '<strong>2º clique simples</strong>: segunda etapa do seu itinerário',
      line3: '<strong>Duplo clique</strong>: remoção da etapa',
      line4: '<strong>Novo duplo clique</strong>: reintegração da etapa',
      line5: '⚠️ Validação necessária no final da reorganização para guardar as alterações.',
      close: 'Compreendi'
    },
    ar: {
      btnTitle: 'إعادة ترتيب',
      title: 'إعادة ترتيب المسار',
      line1: '<strong>النقر البسيط الأول</strong> على مرحلة: بداية المسار',
      line2: '<strong>النقر البسيط الثاني</strong>: المرحلة الثانية من مساركم',
      line3: '<strong>النقر المزدوج</strong>: حذف المرحلة',
      line4: '<strong>نقر مزدوج جديد</strong>: إعادة دمج المرحلة',
      line5: '⚠️ التحقق ضروري في نهاية إعادة الترتيب لحفظ التغييرات.',
  close: 'فهمت'
    }
  };

  // Traductions pour le panneau de réorganisation
const PANEL_I18N = {
  fr: {
    panelTitle: '🔄 Réorganisation',
    inst1: 'Clic simple',
    inst1b: 'Ajouter au nouvel ordre',
    inst2: 'Double-clic',
    inst2b: 'Supprimer / Réintégrer',
    save: '💾 Sauvegarder',
    preview: '👁️ Prévisualiser',
    invert: 'Inverser le circuit',
    reset: 'Annuler les modifs et revenir',
    invertHelp: 'Inverser l’ordre actuel (priorité au nouvel ordre si présent, sinon l’ordre d’origine).',
    resetHelp: 'Annuler toutes les modifications (ordre/suppressions) et revenir à l’itinéraire initial.',
    previewTitle: 'Prévisualisation du nouvel itinéraire',
    validate: '✓ Valider',
    cancel: '✕ Annuler',
    deleted: 'Supprimée',
    noSteps: 'Aucune étape à réorganiser',
    mustKeepOne: 'Vous devez conserver au moins une étape !',
    saved: '✅ Réorganisation sauvegardée !',
    nights: 'nuit',
    nightsPlural: 'nuits'
  },

  en: {
    panelTitle: '🔄 Reordering',
    inst1: 'Single click',
    inst1b: 'Add to new order',
    inst2: 'Double-click',
    inst2b: 'Remove / Re-add',
    save: '💾 Save',
    preview: '👁️ Preview',
    invert: 'Reverse route',
    reset: 'Discard changes & revert',
    invertHelp: 'Reverse the current order (use new order if set, otherwise original order).',
    resetHelp: 'Discard all changes (order/deletions) and restore the initial itinerary.',
    previewTitle: 'Preview of the new itinerary',
    validate: '✓ Apply',
    cancel: '✕ Cancel',
    deleted: 'Removed',
    noSteps: 'No steps to reorder',
    mustKeepOne: 'You must keep at least one step!',
    saved: '✅ Reordering saved!',
    nights: 'night',
    nightsPlural: 'nights'
  },

  it: {
    panelTitle: '🔄 Riorganizzazione',
    inst1: 'Clic singolo',
    inst1b: 'Aggiungi al nuovo ordine',
    inst2: 'Doppio clic',
    inst2b: 'Rimuovi / Reintegra',
    save: '💾 Salva',
    preview: '👁️ Anteprima',
    invert: 'Inverti il circuito',
    reset: 'Annulla modifiche e ripristina',
    invertHelp: "Inverte l'ordine corrente (priorità al nuovo ordine se presente, altrimenti l'originale).",
    resetHelp: 'Annulla tutte le modifiche (ordine/eliminazioni) e ripristina l’itinerario iniziale.',
    previewTitle: 'Anteprima del nuovo itinerario',
    validate: '✓ Applica',
    cancel: '✕ Annulla',
    deleted: 'Rimossa',
    noSteps: 'Nessuna tappa da riorganizzare',
    mustKeepOne: 'Devi mantenere almeno una tappa!',
    saved: '✅ Riorganizzazione salvata!',
    nights: 'notte',
    nightsPlural: 'notti'
  },

  es: {
    panelTitle: '🔄 Reorganización',
    inst1: 'Clic simple',
    inst1b: 'Añadir al nuevo orden',
    inst2: 'Doble clic',
    inst2b: 'Eliminar / Reintegrar',
    save: '💾 Guardar',
    preview: '👁️ Previsualizar',
    invert: 'Invertir el circuito',
    reset: 'Anular cambios y volver',
    invertHelp: 'Invertir el orden actual (prioridad al nuevo orden si existe, si no al original).',
    resetHelp: 'Anular todos los cambios (orden/eliminaciones) y restaurar el itinerario inicial.',
    previewTitle: 'Previsualización del nuevo itinerario',
    validate: '✓ Aplicar',
    cancel: '✕ Cancelar',
    deleted: 'Eliminada',
    noSteps: 'Ninguna etapa que reorganizar',
    mustKeepOne: '¡Debes conservar al menos una etapa!',
    saved: '✅ ¡Reorganización guardada!',
    nights: 'noche',
    nightsPlural: 'noches'
  },

  pt: {
    panelTitle: '🔄 Reorganização',
    inst1: 'Clique simples',
    inst1b: 'Adicionar à nova ordem',
    inst2: 'Duplo clique',
    inst2b: 'Remover / Reintegrar',
    save: '💾 Guardar',
    preview: '👁️ Pré-visualizar',
    invert: 'Inverter o circuito',
    reset: 'Anular alterações e voltar',
    invertHelp: 'Inverter a ordem atual (prioridade à nova ordem se existir, caso contrário a original).',
    resetHelp: 'Anular todas as alterações (ordem/remoções) e restaurar o itinerário inicial.',
    previewTitle: 'Pré-visualização do novo itinerário',
    validate: '✓ Aplicar',
    cancel: '✕ Cancelar',
    deleted: 'Removida',
    noSteps: 'Nenhuma etapa para reorganizar',
    mustKeepOne: 'Deve manter pelo menos uma etapa!',
    saved: '✅ Reorganização guardada!',
    nights: 'noite',
    nightsPlural: 'noites'
  },

  ar: {
    panelTitle: '🔄 إعادة التنظيم',
    inst1: 'نقرة واحدة',
    inst1b: 'إضافة إلى الترتيب الجديد',
    inst2: 'نقرتان',
    inst2b: 'حذف / إعادة إدراج',
    save: '💾 حفظ',
    preview: '👁️ معاينة',
    invert: 'عكس المسار',
    reset: 'إلغاء التعديلات والرجوع',
    invertHelp: 'عكس الترتيب الحالي (الأولوية للترتيب الجديد إن وُجد، وإلا فالأصلي).',
    resetHelp: 'إلغاء جميع التغييرات (الترتيب/الحذف) واستعادة المسار الأصلي.',
    previewTitle: 'معاينة المسار الجديد',
    validate: '✓ اعتماد',
    cancel: '✕ إلغاء',
    deleted: 'محذوفة',
    noSteps: 'لا توجد مراحل لإعادة تنظيمها',
    mustKeepOne: 'يجب الإبقاء على مرحلة واحدة على الأقل!',
    saved: '✅ تم حفظ إعادة التنظيم!',
    nights: 'ليلة',
    nightsPlural: 'ليالٍ'
  }
};

 

  const t = I18N[LANG] || I18N.fr;
  const tPanel = PANEL_I18N[LANG] || PANEL_I18N.fr;
   // === [ADD] Mémo "modale info déjà vue" par utilisateur ===
  const uidForSeen = (typeof currentUser==='function' && currentUser() && currentUser().uid)
                   || localStorage.getItem('ort.lastUid')
                   || 'anon';
  const REORG_INFO_KEY = `ort.reorg.info.seen::${uidForSeen}`;
  const hasSeenReorgInfo = () => localStorage.getItem(REORG_INFO_KEY) === '1';
  const markReorgInfoSeen = () => { try{ localStorage.setItem(REORG_INFO_KEY, '1'); }catch(_){} };
  // Exposer les traductions globalement pour le panneau
  window.REORG_TRANSLATIONS = tPanel;

  // Appliquer les traductions
  btn.title = t.btnTitle;
  btn.setAttribute('aria-label', t.btnTitle);
  
  modal.querySelector('[data-i18n="reorganize"]').textContent = t.title;
  modal.querySelector('[data-i18n="reorg.info.line1"]').innerHTML = t.line1;
  modal.querySelector('[data-i18n="reorg.info.line2"]').innerHTML = t.line2;
  modal.querySelector('[data-i18n="reorg.info.line3"]').innerHTML = t.line3;
  modal.querySelector('[data-i18n="reorg.info.line4"]').innerHTML = t.line4;
  modal.querySelector('[data-i18n="reorg.info.line5"]').innerHTML = t.line5;
  modal.querySelector('[data-i18n="understood"]').textContent = t.close;

// Ouvrir la modal au clic sur le bouton
btn.addEventListener('click', () => {
  console.log('[REORG] Bouton cliqué !');
  
  // ✅ Vérifier si l'utilisateur a déjà vu la modale ET que startReorganization existe
  if (hasSeenReorgInfo() && typeof window.startReorganization === 'function') {
    console.log('[REORG] ✅ Utilisateur a déjà vu l\'info → lancement direct');
    window.startReorganization();
    return;
  }
  
  // Si startReorganization n'existe pas encore, afficher la modal quand même
  if (hasSeenReorgInfo() && typeof window.startReorganization !== 'function') {
    console.warn('[REORG] ⚠️ startReorganization pas encore disponible, on affiche la modal');
  }
  
  const isShown = modal.classList.contains('show');
  console.log('[REORG] Modal state avant clic:', isShown ? 'show' : 'hidden');

  // Si la modale est déjà visible, on relance directement la réorganisation
  if (isShown) {
    try {
      modal.classList.remove('show');
      modal.style.display = 'none';
      console.log('[REORG] Modale déjà ouverte → on la ferme et on (re)lance startReorganization()');
      if (typeof window.startReorganization === 'function') {
        window.startReorganization();
      } else {
        console.error('[REORG] startReorganization introuvable');
      }

    } catch (e) {
      console.error('[REORG] Erreur relance réorg:', e);
    }
    return;
  }

  // Cas normal : première ouverture → on montre la modale d'info
  console.log('[REORG] Modal avant ajout classe:', modal.className);
  modal.style.display = 'flex';
  modal.classList.add('show');
  console.log('[REORG] Modal après ajout classe:', modal.className);
});

// Fermer la modal
  function closeModal(){
    modal.classList.remove('show');
    
    // ✅ Réinitialiser complètement la modal après l'animation
    setTimeout(() => {
      modal.style.display = 'none';
    }, 300);

    // ✅ Mémoriser SEULEMENT si on lance la réorganisation (pas si on clique sur le fond)
    // On le fera dans le setTimeout ci-dessous
  }
  
  // Fonction pour fermer ET lancer la réorganisation
  function closeAndStart(){
    // ✅ Mémoriser que l'utilisateur a vu la modal
    markReorgInfoSeen();
    console.log('[REORG] ✅ Modal vue → enregistré pour cet utilisateur');
    
    closeModal();
    
    // Démarrer immédiatement la réorganisation
    setTimeout(() => {
      try {
        if (typeof startReorganization === 'function') {
          startReorganization();
        } else {
          console.warn('[REORG] startReorganization() indisponible');
        }
      } catch (e) {
        console.error('[REORG] Erreur au démarrage de la réorg:', e);
      }
    }, 150);
  }

  // Bouton "J'ai compris" → mémorise ET lance
  infoCloseBtn?.addEventListener('click', closeAndStart);

  // Clic sur le fond → ferme SANS mémoriser (l'utilisateur n'a pas validé)
  modal.addEventListener('click', (e) => {
    if(e.target === modal) {
      console.log('[REORG] ⚠️ Fermeture sans validation (clic fond)');
      closeModal();
    }
  });


  // Fermer avec Échap
  document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape' && modal.classList.contains('show')){
      closeModal();
    }
  });

})();

// === Logique de réorganisation avec panneau latéral ===
(function(){
  console.log('[REORG-PANEL] Initialisation');
  
const panel = document.getElementById('reorgPanel');
const panelCloseBtn = panel?.querySelector('.reorg-panel-close');
const previewBtn = document.getElementById('reorgPreviewBtn');
const stepsList = document.getElementById('reorgStepsList');

// ⚠️ Ne pas interrompre l'init complète : on logue et on continue
if (!panel) {
  console.error('[REORG-PANEL] Panneau introuvable — init annulée.');
  return;
}
if (!panelCloseBtn) console.warn('[REORG-PANEL] Bouton close introuvable au chargement.');
if (!previewBtn)   console.warn('[REORG-PANEL] Bouton preview introuvable au chargement.');
if (!stepsList)    console.warn('[REORG-PANEL] Liste des étapes introuvable au chargement.');


  // Récupérer les traductions
  const TR = window.REORG_TRANSLATIONS || {
    panelTitle: '🔄 Réorganisation',
    inst1: 'Clic simple',
    inst1b: 'Ajouter au nouvel ordre',
    inst2: 'Double-clic',
    inst2b: 'Supprimer / Réintégrer',
    save: '💾 Sauvegarder',
    deleted: 'Supprimée',
    noSteps: 'Aucune étape à réorganiser',
    mustKeepOne: 'Vous devez conserver au moins une étape !',
    saved: '✅ Réorganisation sauvegardée !',
    nights: 'nuit',
    nightsPlural: 'nuits'
  };
  
  // Appliquer les traductions au panneau
  const panelTitleEl = panel.querySelector('#reorgPanelTitle span[data-i18n]');
  const inst1El = panel.querySelector('[data-i18n="reorg.panel.inst1"]');
  const inst1bEl = panel.querySelector('[data-i18n="reorg.panel.inst1b"]');
  const inst2El = panel.querySelector('[data-i18n="reorg.panel.inst2"]');
    const inst2bEl = panel.querySelector('[data-i18n="reorg.panel.inst2b"]');
  const previewBtnEl = previewBtn.querySelector('[data-i18n="reorg.panel.preview"]');

   const invertBtn  = document.getElementById('reorgInvertBtn');
  const resetBtn   = document.getElementById('reorgResetBtn');
  const invertTip  = invertBtn?.querySelector('[data-i18n="reorg.panel.invertHelp"]');
  const resetTip   = resetBtn?.querySelector('[data-i18n="reorg.panel.resetHelp"]');

  // Helper: positionner le tooltip pour qu’il ne soit pas coupé
  function positionTip(btn, tip){
    if (!btn || !tip || !panel) return;
    tip.classList.remove('align-left','align-right','align-center');

    // Forcer une largeur calculée avant mesures
    tip.style.visibility = 'hidden';
    tip.style.opacity = '1';
    tip.classList.add('align-center'); // base
    const panelRect = panel.getBoundingClientRect();
    const tipRect   = tip.getBoundingClientRect();

    // dépassement à gauche ?
    if (tipRect.left < panelRect.left) {
      tip.classList.remove('align-center');
      tip.classList.add('align-left');
    }
    // recalcul si on vient de bouger
    const tipRect2 = tip.getBoundingClientRect();

    // dépassement à droite ?
    if (tipRect2.right > panelRect.right) {
      tip.classList.remove('align-center','align-left');
      tip.classList.add('align-right');
    }

    // Restaure visibilité contrôlée par :hover
    tip.style.opacity = '';
    tip.style.visibility = '';
  }

  // (ré)aligner au survol et au resize
  invertBtn?.addEventListener('mouseenter', () => positionTip(invertBtn, invertTip));
  resetBtn?.addEventListener('mouseenter', () => positionTip(resetBtn,  resetTip));
  window.addEventListener('resize', () => {
    positionTip(invertBtn, invertTip);
    positionTip(resetBtn,  resetTip);
  });

  if (panelTitleEl) panelTitleEl.textContent = TR.panelTitle;
  if (inst1El)      inst1El.textContent      = TR.inst1;

  if (inst1bEl)     inst1bEl.textContent     = TR.inst1b;
  if (inst2El)      inst2El.textContent      = TR.inst2;
  if (inst2bEl)     inst2bEl.textContent     = TR.inst2b;
 if (previewBtnEl) previewBtnEl.textContent = TR.preview;

// outil: repositionner le tooltip pour qu'il reste DANS le panneau
function positionTip(btn, tip){
  const panel = document.getElementById('reorgPanel');
  if (!btn || !tip || !panel) return;
  tip.classList.remove('align-left','align-right');      // base centrée (CSS)
  // forcer mesure hors :hover
  const prevVis = tip.style.visibility, prevOp = tip.style.opacity;
  tip.style.visibility = 'hidden'; tip.style.opacity = '1';
  const p = panel.getBoundingClientRect();
  const r = tip.getBoundingClientRect();
  if (r.left < p.left) tip.classList.add('align-left');
  const r2 = tip.getBoundingClientRect();
  if (r2.right > p.right) { tip.classList.remove('align-left'); tip.classList.add('align-right'); }
  tip.style.visibility = prevVis; tip.style.opacity = prevOp;
}

// listeners (mouseenter + resize)
invertBtn?.addEventListener('mouseenter', ()=>positionTip(invertBtn, invertTip));
resetBtn ?.addEventListener('mouseenter', ()=>positionTip(resetBtn,  resetTip ));
window.addEventListener('resize', ()=>{
  positionTip(invertBtn, invertTip);
  positionTip(resetBtn,  resetTip);
});

// I18N tooltips + aria-label
if (invertBtn) {
  invertBtn.title = TR.invert || 'Inverser le circuit';

    invertBtn.setAttribute('aria-label', TR.invert || 'Inverser le circuit');
  }
  if (resetBtn) {
    resetBtn.title = TR.reset || 'Annuler les modifs et revenir';
    resetBtn.setAttribute('aria-label', TR.reset || 'Annuler les modifs et revenir');
  }
  if (invertTip) invertTip.textContent = TR.invertHelp || invertTip.textContent;
  if (resetTip)  resetTip.textContent  = TR.resetHelp  || resetTip.textContent;

  // classes par défaut (centré) pour l’affichage initial
  invertTip?.classList.add('align-center');
  resetTip?.classList.add('align-center');

  // === Actions outils ===
  function refreshUI() {
    renderStepsList();
    if (typeof updateAllMarkersVisualState === 'function') updateAllMarkersVisualState();
    if (typeof updateMiniMarkersAppearance === 'function') updateMiniMarkersAppearance();
  }

  // Inverser le circuit (priorité à newOrder si présent)
  invertBtn?.addEventListener('click', () => {
    let base = [];
    if (reorgState.newOrder.length > 0) {
      base = reorgState.newOrder.filter(sid => !reorgState.deleted.includes(sid));
    } else {
      base = (window.state?.steps||[])
        .map(s => s.__sid)
        .filter(sid => !reorgState.deleted.includes(sid));
    }
    base.reverse();
    reorgState.newOrder = base;
    refreshUI();
  });

  // Réinitialiser toutes les modifications
  resetBtn?.addEventListener('click', () => {
    reorgState.newOrder = [];
    reorgState.deleted  = [];
    delete reorgState.savedMapState;
    refreshUI();
  });


  
  // État de la réorganisation
let reorgState = {
  active: false,
  newOrder: [],    // IDs des étapes dans le nouvel ordre (vide au départ)
  deleted: [],     // IDs des étapes supprimées
  clickTimer: null // Timer pour distinguer clic simple / double-clic
};

  // Ouvrir le panneau après fermeture de la modal d'info
  // Ouvrir le panneau après fermeture de la modal d'info
  const modalCloseBtn = document.querySelector('#reorgInfoModal .btn-close-info');
  console.log('[REORG-PANEL] modalCloseBtn trouvé:', !!modalCloseBtn);
  
  if (modalCloseBtn) {
    modalCloseBtn.addEventListener('click', function() {
      console.log('[REORG-PANEL] 🖱️ Bouton "J\'ai compris" cliqué');
      const modal = document.getElementById('reorgInfoModal');
      console.log('[REORG-PANEL] Modal trouvée:', !!modal);
      
      if (modal) {
        console.log('[REORG-PANEL] Classes modal avant:', modal.className);
        modal.classList.remove('show');
        modal.style.display = 'none';
        console.log('[REORG-PANEL] Modal fermée');
      }
      
          setTimeout(() => {
        console.log('[REORG-PANEL] ⏱️ setTimeout déclenché, appel startReorganization()');
        try {
          if (typeof window.startReorganization === 'function') {
            window.startReorganization();
          }
        } catch(err) {
          console.error('[REORG-PANEL] ❌ Erreur dans startReorganization:', err);

        }
      }, 200);
    });
  
// Démarrer la réorganisation
function startReorganization() {
    console.log('[REORG-PANEL] 🚀 Démarrage réorganisation');
    console.log('[REORG-PANEL] panel element:', panel);
    console.log('[REORG-PANEL] panel existe?', !!panel);
    
    // Fermer le popup s'il est ouvert pour éviter les blocages
    const mapPopup = document.getElementById('mapPopup');
    if (mapPopup) {
      console.log('[REORG-PANEL] Fermeture du popup carte');
      mapPopup.classList.remove('show');
    }
    window.popupLocked = false;
    
    reorgState.active = true;
    console.log('[REORG-PANEL] État actif:', reorgState.active);

    reorgState.newOrder = []; // Vide au départ : l'utilisateur clique pour construire l'ordre
    reorgState.deleted = [];
    
  console.log('[REORG-PANEL] Avant ajout classe "show"');
    console.log('[REORG-PANEL] Classes actuelles du panel:', panel.className);
    console.log('[REORG-PANEL] Style inline du panel:', panel.style.display);
    
    // Supprimer le style inline qui pourrait bloquer l'affichage
    panel.style.display = '';
    panel.classList.add('show');
    console.log('[REORG-PANEL] Classes après ajout "show":', panel.className);
    
    document.body.classList.add('reorg-active');
    console.log('[REORG-PANEL] Classe reorg-active ajoutée au body');


    
    console.log('[REORG-PANEL] Appel renderStepsList()');
    renderStepsList();
    console.log('[REORG-PANEL] ✅ renderStepsList terminée, appel setupMarkerEvents()');
    setupMarkerEvents();
    console.log('[REORG-PANEL] ✅ setupMarkerEvents terminée, appel setupGroupLabelsEvents()');
        setupGroupLabelsEvents();
    console.log('[REORG-PANEL] ✅ setupGroupLabelsEvents terminée');
    console.log('[REORG-PANEL] ✅ startReorganization terminée');
  }
  // ← expose globalement pour le handler du bouton
  window.startReorganization = startReorganization;

  // === Bouton Réorganisation plein écran ===
  document.addEventListener('DOMContentLoaded', function(){
    const reorgBtn = document.getElementById('reorgFullscreenBtn');
    if (reorgBtn) {
      reorgBtn.addEventListener('click', function(e){
        e.preventDefault();
        e.stopPropagation();
        console.log('[REORG] Bouton fullscreen cliqué');
        // Passer en mode plein écran
        document.body.classList.add('view-map-only');
        localStorage.setItem('ort.view', 'map');
        
        // Afficher le bouton de sortie
        const btnFull = document.getElementById('btnMapFull');
        const btnExit = document.getElementById('btnMapExit');
        if (btnFull) btnFull.style.display = 'none';
        if (btnExit) btnExit.style.display = '';
        
        // Recalculer la carte
        if (window.map?.invalidateSize) {
          setTimeout(() => window.map.invalidateSize(), 100);
        }
        
        // Lancer la réorganisation
        if (typeof window.startReorganization === 'function') {
          window.startReorganization();
        }
      });
    }
  });

  // Arrêter la réorganisation
 function stopReorganization() {


  console.log('[REORG-PANEL] Arrêt réorganisation');
  
  reorgState.active = false;
  reorgState.newOrder = [];        // ← AJOUT : Réinitialise l'ordre
  reorgState.deleted = [];         // ← AJOUT : Réinitialise les suppressions
  delete reorgState.savedMapState; // ← AJOUT : Nettoie l'état sauvegardé
  
  panel.classList.remove('show');
  document.body.classList.remove('reorg-active');
  
  // ← FORCER LA SORTIE DU MODE PLEIN ÉCRAN
  document.body.classList.remove('view-map-only');
  localStorage.setItem('ort.view', 'normal');
  const btnFull = document.getElementById('btnMapFull');
  const btnExit = document.getElementById('btnMapExit');
  if (btnFull) btnFull.style.display = '';
  if (btnExit) btnExit.style.display = 'none';
  
  // Recalculer la taille de la carte avec plusieurs invalidations progressives
  // (nécessaire en mode côte-à-côte où les dimensions CSS changent avec !important)
  if (window.map?.invalidateSize) {
    // Immédiat
    window.map.invalidateSize();
    // Après le retrait des classes CSS
    setTimeout(() => window.map.invalidateSize(), 50);
    // Après l'application complète des styles côte-à-côte
    setTimeout(() => window.map.invalidateSize(), 150);
    setTimeout(() => window.map.invalidateSize(), 300);
    // Final - pour être vraiment sûr
    setTimeout(() => window.map.invalidateSize(), 500);
  }
  
// Sur mobile/tablette, forcer un recalcul supplémentaire au prochain resize
  const resizeHandler = () => {
    if (window.map?.invalidateSize) {
      window.map.invalidateSize();
    }
    window.removeEventListener('resize', resizeHandler);
  };
  window.addEventListener('resize', resizeHandler);
  
  // Nettoyer après 2 secondes si aucun resize
  setTimeout(() => {
    window.removeEventListener('resize', resizeHandler);
  }, 2000);


console.log('[REORG] Sortie réorg - recalcul carte');
  console.log('[REORG] Layout actuel:', 
    document.body.classList.contains('layout-side') ? 'côte-à-côte' : 'empilé'
  );
  
  if (window.map?.invalidateSize) {
    window.map.invalidateSize();
    console.log('[REORG] invalidateSize #1 (immédiat)');
    
    setTimeout(() => {
      window.map.invalidateSize();
      console.log('[REORG] invalidateSize #2 (50ms)');
    }, 50);
    
    setTimeout(() => {
      window.map.invalidateSize();
      console.log('[REORG] invalidateSize #3 (150ms)');
    }, 150);
    
    setTimeout(() => {
      window.map.invalidateSize();
      console.log('[REORG] invalidateSize #4 (300ms)');
    }, 300);
    
    setTimeout(() => {
      window.map.invalidateSize();
      console.log('[REORG] invalidateSize #5 (500ms - FINAL)');
    }, 500);
  }


// ← AJOUT : Réactiver le bouton de réorganisation
const reorgBtn = document.getElementById('reorgFullscreenBtn'); // <-- correct
if (reorgBtn) {
  reorgBtn.disabled = false;
  reorgBtn.style.opacity = '1';
  reorgBtn.style.cursor = 'pointer';
}
  
  const allMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : null;
  if (allMarkers) {
    allMarkers.forEach(m => {
      const icon = m.getElement();
      if (icon) {
        icon.classList.remove('reorg-selected', 'reorg-deleted');
      }
    });
  }
}
  
// Générer la liste des étapes dans le panneau
function renderStepsList() {
    console.log('[REORG-PANEL] 📋 renderStepsList() appelée');
    console.log('[REORG-PANEL] stepsList element:', stepsList);
    
    if (!stepsList) {
      console.error('[REORG-PANEL] ❌ stepsList introuvable');
      return;
    }
    
    console.log('[REORG-PANEL] Vidage de stepsList');
    stepsList.innerHTML = '';
    
    // IMPORTANT : Afficher dans l'ordre ORIGINAL, pas dans le nouvel ordre
    console.log('[REORG-PANEL] window.state:', window.state);
console.log('[REORG-PANEL] window.state.steps:', window.state?.steps);
const allSteps = [...window.state.steps];
console.log('[REORG-PANEL] 📝 Affichage de', allSteps.length, 'étapes');
console.log('[REORG-PANEL] reorgState.newOrder:', reorgState.newOrder);
console.log('[REORG-PANEL] reorgState.deleted:', reorgState.deleted);


    
   allSteps.forEach((step, index) => {

      const sid = step.__sid;
      const isDeleted = reorgState.deleted.includes(sid);
      const orderIndex = reorgState.newOrder.indexOf(sid);
      const inNewOrder = orderIndex !== -1;
      const hasChanged = !isDeleted && inNewOrder;
      
      const item = document.createElement('div');
      item.className = 'reorg-step-item';
      item.dataset.sid = sid;
      
      if (isDeleted) {
        item.classList.add('deleted');
      } else if (hasChanged) {
        // Position changée : fond ROUGE
        item.classList.add('selected');
      }
      
const num = document.createElement('div');
      num.className = 'reorg-step-num';
      if (isDeleted) {
        num.textContent = '✕';
      } else if (hasChanged) {
        // Afficher "numéro initial → nouveau numéro"
        num.innerHTML = `${index + 1} <span style="color:#ef4444;font-weight:900;">→ ${orderIndex + 1}</span>`;
      } else {
        num.textContent = index + 1;
      }

      
      const info = document.createElement('div');
      info.className = 'reorg-step-info';
      
      const name = document.createElement('div');
      name.className = 'reorg-step-name';
      name.textContent = step.name || 'Étape sans nom';
      
     const meta = document.createElement('div');
      meta.className = 'reorg-step-meta';
      const nights = step.nights || 0;
      const nightsText = nights > 1 ? TR.nightsPlural : TR.nights;
      meta.textContent = `${nights} ${nightsText}`;
      
      info.appendChild(name);
      info.appendChild(meta);
      
// Badge état
      if (isDeleted) {
        const badge = document.createElement('div');
        badge.className = 'reorg-step-badge';
        badge.textContent = TR.deleted;
        item.appendChild(badge);

 } else if (hasChanged) {
        const badge = document.createElement('div');
        badge.className = 'reorg-step-badge';
        badge.textContent = `#${orderIndex + 1}`;
        item.appendChild(badge);
      }
 
      item.appendChild(num);
      item.appendChild(info);
      
  item.addEventListener('click', (e) => {
        console.log('[REORG-PANEL] ✓ CLIC détecté sur item', sid);
        
        // Si un timer existe déjà, c'est un double-clic
        if (reorgState.clickTimer) {
          clearTimeout(reorgState.clickTimer);
          reorgState.clickTimer = null;
          console.log('[REORG-PANEL] ✓✓ DOUBLE-CLIC confirmé sur item', sid);
          e.preventDefault();
          e.stopPropagation();
          handleStepDoubleClick(sid);
        } else {
          // Sinon, attendre un peu pour voir si un deuxième clic arrive
          reorgState.clickTimer = setTimeout(() => {
            reorgState.clickTimer = null;
            console.log('[REORG-PANEL] ✓ CLIC SIMPLE confirmé sur item', sid);
            handleStepClick(sid);
          }, 250); // 250ms pour détecter le double-clic
        }
      });


      
      stepsList.appendChild(item);
    });
  }
  
// Clic simple sur une étape
  function handleStepClick(sid) {
    console.log('[REORG-PANEL] Clic sur étape', sid);
    
    const isDeleted = reorgState.deleted.includes(sid);
    if (isDeleted) {
      // Si l'étape est supprimée, ne rien faire
      return;
    }
    
    const originalIndex = window.state.steps.findIndex(s => s.__sid === sid);
    const currentOrderIndex = reorgState.newOrder.indexOf(sid);
    
    // LOGIQUE : Chaque clic définit la prochaine position dans le nouvel itinéraire
    // On compte combien d'étapes sont déjà ordonnées (non supprimées)
    const orderedCount = reorgState.newOrder.filter(id => !reorgState.deleted.includes(id)).length;
    
    if (currentOrderIndex !== -1) {
      // Déjà cliqué : on le retire pour permettre de re-cliquer
      reorgState.newOrder.splice(currentOrderIndex, 1);
      console.log('[REORG-PANEL] → Étape retirée du nouvel ordre');
    } else {
      // Pas encore cliqué : on l'ajoute à la position suivante
      reorgState.newOrder.push(sid);
      console.log('[REORG-PANEL] → Étape ajoutée en position', orderedCount + 1);
    }
    
    // Mettre à jour l'affichage
// Mettre à jour l'affichage
    renderStepsList();
    updateMarkers();

     updateAllMarkersVisualState();

    // Feedback visuel : animer l'élément de la liste
    const item = stepsList.querySelector(`[data-sid="${sid}"]`);
    if (item) {
      item.style.transform = 'scale(1.05)';
      setTimeout(() => {
        item.style.transform = '';
      }, 200);
    }

    // Feedback visuel : animer le marqueur sur la carte (effet miroir)
    const allMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : null;
    if (allMarkers) {
      const marker = allMarkers.find(m => m.stepId === sid);
      if (marker) {
        const icon = marker.getElement();
        if (icon) {
          // Retirer d'abord la classe si elle existe
          icon.classList.remove('marker-animate-red');
          
          // Forcer un reflow pour que le navigateur redémarre l'animation
          void icon.offsetWidth;
          
          // Ajouter la classe d'animation
          icon.classList.add('marker-animate-red');
          
          // Retirer la classe après l'animation (600ms)
          setTimeout(() => {
            icon.classList.remove('marker-animate-red');
          }, 600);
        }
      }
    }
     }
  
// Double-clic sur une étape
  function handleStepDoubleClick(sid) {
    console.log('[REORG-PANEL] Double-clic sur étape', sid);
    
    const isDeleted = reorgState.deleted.includes(sid);
    
    // SCENARIO 1 : Double-clic sur une étape supprimée → Réintégration
    if (isDeleted) {
      reorgState.deleted = reorgState.deleted.filter(id => id !== sid);
      // Remettre dans l'ordre à la fin
      if (!reorgState.newOrder.includes(sid)) {
        reorgState.newOrder.push(sid);
      }
      console.log('[REORG-PANEL] Étape réintégrée:', sid);
    } 
    // SCENARIO 2 : Double-clic sur une étape active → Suppression
    else {
      reorgState.deleted.push(sid);
      reorgState.newOrder = reorgState.newOrder.filter(id => id !== sid);
      console.log('[REORG-PANEL] Étape supprimée:', sid);
    }
    
    // Mettre à jour l'affichage
  // Mettre à jour l'affichage
    renderStepsList();
    updateMarkers();
updateAllMarkersVisualState();
    
    // Feedback visuel : animation de suppression/réintégration sur la liste
    const item = stepsList.querySelector(`[data-sid="${sid}"]`);
    if (item) {
      if (isDeleted) {
        // Animation de réintégration
        item.style.transform = 'translateX(-20px)';
        item.style.opacity = '0.5';
        setTimeout(() => {
          item.style.transform = '';
          item.style.opacity = '';
        }, 150);
      } else {
        // Animation de suppression
        item.style.transform = 'translateX(20px)';
        item.style.opacity = '0.5';
        setTimeout(() => {
          item.style.transform = '';
          item.style.opacity = '';
        }, 150);
      }
    }
    
// Feedback visuel : animer le marqueur sur la carte (effet miroir)
    const allMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : null;
    if (allMarkers) {
      const marker = allMarkers.find(m => m.stepId === sid);
      if (marker) {
        const icon = marker.getElement();
        if (icon) {
          if (isDeleted) {
            // Animation de réintégration : pulsation verte
            icon.classList.remove('marker-animate-green');
            void icon.offsetWidth; // Force reflow
            icon.classList.add('marker-animate-green');
            setTimeout(() => {
              icon.classList.remove('marker-animate-green');
            }, 600);
          } else {
            // Animation de suppression : pulsation grise
            icon.classList.remove('marker-animate-gray');
            void icon.offsetWidth; // Force reflow
            icon.classList.add('marker-animate-gray');
            setTimeout(() => {
              icon.classList.remove('marker-animate-gray');
            }, 600);
          }
        }
      }
    }
  }
  
  // Exposer les fonctions globalement pour les clics sur marqueurs
  window.handleStepClick = handleStepClick;
  window.handleStepDoubleClick = handleStepDoubleClick;
  
// Mettre à jour l'affichage des marqueurs sur la carte
  function updateMarkers() {
    console.log('[REORG-PANEL] 🗺️ updateMarkers() appelée');
    const allMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : null;
    console.log('[REORG-PANEL] allMarkers:', allMarkers?.length || 0, 'marqueurs');
    
    if (!allMarkers || allMarkers.length === 0) {
      console.log('[REORG-PANEL] ⚠️ Aucun marqueur disponible');
      return;
    }
    
    allMarkers.forEach(marker => {

      const sid = marker.stepId;
      
      marker.off('click');
      marker.off('dblclick');
      marker.off('mouseover');
      marker.off('mouseout');
      
      // Afficher le popup au survol
      marker.on('mouseover', function(e) {
        const step = state.steps.find(s => s.__sid === sid);
        if (step) {
          showStepPreview(step);
          document.getElementById('mapPopup')?.classList.add('show');
        }
      });
      
      marker.on('mouseout', function(e) {
        if (!window.popupLocked) {
          document.getElementById('mapPopup')?.classList.remove('show');
        }
      });
      
      marker.on('click', function(e) {
        console.log('[REORG-PANEL] 🗺️ CLIC sur marqueur carte', sid);
        L.DomEvent.stopPropagation(e);
        handleStepClick(sid);
      });
      
     marker.on('click', function(e) {
        console.log('[REORG-PANEL] 🗺️ CLIC sur marqueur carte', sid);
        L.DomEvent.stopPropagation(e);
        handleStepClick(sid);
      });
      
      marker.on('dblclick', function(e) {
        console.log('[REORG-PANEL] 🗺️ DOUBLE-CLIC sur marqueur carte', sid);
        L.DomEvent.stopPropagation(e);
        handleStepDoubleClick(sid);
      });
    });
  }
  
 function setupMarkerEvents() {
    const allMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : null;

    if (!allMarkers || allMarkers.length === 0) {
      console.log('[REORG-PANEL] ⚠️ Aucun marqueur pour l\'instant — attente de "ort:markers-ready"');
      const once = (e)=>{ 
        window.removeEventListener('ort:markers-ready', once, {capture:false});
        console.log('[REORG-PANEL] 📢 Event "ort:markers-ready" reçu, relance setupMarkerEvents()');
        setupMarkerEvents();
      };
      window.addEventListener('ort:markers-ready', once, {capture:false, once:true});
      return;
    }

    console.log('[REORG-PANEL] ✅ Configuration de', allMarkers.length, 'marqueurs');
    
    allMarkers.forEach(marker => {

      const sid = marker.stepId;
      
      marker.off('click');
      marker.off('dblclick');
      
      marker.on('click', function(e) {
        console.log('[REORG-PANEL] 🗺️ CLIC sur marqueur carte', sid);
        L.DomEvent.stopPropagation(e);
        handleStepClick(sid);
      });
      
      marker.on('dblclick', function(e) {
        console.log('[REORG-PANEL] 🗺️ DOUBLE-CLIC sur marqueur carte', sid);
        L.DomEvent.stopPropagation(e);
        handleStepDoubleClick(sid);
      });
    });
  }
  // Mettre à jour l'apparence des mini-marqueurs en fonction de l'état
function updateMiniMarkersAppearance() {
    console.log('[REORG-PANEL] 🎨 updateMiniMarkersAppearance() appelée');
    const allGroupLabels = (window.ORT && Array.isArray(window.ORT.groupLabels)) ? window.ORT.groupLabels : [];
    console.log('[REORG-PANEL] Nombre de mini-marqueurs:', allGroupLabels.length);
    console.log('[REORG-PANEL] reorgState.newOrder:', reorgState.newOrder);
    console.log('[REORG-PANEL] reorgState.deleted:', reorgState.deleted);
    
    allGroupLabels.forEach(miniMarker => {
      console.log('[REORG-PANEL] Traitement mini-marqueur:', miniMarker.stepId, 'isMiniMarker:', miniMarker.isMiniMarker);

      if (!miniMarker.stepId || !miniMarker.isMiniMarker) return;
      
      const sid = miniMarker.stepId;
      const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
      if (!el) return;
      
      const isDeleted = reorgState.deleted.includes(sid);
      const isInNewOrder = reorgState.newOrder.includes(sid);
      
console.log('[REORG-PANEL] Mini-marqueur', sid, '- deleted:', isDeleted, 'inNewOrder:', isInNewOrder);
      // Appliquer les styles en fonction de l'état
      if (isDeleted) {
        el.style.background = '#ef4444';
        el.style.opacity = '0.5';
        el.style.borderColor = '#fee2e2';
      } else if (isInNewOrder) {
        el.style.background = '#ef4444';
        el.style.opacity = '1';
        el.style.borderColor = '#fbbf24';
      } else {
        el.style.background = '#3b82f6';
        el.style.opacity = '1';
        el.style.borderColor = 'white';
      }
    });
  }
  
function updateAllMarkersVisualState() {
    console.log('[REORG-VISUAL] updateAllMarkersVisualState appelée');
    console.log('[REORG-VISUAL] reorgState:', reorgState);
    
    const miniMarkers = (window.ORT && Array.isArray(window.ORT.groupLabels)) ? window.ORT.groupLabels : [];
    miniMarkers.forEach(miniMarker => {
      if (!miniMarker.stepId || !miniMarker.isMiniMarker) return;
      const sid = miniMarker.stepId;
      const el = miniMarker.getElement()?.querySelector('.mini-step-marker');
      if (!el) return;
      
      const isDeleted = reorgState.deleted.includes(sid);
      const isInNewOrder = reorgState.newOrder.includes(sid);
      
      if (isDeleted) {
        el.style.background = '#ef4444';
        el.style.opacity = '0.5';
        el.style.borderColor = '#fee2e2';
      } else if (isInNewOrder) {
        el.style.background = '#ef4444';
        el.style.opacity = '1';
        el.style.borderColor = '#fbbf24';
      } else {
        el.style.background = '#3b82f6';
        el.style.opacity = '1';
        el.style.borderColor = 'white';
      }
    });
    
    const mainMarkers = (window.ORT && Array.isArray(window.ORT.markers)) ? window.ORT.markers : [];
    console.log('[REORG-VISUAL] mainMarkers:', mainMarkers.length);
    
    mainMarkers.forEach(m => {
      const markerEl = m.getElement();
      if (!markerEl) {
        console.log('[REORG-VISUAL] Pas d\'élément pour marqueur', m.stepId);
        return;
      }
      
      // L'élément markerEl EST le .step-marker (Leaflet divIcon className)
      const numEl = markerEl.querySelector('.marker-num');
      
      const mSid = m.stepId;
      const mIsInNewOrder = reorgState.newOrder.includes(mSid);
      const mIsDeleted = reorgState.deleted.includes(mSid);
      
      console.log('[REORG-VISUAL] Marqueur', mSid, 'inNewOrder:', mIsInNewOrder, 'deleted:', mIsDeleted);
      
      if (mIsDeleted) {
        markerEl.classList.remove('marker-red');
        markerEl.classList.add('reorg-deleted');
        markerEl.style.setProperty('opacity', '0.5', 'important');
        markerEl.style.setProperty('filter', 'grayscale(100%)', 'important');
        console.log('[REORG-VISUAL] Marqueur', mSid, '→ SUPPRIMÉ (gris)');
      } else if (mIsInNewOrder) {
        markerEl.classList.remove('reorg-deleted');
        markerEl.classList.add('marker-red');
        markerEl.style.setProperty('opacity', '1', 'important');
        markerEl.style.setProperty('filter', 'none', 'important');
        markerEl.style.setProperty('background', '#ef4444', 'important');
        markerEl.style.setProperty('background-color', '#ef4444', 'important');
        markerEl.style.setProperty('border-color', '#fecaca', 'important');
        if (numEl) numEl.style.color = 'white';
        console.log('[REORG-VISUAL] Marqueur', mSid, '→ SÉLECTIONNÉ (rouge)', markerEl.className);
      } else {
        markerEl.classList.remove('marker-red', 'reorg-deleted');
        markerEl.style.removeProperty('opacity');
        markerEl.style.removeProperty('filter');
        markerEl.style.removeProperty('background');
        markerEl.style.removeProperty('border-color');
        if (numEl) numEl.style.color = '';
      }
    });
  }
  
// Configurer les événements sur les labels de groupe (étapes multiples)
// Configurer les événements sur les mini-marqueurs (sous-étapes)
  function setupGroupLabelsEvents() {
    const allGroupLabels = (window.ORT && Array.isArray(window.ORT.groupLabels)) ? window.ORT.groupLabels : [];
    
    if (!allGroupLabels || allGroupLabels.length === 0) {
      console.log('[REORG-PANEL] ⚠️ Aucun mini-marqueur de groupe');
      return;
    }
    
    console.log('[REORG-PANEL] ✅ Configuration de', allGroupLabels.length, 'mini-marqueurs');
    
    allGroupLabels.forEach(miniMarker => {
      if (!miniMarker.stepId || !miniMarker.isMiniMarker) return;
      
      const sid = miniMarker.stepId;
      
      // Nettoyer les anciens événements
      miniMarker.off('click');
      miniMarker.off('dblclick');
      
      // Clic simple : sélectionner cette sous-étape
      miniMarker.on('click', function(e) {
        L.DomEvent.stopPropagation(e);
        console.log('[REORG-PANEL] 🗺️ CLIC sur mini-marqueur', sid);
        handleStepClick(sid);
      });
      
      // Double-clic : éditer cette sous-étape
      miniMarker.on('dblclick', function(e) {
        L.DomEvent.stopPropagation(e);
        console.log('[REORG-PANEL] 🗺️ DOUBLE-CLIC sur mini-marqueur', sid);
        handleStepDoubleClick(sid);
      });
    });
  }

// Afficher la modal de prévisualisation
  function showPreviewModal() {
    console.log('[REORG-PREVIEW] ========== DEBUT ==========');
    console.log('[REORG-PREVIEW] Ouverture de la modal de prévisualisation');
    
    // Vérifier qu'on garde au moins une étape
    const keptSteps = window.state.steps.filter(s => !reorgState.deleted.includes(s.__sid));
    if (keptSteps.length === 0) {
      alert(TR.mustKeepOne);
      return;
    }
    
    // Construire l'aperçu du nouvel ordre (même logique que saveReorganization)
    const previewSteps = [];
    const processedIds = new Set();
    
    // Ajouter les étapes réordonnées en premier
    reorgState.newOrder.forEach(sid => {
      if (!reorgState.deleted.includes(sid)) {
        const step = window.state.steps.find(s => s.__sid === sid);
        if (step) {
          previewSteps.push(step);
          processedIds.add(sid);
        }
      }
    });
    
    // Ajouter les étapes non touchées à la fin
    window.state.steps.forEach(step => {
      const sid = step.__sid;
      if (!processedIds.has(sid) && !reorgState.deleted.includes(sid)) {
        previewSteps.push(step);
      }
    });
    
    // Générer le HTML de prévisualisation
    const modal = document.getElementById('reorgPreviewModal');
    const content = document.getElementById('reorgPreviewContent');
    

console.log('[REORG-PREVIEW] Modal trouvée:', !!modal);
    console.log('[REORG-PREVIEW] Content trouvé:', !!content);
    
    if (!modal || !content) {
      console.error('[REORG-PREVIEW] Modal ou contenu non trouvé');
      return;
    }
    
    // Construire la liste des étapes

    let html = '';
    previewSteps.forEach((step, index) => {
      const nights = step.nights || 0;
      const nightsText = nights === 1 ? TR.nights : TR.nightsPlural;
      
      html += `
        <div class="preview-step-item">
          <div class="preview-step-num">${index + 1}</div>
          <div class="preview-step-content">
            <div class="preview-step-name">${step.name || 'Étape sans nom'}</div>
            ${nights > 0 ? `<div class="preview-step-nights">${nights} ${nightsText}</div>` : ''}
          </div>
        </div>
      `;
    });
    
    content.innerHTML = html;
    
// Masquer le panneau de réorganisation à droite
    const reorgPanel = document.getElementById('reorgPanel');
    if (reorgPanel) {
      reorgPanel.style.display = 'none';
    }
    
    // Afficher la modal (à gauche, moins large)
    modal.style.display = 'flex';
    setTimeout(() => modal.classList.add('show'), 10);
    
    // Sauvegarder l'état actuel de la carte et des steps pour pouvoir les restaurer
    console.log('[REORG-PREVIEW] 🗺️ Tentative d\'accès à map');
    console.log('[REORG-PREVIEW] typeof map:', typeof map);
    console.log('[REORG-PREVIEW] map:', map);
    console.log('[REORG-PREVIEW] typeof window.map:', typeof window.map);
    
    if (!reorgState.savedMapState) {
      console.log('[REORG-PREVIEW] Sauvegarde de l\'état de la carte');
      
      // Utiliser window.map si map n'est pas accessible
     const theMap = window.map || map;
      console.log('[REORG-PREVIEW] theMap:', theMap);
      console.log('[REORG-PREVIEW] theMap type:', typeof theMap);
      console.log('[REORG-PREVIEW] theMap.getCenter exists?', typeof theMap?.getCenter);
      
      if (theMap && typeof theMap.getCenter === 'function') {
  reorgState.savedMapState = {
    center: theMap.getCenter(),
    zoom: theMap.getZoom(),
    originalSteps: [ ...window.state.steps ]
  };
  console.log('[REORG-PREVIEW] ✅ État sauvegardé:', reorgState.savedMapState);
} else {
  console.warn('[REORG-PREVIEW] ⚠️ Carte non disponible, pas de sauvegarde de position');
    reorgState.savedMapState = {
    center: null,
    zoom: null,
    originalSteps: [ ...window.state.steps ]
  };

}

    }
    
// Appliquer temporairement le nouvel ordre aux steps pour le rendu
    window.state.steps = previewSteps;
    
    // IMPORTANT : Sauvegarder previewSteps pour que saveReorganization utilise le même ordre
    reorgState.previewSteps = previewSteps;
    console.log('[REORG-PREVIEW] ✅ previewSteps sauvegardé:', previewSteps.map(s => s.name));
    
    // Recharger la carte avec le nouvel itinéraire
    renderRows();
    
    // Gérer les boutons

    const btnCancel = modal.querySelector('.btn-preview-cancel');
    const btnValidate = modal.querySelector('.btn-preview-validate');
    
    console.log('[REORG-PREVIEW] btnCancel trouvé:', !!btnCancel);
    console.log('[REORG-PREVIEW] btnValidate trouvé:', !!btnValidate);

 // Fonction pour fermer la modal et restaurer l'écran de réorganisation
    const closePreviewModal = () => {
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
        
        // Réafficher le panneau de réorganisation
        if (reorgPanel) {
          reorgPanel.style.display = 'flex';
        }
        
      // Restaurer les steps originaux et la carte
        if (reorgState.savedMapState) {
          console.log('[REORG-PREVIEW] Restauration de l\'état de la carte');
          window.state.steps = reorgState.savedMapState.originalSteps;
          renderRows();
          
          const theMap = window.map || map;
          if (theMap && reorgState.savedMapState.center && typeof theMap.setView === 'function') {
            theMap.setView(reorgState.savedMapState.center, reorgState.savedMapState.zoom);
            console.log('[REORG-PREVIEW] ✅ Vue de la carte restaurée');
          }
          
          delete reorgState.savedMapState;
        }
      }, 300);
    };
    
    // Retirer les anciens listeners pour éviter les doublons
    const newBtnCancel = btnCancel.cloneNode(true);
    const newBtnValidate = btnValidate.cloneNode(true);
    btnCancel.parentNode.replaceChild(newBtnCancel, btnCancel);
    btnValidate.parentNode.replaceChild(newBtnValidate, btnValidate);
    
    // Annuler : fermer la modal et revenir à l'écran 1
newBtnCancel.addEventListener('click', () => {
      console.log('[REORG-PREVIEW] *** BOUTON ANNULER CLIQUÉ ***');
      closePreviewModal();
    });
    
    // Valider : appeler saveReorganization et fermer
    newBtnValidate.addEventListener('click', () => {
      console.log('[REORG-PREVIEW] Validation');
      modal.classList.remove('show');
      setTimeout(() => {
        modal.style.display = 'none';
        if (reorgPanel) {
          reorgPanel.style.display = 'flex';
        }
        delete reorgState.savedMapState;
        saveReorganization();
      }, 300);
    });
  }
  

    
    // Sauvegarder les modifications
  function saveReorganization() {
    console.log('[REORG-PANEL] Sauvegarde');
    
    // Utiliser directement les steps de la prévisualisation
    if (reorgState.previewSteps && reorgState.previewSteps.length > 0) {
      console.log('[REORG-SAVE] ✅ Utilisation des steps de la preview:', reorgState.previewSteps.map(s => s.name));
      window.state.steps = reorgState.previewSteps;
      delete reorgState.previewSteps;
    } else {
      console.warn('[REORG-SAVE] ⚠️ Pas de previewSteps disponible');
      alert('Erreur : veuillez prévisualiser avant de valider');
      return;
    }

    if (typeof window.saveToStorage === 'function') {
      window.saveToStorage();
    }
// Sauvegarde via State Manager avec flag saved=true
if (window.ORT_DETAIL_ADAPTER && typeof window.ORT_DETAIL_ADAPTER.saveCurrent === 'function') {
  console.log('[REORG] Declenchement sauvegarde State Manager');
  window.ORT_DETAIL_ADAPTER.saveCurrent(true);
}
    if (typeof window.renderRows === 'function') {
      window.renderRows();
    }
    if (typeof window.renderMap === 'function') {
      window.renderMap();
    }
    
   stopReorganization();
  showToast(TR.saved);

  // 🔁 Permettre une nouvelle réorganisation sans rechargement
  setTimeout(() => {
    if (typeof startReorganization === 'function') {
      console.log('[REORG] ✅ Réactivation possible du mode réorganisation');
      reorgState.active = false;
      const reorgBtn = document.getElementById('reorgFullscreenBtn');
      if (reorgBtn) {
        reorgBtn.disabled = false;
        reorgBtn.style.opacity = '1';
        reorgBtn.style.cursor = 'pointer';
      }
    }
  }, 600);
}


  
  // Toast de notification
  function showToast(message) {
    const toast = document.createElement('div');
    Object.assign(toast.style, {
      position: 'fixed',
      bottom: '24px',
      left: '50%',
      transform: 'translateX(-50%)',
      background: '#113f7a',
      color: '#fff',
      padding: '12px 24px',
      borderRadius: '10px',
      boxShadow: '0 4px 12px rgba(0,0,0,0.3)',
      zIndex: 14000,
      fontWeight: '700'
    });
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s';
      setTimeout(() => toast.remove(), 300);
    }, 2500);
  }
  

  panelCloseBtn.addEventListener('click', stopReorganization);

  
  // Remplacer le bouton saveBtn par previewBtn
if (previewBtn) {
    console.log('[REORG-PANEL] ✅ Bouton preview trouvé, ajout du listener');
    console.log('[REORG-PANEL] previewBtn element:', previewBtn);
    console.log('[REORG-PANEL] previewBtn computed style:', window.getComputedStyle(previewBtn).pointerEvents);
    console.log('[REORG-PANEL] previewBtn z-index:', window.getComputedStyle(previewBtn).zIndex);
    console.log('[REORG-PANEL] previewBtn display:', window.getComputedStyle(previewBtn).display);
    console.log('[REORG-PANEL] previewBtn visibility:', window.getComputedStyle(previewBtn).visibility);
    
    previewBtn.addEventListener('click', () => {
      console.log('[REORG-PANEL] 🔴 CLIC sur bouton Prévisualiser détecté !');
      console.log('[REORG-PANEL] Appel de showPreviewModal()');
      showPreviewModal();
    });
  } else {
    console.error('[REORG-PANEL] Bouton prévisualisation non trouvé');
  }
  
  console.log('[REORG-PANEL] typeof showPreviewModal:', typeof showPreviewModal);
  console.log('[REORG-PANEL] Prêt');
}
})();

// ===== INITIALISATION STATE MANAGER =====
(async function initStateManager() {
  console.log('[INIT] Initialisation State Manager...');
  
  // Charger Firebase si pas déjà chargé
  if (!window.firebase?.apps?.length) {
    console.log('[INIT] 🔄 Chargement Firebase...');
    const load = (src) => new Promise((ok, ko) => {
      const s = document.createElement('script');
      s.src = src;
      s.onload = ok;
      s.onerror = () => ko(new Error('load ' + src));
      document.head.appendChild(s);
    });
    
    try {
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js");
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js");
      await load("https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js");
      
      // Attendre que firebase.auth soit vraiment disponible (le script peut mettre du temps à s'initialiser)
      let authReady = false;
      for (let i = 0; i < 50 && !authReady; i++) {
        if (typeof window.firebase?.auth === 'function') {
          authReady = true;
        } else {
          await new Promise(r => setTimeout(r, 50));
        }
      }
      
      if (!authReady) {
        throw new Error('firebase.auth not available after loading');
      }
      
      // Initialiser Firebase seulement si pas déjà fait
      if (!window.firebase.apps.length) {
        window.firebase.initializeApp(window.__FIREBASE_CONFIG__);
      }
      await window.firebase.auth().setPersistence(window.firebase.auth.Auth.Persistence.LOCAL);
      console.log('[INIT] ✅ Firebase chargé');
    } catch (e) {
      console.warn('[INIT] ⚠️ Erreur chargement Firebase:', e);
    }
  }
  
  // Attend que Firebase Auth soit prêt
  console.log('[INIT] 🔍 Firebase disponible?', !!window.firebase);
  console.log('[INIT] 🔍 Firebase.auth disponible?', !!window.firebase?.auth);
  
  const user = await new Promise(resolve => {
    if (window.firebase?.auth) {
      console.log('[INIT] ⏳ Attente onAuthStateChanged...');
      const unsubscribe = firebase.auth().onAuthStateChanged(user => {
        console.log('[INIT] ✅ Auth state:', user ? user.uid : 'null', 'email:', user?.email);
        unsubscribe();
        resolve(user);
      });
    } else {
      console.log('[INIT] ❌ Firebase.auth non disponible');
      resolve(null);
    }
  });

  await window.ORT_STATE.init({
    user: user,
    premium: false
  });
  
  // Mettre à jour le user pour activer Firestore
  if (user) {
    console.log('[INIT] 🔄 Mise à jour user dans State Manager...');
    await window.ORT_STATE.updateUser(user);
  }

  console.log('[INIT] State Manager initialisé avec user:', user?.uid || 'non connecté');

  // Initialiser le bouton "Écrire source" pour admin
  if (typeof window.initSaveSourceButton === 'function') {
    console.log('[INIT] 🔴 Appel initSaveSourceButton...');
    window.initSaveSourceButton();
  }

  const urlParams = new URLSearchParams(window.location.search);
  const fromTemp = urlParams.get('from') === 'temp';
  const rtKey = urlParams.get('rtKey');
  
// MODE IMPORT : Ne pas utiliser le State Manager
if (fromTemp && rtKey) {
  console.log('[INIT] Mode IMPORT detecte - rtKey:', rtKey);
  console.log('[INIT] Pas de State Manager pour les imports');
  
  // Extraire CC depuis rtKey (format: CC_slug_timestamp)
  const ccFromRtKey = rtKey.split('_')[0]?.toUpperCase() || 'XX';
  
  // Créer la référence itinéraire pour "Écrire source"
  state._itinRef = {
    country: ccFromRtKey,
    itin: `${ccFromRtKey}::temp_${Date.now()}`
  };
  state.country = ccFromRtKey;
  state.cc = ccFromRtKey;
  console.log('[INIT] Mode TEMP - Référence créée:', state._itinRef);
  
  // Attendre que l'import soit chargé
  const waitForImport = setInterval(() => {
    if (window.state && window.state.steps && window.state.steps.length > 0) {
      clearInterval(waitForImport);
      
      // Générer un tripId temporaire
      const tempTripId = `temp_${Date.now()}`;
      window.ORT_DETAIL_ADAPTER.init(tempTripId, window.state);
      localStorage.setItem('ORT_CURRENT_TRIP_ID', tempTripId);
      // Sauvegarder l'état entier pour le fallback (retour back button)
      localStorage.setItem(`ORT_TEMP_STATE_${tempTripId}`, JSON.stringify(window.state));
      console.log('[INIT] Import initialisé avec tripId temp:', tempTripId);
    }
  }, 100);
  
  setTimeout(() => clearInterval(waitForImport), 5000);
  return;
}

// === MODE DASHBOARD : tripId dans l'URL SANS cc/itin → Charger depuis Firestore ===
const tripIdFromUrl = urlParams.get('tripId') || urlParams.get('id');
const ccParam = urlParams.get('cc');
const itinParam = urlParams.get('itin');

// Détecter si cc/itin sont vraiment définis (pas null/undefined/"null")
const hasValidCc = ccParam && ccParam !== 'null' && ccParam !== 'undefined';
const hasValidItin = itinParam && itinParam !== 'null' && itinParam !== 'undefined';

if (tripIdFromUrl && (!hasValidCc || !hasValidItin)) {
  console.log('[INIT] 📌 Mode DASHBOARD détecté - tripId:', tripIdFromUrl);
  
  // Attendre que ORT_STATE et renderRows soient prêts
  const waitForDeps = setInterval(async () => {
    if (window.ORT_STATE && typeof window.ORT_STATE.getTrip === 'function' && typeof window.renderRows === 'function') {
      clearInterval(waitForDeps);
      console.log('[INIT] ✅ Dépendances prêtes (ORT_STATE + renderRows)');
      
      try {
        let savedTrip = null;
        
        // Cas 1: tripId temporaire → chercher dans localStorage
        if (tripIdFromUrl.startsWith('temp_')) {
          console.log('[INIT] 🔧 TripId temporaire - cherche en localStorage');
          const savedStateStr = localStorage.getItem(`ORT_TEMP_STATE_${tripIdFromUrl}`);
          if (savedStateStr) {
            savedTrip = JSON.parse(savedStateStr);
            console.log('[INIT] ✅ État temporaire trouvé en localStorage');
          }
        }
        
        // Cas 2: tripId réel → chercher dans Firestore
        if (!savedTrip) {
          savedTrip = await window.ORT_STATE.getTrip(tripIdFromUrl);
        }
        
        if (savedTrip && savedTrip.steps && savedTrip.steps.length > 0) {
          console.log('[INIT] ✅ Voyage trouvé:', savedTrip.title || tripIdFromUrl, '-', savedTrip.steps.length, 'étapes');
          
          // Initialiser window.state avec les données sauvegardées
          window.state = window.state || {};
          window.state.steps = savedTrip.steps;
          window.state.title = savedTrip.title || 'Roadtrip';
          window.state.cc = savedTrip.country || 'XX';
          window.state.country = savedTrip.country || 'XX';
          window.state.tripId = tripIdFromUrl;
          
          if (savedTrip.nights) {
            window.state.targetNights = savedTrip.nights;
            window.state.initialNights = savedTrip.initialNights || savedTrip.nights;
          }
          
          // Restaurer les réservations (ancien format: savedTrip.bookings)
          if (savedTrip.bookings && typeof globalBookingManager !== 'undefined' && globalBookingManager) {
            window.state.bookings = savedTrip.bookings;
            Object.entries(savedTrip.bookings).forEach(([stepIdx, bookings]) => {
              if (Array.isArray(bookings)) {
                bookings.forEach(booking => {
                  globalBookingManager.addBooking(parseInt(stepIdx), booking);
                });
              }
            });
            console.log('[INIT] ✅ Réservations restaurées (ancien format)');
          }
          
          // Restaurer les réservations (nouveau format: steps[].bookings)
          if (savedTrip.steps && typeof globalBookingManager !== 'undefined' && globalBookingManager) {
            savedTrip.steps.forEach((step, stepIdx) => {
              if (step.bookings && Array.isArray(step.bookings) && step.bookings.length > 0) {
                step.bookings.forEach(booking => {
                  globalBookingManager.addBooking(stepIdx, booking);
                });
                console.log('[INIT] ✅ Réservations étape', stepIdx, ':', step.bookings.length);
              }
            });
          }
          
          // Restaurer les réservations voyage (travelBookings: vol, voiture, etc.)
          if (savedTrip.travelBookings && Array.isArray(savedTrip.travelBookings) && savedTrip.travelBookings.length > 0) {
            window.state.travelBookings = savedTrip.travelBookings;
            console.log('[INIT] ✅ Réservations voyage restaurées:', savedTrip.travelBookings.length);
          }
          
          // Restaurer les groupes d'étapes
          if (savedTrip._stepGroups && Object.keys(savedTrip._stepGroups).length > 0) {
            window.state._stepGroups = savedTrip._stepGroups;
            console.log('[INIT] ✅ Groupes restaurés:', Object.keys(window.state._stepGroups).length);
          }
          
          // Restaurer les métadonnées pour "Écrire source"
          if (savedTrip._sourceLanguage) {
            window.state._sourceLanguage = savedTrip._sourceLanguage;
            console.log('[INIT] ✅ Langue source restaurée:', savedTrip._sourceLanguage);
          }
          if (savedTrip._originalItinId) window.state._originalItinId = savedTrip._originalItinId;
          if (savedTrip._originalSourceUrl) window.state._originalSourceUrl = savedTrip._originalSourceUrl;
          if (savedTrip._originalCreatedAt) window.state._originalCreatedAt = savedTrip._originalCreatedAt;
          if (savedTrip.baseItinerary) {
            window.state._itinRef = savedTrip.baseItinerary;
            console.log('[INIT] ✅ _itinRef restauré:', savedTrip.baseItinerary);
          }
          
          // Mettre à jour la variable locale state
          Object.assign(state, window.state);
          
          // Initialiser l'adaptateur
          window.ORT_DETAIL_ADAPTER.init(tripIdFromUrl, window.state);
          localStorage.setItem('ORT_CURRENT_TRIP_ID', tripIdFromUrl);
          
          // Rafraîchir l'affichage
          window.renderRows();
          if (typeof setTitleTranslated === 'function') setTitleTranslated(window.state.title);
          if (typeof loadGroups === 'function') loadGroups();
          
          // Charger le budget et les photos utilisateur APRÈS init complète
          setTimeout(() => {
            if (typeof loadBudgetData === 'function') {
              console.log('[INIT] 🔄 Chargement budget/photos pour tripId:', tripIdFromUrl);
              loadBudgetData();
            }
          }, 500);
          
          console.log('[INIT] ✅ Mode DASHBOARD - Affichage terminé');
        } else {
          console.warn('[INIT] ⚠️ Voyage non trouvé en Firestore:', tripIdFromUrl);
        }
      } catch (e) {
        console.error('[INIT] ❌ Erreur chargement:', e);
      }
    }
  }, 100);
  
  setTimeout(() => clearInterval(waitForDeps), 10000);
  return; // Ne pas continuer vers MODE NORMAL
}

// === FALLBACK: URL VIDE → Charger depuis localStorage + ORT_STATE ===
// ══════════════════════════════════════════════════════════════
// SKIP si from=builder - le Route Builder gère tout lui-même
// ══════════════════════════════════════════════════════════════
const fromBuilder = urlParams.get('from');
if (fromBuilder === 'builder') {
  console.log('[INIT] ⏭️ Skip fallback - Route Builder actif');
  // Le Route Builder va créer son propre tripId et initialiser l'adaptateur
  return;
}

const cc = urlParams.get('cc');
const itin = urlParams.get('itin');
if (!cc || !itin) {
  console.log('[INIT] 🔄 URL vide - cherche tripId en localStorage');
  
  const savedTripId = localStorage.getItem('ORT_CURRENT_TRIP_ID');
  if (!savedTripId) {
    console.log('[INIT] ❌ Pas de tripId trouvé');
    return;
  }
  
  console.log('[INIT] 📌 TripId trouvé:', savedTripId);
  
  // === Cas 1: TripId temporaire (temp_XXXX) ===
  if (savedTripId.startsWith('temp_')) {
    console.log('[INIT] 🔧 TripId temporaire - cherche état en localStorage');
    
    const savedStateStr = localStorage.getItem(`ORT_TEMP_STATE_${savedTripId}`);
    if (savedStateStr) {
      try {
        const savedState = JSON.parse(savedStateStr);
        if (savedState && savedState.steps && savedState.steps.length > 0) {
          console.log('[INIT] ✅ État temporaire restauré:', savedTripId);
          
          // Mettre à jour WINDOW.STATE ET la variable locale state
          window.state = savedState;
          Object.assign(state, savedState); // ← Met à jour la variable locale state
          
          // Restaurer bookings DIRECTEMENT (pas via addBooking)
          if (window.state.bookings && typeof globalBookingManager !== 'undefined') {
            console.log('[INIT] 🎫 Bookings trouvés:', Object.keys(window.state.bookings).length, 'étapes');
            // Copier directement les bookings au lieu d'utiliser addBooking
            globalBookingManager.bookings = JSON.parse(JSON.stringify(window.state.bookings));
            console.log('[INIT] 🎫 Bookings restaurés dans globalBookingManager:', Object.keys(globalBookingManager.bookings).length, 'étapes');
          } else {
            console.log('[INIT] ⚠️ Pas de bookings ou globalBookingManager inexistant');
          }
          
          window.ORT_DETAIL_ADAPTER.init(savedTripId, window.state);
          console.log('[INIT] 💾 État & adaptateur restaurés');
          
          // APPELER RENDROWS DIRECTEMENT
          setTimeout(() => {
            if (typeof renderRows === 'function') {
              renderRows(); // renderTripBookings() s'appelle automatiquement dedans
              console.log('[INIT] 🎨 renderRows() appelé');
            }
          }, 100);
          
          // VRAIMENT SORTIR DU FALLBACK
          return;
        } else {
          console.warn('[INIT] ⚠️ État temporaire invalide');
        }
      } catch (e) {
        console.error('[INIT] Erreur parsing état temporaire:', e);
      }
    } else {
      console.warn('[INIT] ⚠️ État temporaire non trouvé en localStorage');
    }
    // CAS 1 TERMINÉ - continue vers code normal
    return;
  }
  
  // === Cas 2: TripId réel (depuis Firestore) ===
  console.log('[INIT] 📚 TripId réel - cherche dans State Manager...');
  
  let attempts = 0;
  const waitForStateManager = setInterval(async () => {
    attempts++;
    
    if (window.ORT_STATE && typeof window.ORT_STATE.getTrip === 'function') {
      clearInterval(waitForStateManager);
      
      try {
        const trip = await ORT_STATE.getTrip(savedTripId);
        console.log('[INIT] Trip récupéré:', trip ? trip.id : 'null');
        
        if (trip && trip.steps && trip.steps.length > 0) {
          console.log('[INIT] ✅ Trip chargé:', trip.id);
          
          // Mettre à jour WINDOW.STATE ET la variable locale state
          window.state = trip;
          Object.assign(state, trip); // ← Met à jour la variable locale state
          
          // Restaurer bookings
          if (trip.bookings && typeof globalBookingManager !== 'undefined') {
            console.log('[INIT] 🎫 Bookings trouvés (trip):', Object.keys(trip.bookings).length, 'étapes');
            // Copier directement les bookings
            globalBookingManager.bookings = JSON.parse(JSON.stringify(trip.bookings));
            console.log('[INIT] 🎫 Bookings restaurés dans globalBookingManager:', Object.keys(globalBookingManager.bookings).length, 'étapes');
          }
          
          window.ORT_DETAIL_ADAPTER.init(trip.id, window.state);
          
          // APPELER RENDERROWS DIRECTEMENT
          setTimeout(() => {
            if (typeof renderRows === 'function') {
              renderRows();
              console.log('[INIT] 🎨 renderRows() appelé (trip réel)');
            }
            if (typeof renderTripBookings === 'function') {
              renderTripBookings();
              console.log('[INIT] 🎨 renderTripBookings() appelé (trip réel)');
            }
          }, 100);
          
          return;
        } else {
          console.warn('[INIT] ⚠️ Trip invalide ou introuvable');
        }
      } catch (e) {
        console.error('[INIT] Erreur:', e);
      }
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(waitForStateManager);
    console.log('[INIT] Fallback timeout');
  }, 5000);
  return;
}
  
  // MODE NORMAL : Attendre que window.state soit prêt
  const waitForState = setInterval(async () => {
    if (window.state && window.state.steps) {
      clearInterval(waitForState);
      
      console.log('[INIT] window.state prêt');
      
      // Générer ou récupérer tripId de manière STABLE
      // PRIORITÉ: tripId > id > ORT_TRIPID > génération depuis cc+itin
      let tripId = urlParams.get('tripId') || urlParams.get('id');
      
      // Fallback sur ORT_TRIPID si pas dans URL
      if (!tripId && window.ORT_TRIPID) {
        tripId = window.ORT_TRIPID.get();
        if (tripId) console.log('[INIT] ✅ TripId depuis ORT_TRIPID:', tripId);
      }
      
      if (!tripId) {
        // Pour les RT standards (cc+itin), créer un tripId stable
        const cc = urlParams.get('cc');
        const itin = urlParams.get('itin');
        
        if (cc && itin && cc !== 'null' && itin !== 'null') {
          // TripId stable basé sur l'itinéraire (même ID à chaque visite)
          tripId = `user::${cc}::${itin}`.replace(/[^a-zA-Z0-9:_-]/g, '_');
          console.log('[INIT] ✅ TripId stable généré depuis cc+itin:', tripId);
        } else {
          // Sinon, générer un ID unique (RT temporaire/personnalisé)
          tripId = window.ORT_STATE.generateTripId();
          console.log('[INIT] ⚠️ TripId temporaire généré (pas de cc/itin valides):', tripId);
        }
      } else {
        console.log('[INIT] ✅ TripId depuis URL:', tripId);
      }
      
      // Stocker dans ORT_TRIPID pour cohérence
      if (window.ORT_TRIPID && tripId) {
        window.ORT_TRIPID.store(tripId);
      }
      
     // Chercher modifications sauvegardées (accepte trip_, user:: ET temp_)
      if (tripId && (tripId.startsWith('trip_') || tripId.startsWith('user::') || tripId.startsWith('temp_'))) {
        console.log('[INIT] 🔍 Recherche modifications pour:', tripId);
        
        try {
          const savedTrip = await window.ORT_STATE.getTrip(tripId);
          
          if (savedTrip && savedTrip.steps && savedTrip.steps.length > 0) {
            console.log('[INIT] ✅ Modifications trouvées, application...');
            
            // Appliquer les modifications
            window.state.steps = savedTrip.steps;
            if (savedTrip.title) window.state.title = savedTrip.title;
            if (savedTrip.country) window.state.cc = savedTrip.country;
            if (savedTrip.nights) {
              window.state.targetNights = savedTrip.nights;
              window.state.initialNights = savedTrip.initialNights || savedTrip.nights;
            }
            
            // === RESTAURER LES RÉSERVATIONS ===
            // Ancien format: savedTrip.bookings
            if (savedTrip.bookings && typeof globalBookingManager !== 'undefined' && globalBookingManager) {
              window.state.bookings = savedTrip.bookings;
              
              // Charger dans le gestionnaire de réservations
              Object.entries(savedTrip.bookings).forEach(([stepIdx, bookings]) => {
                if (Array.isArray(bookings)) {
                  bookings.forEach(booking => {
                    globalBookingManager.addBooking(parseInt(stepIdx), booking);
                  });
                }
              });
              
              console.log('[INIT] ✅ Réservations restaurées (ancien format):', Object.keys(savedTrip.bookings).length, 'étapes');
            }
            
            // Nouveau format: steps[].bookings (ORT_TRIP_DATA)
            if (savedTrip.steps && typeof globalBookingManager !== 'undefined' && globalBookingManager) {
              savedTrip.steps.forEach((step, stepIdx) => {
                if (step.bookings && Array.isArray(step.bookings) && step.bookings.length > 0) {
                  step.bookings.forEach(booking => {
                    globalBookingManager.addBooking(stepIdx, booking);
                  });
                  console.log('[INIT] ✅ Réservations étape', stepIdx, ':', step.bookings.length);
                }
              });
            }
            
            // Réservations voyage (travelBookings: vol, voiture, etc.)
            if (savedTrip.travelBookings && Array.isArray(savedTrip.travelBookings) && savedTrip.travelBookings.length > 0) {
              window.state.travelBookings = savedTrip.travelBookings;
              console.log('[INIT] ✅ Réservations voyage restaurées:', savedTrip.travelBookings.length);
            }
            
            // 🔗 RESTAURER LES GROUPES D'ÉTAPES (V7)
            if (savedTrip._stepGroups && Object.keys(savedTrip._stepGroups).length > 0) {
              window.state._stepGroups = savedTrip._stepGroups;
              console.log('[INIT] ✅ Groupes restaurés:', Object.keys(window.state._stepGroups).length);
              
              // Réappliquer les groupes aux étapes
              if (typeof loadGroups === 'function') {
                loadGroups();
                console.log('[INIT] loadGroups() appelé pour réappliquer les groupes');
              }
            } else {
              console.log('[INIT] ℹ️ Pas de groupes sauvegardés');
            }
            
            // Rafraîchir l'affichage
            if (typeof window.renderRows === 'function') window.renderRows();
            if (typeof window.renderMap === 'function') window.renderMap();
            if (typeof setTitleTranslated === 'function') setTitleTranslated(window.state.title);
            
            console.log('[INIT] ✅ Modifications appliquées');
          } else {
            console.log('[INIT] ℹ️ Pas de modifications sauvegardées pour ce voyage');
          }
        } catch (error) {
          console.error('[INIT] ❌ Erreur chargement modifications:', error);
        }
      } else {
        console.log('[INIT] ⚠️ TripId invalide, chargement itinéraire de base');
      }
      
      // Initialiser l'adaptateur
      window.ORT_DETAIL_ADAPTER.init(tripId, window.state);
      
      // Sauvegarder le tripId pour les retours (like ort-step-common.js)
      localStorage.setItem('ORT_CURRENT_TRIP_ID', tripId);
      
      // Charger l'index des lieux pour "Autres lieux" (sans await car fonction pas encore définie)
      if (typeof ensurePlacesIndex === 'function') {
        ensurePlacesIndex().catch(err => {
          console.warn('[INIT] Impossible de charger PLACES_INDEX:', err);
        });
      } else {
        // Réessayer après 500ms
        setTimeout(() => {
          if (typeof ensurePlacesIndex === 'function') {
            ensurePlacesIndex().catch(() => {});
          }
        }, 500);
      }
      
      console.log('[INIT] ✅ State Manager initialisé pour trip:', tripId);
      

    }
  }, 100);
  
  // Timeout de sécurité
  setTimeout(() => {
    clearInterval(waitForState);
    console.warn('[INIT] ⚠️ Timeout atteint');
  }, 5000);
})();
        </script>
<!-- [PATCH-REORG-FULLSCREEN] END -->


  <div id="reorgInfoModal" role="dialog" aria-modal="true" aria-labelledby="reorgInfoTitle">
  <div class="reorg-info-box">

    <h2 id="reorgInfoTitle">⇄ <span data-i18n="reorganize">Réorganiser l'itinéraire</span></h2>
    <p data-i18n="reorg.info.line1">
      <strong>1er clic simple</strong> sur une étape : démarrage de l'itinéraire
    </p>
    <p data-i18n="reorg.info.line2">
      <strong>2ème clic simple</strong> : seconde étape de votre itinéraire
    </p>
    <p data-i18n="reorg.info.line3">
      <strong>Double-clic</strong> : suppression de l'étape
    </p>
    <p data-i18n="reorg.info.line4">
      <strong>Nouveau double-clic</strong> : réintégration de l'étape
    </p>
    <p data-i18n="reorg.info.line5" style="margin-top:16px;font-style:italic;color:#64748b;">
      ⚠️ Validation nécessaire en fin de réorganisation pour sauvegarder vos changements.
    </p>
    <button class="btn-close-info" data-i18n="understood">J'ai compris</button>
  </div>
</div>

<!-- ========================================= -->
<!-- GROUPES V7 FINAL - PARTIE 1/2 -->
<!-- Nom défaut + Sticky + I18N + Coloration -->
<!-- Remplacer tout le code V6 par V7 (parties 1 et 2) -->
<!-- ========================================= -->

<!-- IMPORTANT : Télécharger aussi la partie 2 ! -->

<style>
/* Couleurs des groupes */
}

#groupModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.15);
  display: none;
  z-index: 16000;
}
#groupModal.show { display: block; }

/* Bouton hôtel Stay22 */
.btn-hotel-choose {
  transition: all 0.2s;
}
.btn-hotel-choose:hover {
  background: #0d5bba !important;
  transform: scale(1.02);
}

.group-modal {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #fff;
  border-radius: 14px;
  padding: 24px;
  width: 90%;
  max-width: 500px;
  max-height: 85vh;
  overflow-y: auto;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  cursor: move;
}
.group-modal h3 {
  margin: 0 0 16px 0;
  color: #113f7a;
  font-size: 1.3rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: move;
  user-select: none;
}
.group-modal-close {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  background: #f1f5f9;
  border: none;
  cursor: pointer;
  font-size: 18px;
  color: #64748b;
}
.group-modal-close:hover { background: #e2e8f0; }

.group-modal label {
  display: block;
  font-weight: 700;
  color: #113f7a;
  margin-bottom: 8px;
}
.group-modal input[type="text"] {
  width: 100%;
  padding: 10px 12px;
  border: 2px solid #e2e8f0;
  border-radius: 8px;
  font-size: 1rem;
  margin-bottom: 16px;
}
.group-modal input[type="text"]:focus {
  outline: none;
  border-color: #3b82f6;
}

.group-info {
  background: #f8fafc;
  padding: 12px;
  border-radius: 8px;
  margin-bottom: 16px;
  color: #64748b;
  font-size: 0.9rem;
  line-height: 1.4;
}
.group-info.tip {
  background: #dbeafe;
  color: #1e40af;
  border: 1px solid #93c5fd;
}

.group-steps-section {
  margin-bottom: 16px;
}
.group-steps-list {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
}
.group-step-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  background: #f8fafc;
  border-radius: 6px;
  margin-bottom: 6px;
}
.group-step-item:last-child {
  margin-bottom: 0;
}
.group-step-name {
  font-weight: 600;
  color: #0f172a;
  flex: 1;
}
.group-step-meta {
  color: #64748b;
  font-size: 0.85rem;
  margin-left: 8px;
}
.group-step-remove {
  background: #fee2e2;
  border: 1px solid #fca5a5;
  color: #dc2626;
  border-radius: 4px;
  padding: 2px 8px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 8px;
}
.group-step-remove:hover {
  background: #fecaca;
}

.group-add-list {
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 8px;
}
.group-add-item {
  display: flex;
  align-items: center;
  padding: 6px 8px;
  border-radius: 6px;
  margin-bottom: 4px;
  cursor: pointer;
}
.group-add-item:hover {
  background: #f1f5f9;
}
.group-add-item.in-other-group {
  opacity: 0.6;
  border-left: 4px solid #94a3b8;
}
.group-add-item.in-other-group-1 { border-left-color: #3b82f6; }
.group-add-item.in-other-group-2 { border-left-color: #ec4899; }
.group-add-item.in-other-group-3 { border-left-color: #22c55e; }
.group-add-item.in-other-group-4 { border-left-color: #f59e0b; }
.group-add-item.in-other-group-5 { border-left-color: #a855f7; }

.group-add-item input[type="checkbox"] {
  width: 18px;
  height: 18px;
  margin-right: 10px;
  cursor: pointer;
}
.group-add-item label {
  cursor: pointer;
  flex: 1;
  margin: 0;
  font-size: 0.95rem;
}

.group-modal-footer {
  margin-top: 20px;
  padding-top: 16px;
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  border-top: 1px solid #e5e7eb;
}
.group-modal-footer button {
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 700;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
}
.btn-cancel {
  background: #f1f5f9;
  color: #475569;
}
.btn-cancel:hover { background: #e2e8f0; }
.btn-delete {
  background: #fee2e2;
  color: #dc2626;
  margin-right: auto;
}
.btn-delete:hover { background: #fecaca; }
.btn-save {
  background: #3b82f6;
  color: #fff;
}
.btn-save:hover { background: #2563eb; }

body.group-map-select #map {
  cursor: crosshair !important;
}
body.group-map-select .leaflet-container {
  cursor: crosshair !important;
}


</style>

<style>
/* Hover sur nom de ville */
.step-row:has(.step-name-link:hover) {
  background: #f8fafc !important;
  transition: background 0.2s;
}

.step-name-link {
  position: relative;
  display: inline-block;
}

.step-name-link:hover {
  color: #2563eb !important;
  text-decoration: underline !important;
}

/* Tooltip */
.step-tooltip {
  position: fixed;
  background: #1f2937;
  color: #fff;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 13px;
  font-weight: 500;
  white-space: normal;        /* ← autorise le retour à la ligne */
  max-width: 420px;           /* ← évite d’être trop large */
  z-index: 10000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

/* Ligne de titre (nom complet) */
.step-tooltip .tt-fullname{
  font-weight: 800;
  margin-bottom: 4px;
  line-height: 1.25;
}


.step-tooltip.show {
  opacity: 1;
}

.step-tooltip::before {
  content: '';
  position: absolute;
  left: -6px;
  top: 50%;
  transform: translateY(-50%);
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 6px 6px 6px 0;
  border-color: transparent #1f2937 transparent transparent;
}
</style>


<!-- MODALE GROUPES SUPPRIMÉE -->

<!-- TÉLÉCHARGER AUSSI LA PARTIE 2 AVEC LE JAVASCRIPT ! -->



<script>
(function initGroups() {

console.log('🔍 [STATE-CHECK] window.state exists:', !!window.state);
console.log('🔍 [STATE-CHECK] window.state.steps:', window.state?.steps?.length);
console.log('🔍 [STATE-CHECK] window.state.title:', window.state?.title);
console.log('[GROUPS V7] Attente de state...');
  
  let attempts = 0;
  const checkState = setInterval(() => {
    attempts++;
    
    const stateExists = typeof window.state !== 'undefined';
    const stepsExists = stateExists && window.state.steps;
    const stepsIsArray = stepsExists && Array.isArray(window.state.steps);
    const stepsHasLength = stepsIsArray && window.state.steps.length > 0;
    
    if (stateExists && stepsIsArray && stepsHasLength) {
      clearInterval(checkState);
      console.log('[GROUPS V7] ⚠️ startGroupSystem supprimé');
      // startGroupSystem() supprimé
 } else if (attempts === 50) {
  console.log('[GROUPS V7] Attente state (50 tentatives)...');
    }
  }, 100);
  
  setTimeout(() => {
    clearInterval(checkState);
    if (typeof window.state !== 'undefined' && window.state.steps?.length > 0) {
      console.log('[GROUPS V7] ⚠️ Timeout mais state OK');
      // startGroupSystem() supprimé
    }
  }, 30000);
})();


// === FALLBACK: Initialisation édition titre ===
setTimeout(function(){
  const editBtn = document.getElementById('rtTitleEdit');
  const titleEl = document.getElementById('rtTitle');
  const wrap = document.getElementById('rtTitleWrap');
  
  if(!editBtn || !titleEl || !wrap) {
    console.log('[TITLE-EDIT-FALLBACK] Éléments non trouvés');
    return;
  }
  
  // Vérifier si déjà initialisé
  if(editBtn._titleEditInit) {
    console.log('[TITLE-EDIT-FALLBACK] Déjà initialisé');
    return;
  }
  editBtn._titleEditInit = true;
  
  let isEditing = false;
  
  function startEdit(){
    if(isEditing) return;
    
    const user = (typeof currentUser === 'function') ? currentUser() : null;
    const isAdmin = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    
    if(!user && !isAdmin){
      if(typeof toast === 'function') toast('Connectez-vous pour modifier le titre');
      return;
    }
    
    isEditing = true;
    const currentTitle = (window.state && window.state.title) || titleEl.textContent || '';
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'title-input';
    input.value = currentTitle;
    input.placeholder = 'Titre du voyage';
    
    titleEl.style.display = 'none';
    editBtn.style.display = 'none';
    wrap.insertBefore(input, titleEl);
    input.focus();
    input.select();
    
    const btnWrap = document.createElement('div');
    btnWrap.style.cssText = 'display:flex;gap:4px';
    btnWrap.innerHTML = `
      <button id="titleSaveBtn" style="background:#22c55e;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:14px">✓</button>
      <button id="titleCancelBtn" style="background:#ef4444;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:14px">✕</button>
    `;
    wrap.appendChild(btnWrap);
    
    if(isAdmin){
      const adminBtn = document.createElement('button');
      adminBtn.id = 'titleSaveSourceBtn';
      adminBtn.style.cssText = 'background:#f59e0b;color:#fff;border:none;padding:4px 10px;border-radius:6px;cursor:pointer;font-size:12px;margin-left:8px';
      adminBtn.textContent = '💾 Source';
      adminBtn.title = 'Sauvegarder dans le fichier source (admin)';
      btnWrap.appendChild(adminBtn);
      
      adminBtn.onclick = async () => {
        const newTitle = input.value.trim() || 'Mon voyage';
        if(window.state) window.state.title = newTitle;
        titleEl.textContent = newTitle;
        endEdit();
        
        // Utiliser le bouton "Écrire source" existant pour sauvegarder
        const btnSaveSource = document.getElementById('btnSaveSource');
        if(btnSaveSource && btnSaveSource.style.display !== 'none'){
          btnSaveSource.click();
        } else {
          if(typeof toast === 'function') toast('⚠️ Bouton "Écrire source" non disponible');
        }
      };
    }
    
    function saveTitle(){
      const newTitle = input.value.trim() || 'Mon voyage';
      if(window.state) window.state.title = newTitle;
      titleEl.textContent = newTitle;
      endEdit();
      if(typeof toast === 'function') toast('✅ Titre modifié');
      if(typeof scheduleAutosave === 'function') scheduleAutosave();
    }
    
    function cancelEdit(){ endEdit(); }
    
    function endEdit(){
      isEditing = false;
      input.remove();
      btnWrap.remove();
      titleEl.style.display = '';
      editBtn.style.display = '';
    }
    
    document.getElementById('titleSaveBtn').onclick = saveTitle;
    document.getElementById('titleCancelBtn').onclick = cancelEdit;
    
    input.addEventListener('keydown', (e) => {
      if(e.key === 'Enter') saveTitle();
      if(e.key === 'Escape') cancelEdit();
    });
    
    input.addEventListener('blur', (e) => {
      setTimeout(() => {
        if(isEditing && !wrap.contains(document.activeElement)) cancelEdit();
      }, 150);
    });
  }
  
  editBtn.onclick = startEdit;
  titleEl.style.cursor = 'pointer';
  titleEl.onclick = startEdit;
  console.log('[TITLE-EDIT-FALLBACK] ✅ Handlers attachés');
}, 1000);
</script>
<div id="stepTooltip" class="step-tooltip"></div>

<!-- === MODALE GETYOURGUIDE === -->
<style>
#gygModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#gygModal.show { display: flex; }
.gyg-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 900px;
  width: 95%;
  max-height: 85vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.gyg-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #ff5533 0%, #ff7744 100%);
  color: #fff;
}
.gyg-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.gyg-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.gyg-modal-close:hover { background: rgba(255,255,255,0.3); }
.gyg-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 300px;
}
.gyg-step-info {
  text-align: center;
  padding: 12px;
  background: #f8fafc;
  border-radius: 10px;
  margin-bottom: 16px;
}
.gyg-step-info strong { color: #113f7a; font-size: 1.1rem; }
</style>

<div id="gygModal">
  <div class="gyg-modal-content">
    <div class="gyg-modal-header" style="background:linear-gradient(135deg,#113f7a 0%,#1a5298 100%);">
      <h3>🎫 Activités & Expériences</h3>
      <button class="gyg-modal-close" onclick="closeGygModal()">✕</button>
    </div>
    <div class="gyg-modal-body">
      <div class="gyg-step-info">
        <span id="gygStepName"></span>
      </div>
      <div id="gygWidgetContainer"></div>
      <div id="gygMoreLink" style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid #e2e8f0;"></div>
    </div>
  </div>
</div>

<script>
// === GETYOURGUIDE WIDGET CONTROLLER ===
function getGygLocale() {
  const lang = (document.documentElement.lang || localStorage.getItem('lang') || 'fr').slice(0,2);
  return { fr:'fr-FR', en:'en-US', es:'es-ES', it:'it-IT', pt:'pt-PT', ar:'en-US' }[lang] || 'en-US';
}

function getGygDomain() {
  const lang = (localStorage.getItem('lang') || 'fr').slice(0,2);
  return { fr:'fr', en:'com', es:'es', it:'it', pt:'pt', ar:'com' }[lang] || 'com';
}

function openGygModal(step, idx) {
  const modal = document.getElementById('gygModal');
  const container = document.getElementById('gygWidgetContainer');
  const stepNameEl = document.getElementById('gygStepName');
  const moreLinkEl = document.getElementById('gygMoreLink');
  if (!modal || !container) return;
  
  const placeName = step?.name || 'cette destination';
  const locale = getGygLocale();
  const lang = locale.split('-')[0];
  const gygDomain = getGygDomain();
  
  // Textes I18N
  const i18n = {
    activitiesNear: { fr:'Activités à proximité de', en:'Activities near', es:'Actividades cerca de', it:'Attività vicino a', pt:'Atividades perto de' },
    loading: { fr:'Chargement des activités...', en:'Loading activities...', es:'Cargando actividades...', it:'Caricamento attività...', pt:'Carregando atividades...' },
    seeMore: { fr:'Voir toutes les activités à', en:'See all activities in', es:'Ver todas las actividades en', it:'Vedi tutte le attività a', pt:'Ver todas as atividades em' }
  };
  const t = (k) => i18n[k]?.[lang] || i18n[k]?.fr || k;
  
  // Récupérer la date de l'étape (format YYYY-MM-DD) pour affichage
  const stepDate = (typeof getStay22CheckinDate === 'function') ? getStay22CheckinDate(idx) : null;
  
  if (stepNameEl) {
    const dateDisplay = stepDate ? ` <span style="color:#64748b;font-size:0.9em;">(${new Date(stepDate).toLocaleDateString(locale)})</span>` : '';
    stepNameEl.innerHTML = `${t('activitiesNear')} <strong>${placeName}</strong>${dateDisplay}`;
  }
  
  // Lien "Voir plus" vers GetYourGuide (sans date - non supporté par leur URL publique)
  const moreUrl = `https://www.getyourguide.${gygDomain}/s/?q=${encodeURIComponent(placeName)}&partner_id=YQ9RFXj5`;
  if (moreLinkEl) {
    moreLinkEl.innerHTML = `
      <a href="${moreUrl}" target="_blank" rel="noopener" 
         style="display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:#113f7a;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;transition:background 0.2s;"
         onmouseover="this.style.background='#0d2f5c'" onmouseout="this.style.background='#113f7a'">
        🔍 ${t('seeMore')} ${placeName}
      </a>
    `;
  }
  
  // URL du widget avec 6 items
  const widgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&place=${encodeURIComponent(placeName)}&items=6&locale=${locale}&powered_by=true&campaign_id=108&promo_id=4039`;
  
  // Afficher loader puis charger le widget
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${t('loading')}</div>`;
  
  // Créer et injecter le script
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  console.log('[GYG] Modal ouverte pour:', placeName, '| date:', stepDate, '| locale:', locale);
}

function closeGygModal() {
  const modal = document.getElementById('gygModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    // Vider le container
    const container = document.getElementById('gygWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeGygModal(); });
document.getElementById('gygModal')?.addEventListener('click', function(e) { if (e.target === this) closeGygModal(); });
console.log('[GYG] ✅ GetYourGuide widget ready (place= dynamic)');
</script>

<!-- === TIQETS - LIEN DIRECT (widget bloqué par WAF) === -->
<script>
// === TIQETS - LIEN DIRECT AVEC VILLE ET DATE ===
function openTiqetsModal(step, idx) {
  const placeName = step?.name || '';
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  
  // Récupérer la date de l'étape (format YYYY-MM-DD)
  let dateParam = '';
  if (typeof getStay22CheckinDate === 'function') {
    const stepDate = getStay22CheckinDate(idx);
    if (stepDate) {
      dateParam = `&date=${stepDate}`;
    }
  }
  
  // Construire l'URL affilié avec ville et date
  const tiqetsUrl = `https://tiqets.tpo.li/L1uxd085?q=${encodeURIComponent(placeName)}${dateParam}&lang=${lang}`;
  
  console.log('[TIQETS] Redirection vers:', tiqetsUrl);
  
  // Ouvrir directement dans un nouvel onglet
  window.open(tiqetsUrl, '_blank', 'noopener');
}

function closeTiqetsModal() {}
console.log('[TIQETS] ✅ Tiqets ready (direct link mode)');
</script>

<!-- === TICKETMASTER WIDGET (Spectacles) === -->
<style>
#ticketmasterModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#ticketmasterModal.show { display: flex; }
.tm-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 900px;
  width: 95%;
  max-height: 85vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.tm-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #026cdf 0%, #0653b6 100%);
  color: #fff;
}
.tm-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.tm-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.tm-modal-close:hover { background: rgba(255,255,255,0.3); }
.tm-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 300px;
}
.tm-step-info {
  text-align: center;
  padding: 12px;
  background: #f8fafc;
  border-radius: 10px;
  margin-bottom: 16px;
}
.tm-step-info strong { color: #026cdf; font-size: 1.1rem; }
</style>

<div id="ticketmasterModal">
  <div class="tm-modal-content">
    <div class="tm-modal-header">
      <h3>🎭 Spectacles</h3>
      <button class="tm-modal-close" onclick="closeTicketmasterModal()">✕</button>
    </div>
    <div class="tm-modal-body">
      <div class="tm-step-info">
        <span id="tmStepName"></span>
      </div>
      <div id="tmWidgetContainer"></div>
      <div id="tmMoreLink" style="text-align:center;margin-top:20px;padding-top:16px;border-top:1px solid #e2e8f0;"></div>
    </div>
  </div>
</div>

<script>
// === TICKETMASTER WIDGET CONTROLLER ===
function getTicketmasterLocale() {
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  return { fr:'fr-FR', en:'en-US', es:'es-ES', it:'it-IT', pt:'pt-PT', ar:'en-US' }[lang] || 'en-US';
}

// Mapping pays pour Ticketmaster
function getCountryFromCC() {
  const cc = (window.CC || window.state?.cc || window.state?.country || '').toUpperCase();
  const supported = ['US','CA','MX','AU','NZ','GB','IE','DE','FR','ES','IT','NL','BE','AT','CH','PL','SE','NO','DK','FI'];
  return supported.includes(cc) ? cc : 'FR';
}

function openTicketmasterModal(step, idx) {
  const modal = document.getElementById('ticketmasterModal');
  const container = document.getElementById('tmWidgetContainer');
  const stepNameEl = document.getElementById('tmStepName');
  const moreLinkEl = document.getElementById('tmMoreLink');
  if (!modal || !container) return;
  
  const placeName = step?.name || 'cette destination';
  const locale = getTicketmasterLocale();
  const lang = locale.split('-')[0];
  const country = getCountryFromCC();
  
  // Textes I18N
  const i18n = {
    showsNear: { fr:'Spectacles à', en:'Shows in', es:'Espectáculos en', it:'Spettacoli a', pt:'Espetáculos em' },
    loading: { fr:'Chargement des spectacles...', en:'Loading shows...', es:'Cargando espectáculos...', it:'Caricamento spettacoli...', pt:'Carregando espetáculos...' },
    seeMore: { fr:'Voir tous les spectacles', en:'See all shows', es:'Ver todos los espectáculos', it:'Vedi tutti gli spettacoli', pt:'Ver todos os espetáculos' },
    errorLoad: { fr:'Impossible de charger. Cliquez ci-dessous.', en:'Unable to load. Click below.', es:'No se puede cargar. Haga clic abajo.', it:'Impossibile caricare. Clicca sotto.', pt:'Não foi possível carregar. Clique abaixo.' }
  };
  const t = (k) => i18n[k]?.[lang] || i18n[k]?.fr || k;
  
  // Récupérer la date de l'étape (format YYYY-MM-DD) - OBLIGATOIRE
  let startDate = '';
  if (typeof getStay22CheckinDate === 'function') {
    startDate = getStay22CheckinDate(idx) || '';
  }
  // Fallback: aujourd'hui si pas de date
  if (!startDate) {
    startDate = new Date().toISOString().split('T')[0];
  }
  
  if (stepNameEl) {
    const dateDisplay = ` <span style="color:#64748b;font-size:0.9em;">(${new Date(startDate).toLocaleDateString(locale)})</span>`;
    stepNameEl.innerHTML = `${t('showsNear')} <strong>${placeName}</strong>${dateDisplay}`;
  }
  
  // Lien "Voir plus" vers Ticketmaster
  const moreUrl = `https://www.ticketmaster.com/search?q=${encodeURIComponent(placeName)}&startDate=${startDate}`;
  if (moreLinkEl) {
    moreLinkEl.innerHTML = `
      <a href="${moreUrl}" target="_blank" rel="noopener" 
         style="display:inline-flex;align-items:center;gap:8px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;transition:background 0.2s;"
         onmouseover="this.style.background='#0653b6'" onmouseout="this.style.background='#026cdf'">
        🔍 ${t('seeMore')}
      </a>
    `;
  }
  
  // URL du widget Ticketmaster via Travelpayouts avec DATE DE L'ÉTAPE
  const widgetUrl = `https://trpwdg.com/content?trs=478677&start_date=${startDate}&country=${country}&sort=relevance%2Cdesc&powered_by=true&min_lines=5&promo_id=5431&shmarker=688844&campaign_id=183`;
  
  console.log('[TICKETMASTER] Widget URL:', widgetUrl);
  console.log('[TICKETMASTER] date étape:', startDate, '| country:', country);
  
  // Afficher loader
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${t('loading')}</div>`;
  
  // Créer et injecter le script
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  // Timeout fallback
  const loadTimeout = setTimeout(() => {
    if (!container.querySelector('[class*="trp"]') && !container.querySelector('a[href*="ticket"]')) {
      container.innerHTML = `
        <div style="text-align:center;padding:30px;color:#64748b;">
          <div style="font-size:2rem;margin-bottom:10px;">🎭</div>
          <p>${t('errorLoad')}</p>
          <a href="${moreUrl}" target="_blank" rel="noopener" 
             style="display:inline-block;margin-top:12px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
            🔍 ${t('seeMore')}
          </a>
        </div>
      `;
    }
  }, 5000);
  
  script.onload = () => {
    clearTimeout(loadTimeout);
    console.log('[TICKETMASTER] Script chargé OK');
  };
  
  script.onerror = () => {
    clearTimeout(loadTimeout);
    console.error('[TICKETMASTER] Erreur chargement');
    container.innerHTML = `
      <div style="text-align:center;padding:30px;color:#64748b;">
        <div style="font-size:2rem;margin-bottom:10px;">🎭</div>
        <p>${t('errorLoad')}</p>
        <a href="${moreUrl}" target="_blank" rel="noopener" 
           style="display:inline-block;margin-top:12px;padding:12px 24px;background:#026cdf;color:#fff;text-decoration:none;border-radius:8px;font-weight:600;">
          🔍 ${t('seeMore')}
        </a>
      </div>
    `;
  };
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  console.log('[TICKETMASTER] Modal ouverte | place:', placeName, '| country:', country, '| date:', startDate);
}

function closeTicketmasterModal() {
  const modal = document.getElementById('ticketmasterModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    const container = document.getElementById('tmWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeTicketmasterModal(); });
document.getElementById('ticketmasterModal')?.addEventListener('click', function(e) { if (e.target === this) closeTicketmasterModal(); });
console.log('[TICKETMASTER] ✅ Ticketmaster widget ready');
</script>

<!-- === CAR RENTAL WIDGET === -->
<style>
#carRentalModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(17,63,122,0.85);
  align-items: center;
  justify-content: center;
  padding: 20px;
}
#carRentalModal.show { display: flex; }
.car-modal-content {
  background: #fff;
  border-radius: 16px;
  max-width: 950px;
  width: 95%;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.car-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  background: linear-gradient(135deg, #0f9d58 0%, #0b7a45 100%);
  color: #fff;
}
.car-modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 700; }
.car-modal-close {
  background: rgba(255,255,255,0.2);
  border: none;
  color: #fff;
  width: 32px; height: 32px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 18px;
}
.car-modal-close:hover { background: rgba(255,255,255,0.3); }
.car-modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 20px;
  min-height: 350px;
}
/* Fix pour les inputs du widget Travelpayouts */
#carWidgetContainer input,
#carWidgetContainer select,
#carWidgetContainer button {
  opacity: 1 !important;
  visibility: visible !important;
  pointer-events: auto !important;
  color: #333 !important;
  background-color: #fff !important;
}
#carWidgetContainer input[type="text"],
#carWidgetContainer input[type="date"] {
  border: 1px solid #ccc !important;
  padding: 8px !important;
}
</style>

<div id="carRentalModal">
  <div class="car-modal-content">
    <div class="car-modal-header">
      <h3>🚗 Location de voiture</h3>
      <button class="car-modal-close" onclick="closeCarRentalModal()">✕</button>
    </div>
    <div class="car-modal-body">
      <div id="carWidgetContainer"></div>
    </div>
  </div>
</div>

<script>
// === CAR RENTAL WIDGET CONTROLLER ===
function getCarLocale() {
  const lang = (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
  return { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
}

function openCarRentalModal() {
  const modal = document.getElementById('carRentalModal');
  const container = document.getElementById('carWidgetContainer');
  if (!modal || !container) return;
  
  const locale = getCarLocale();
  
  // Textes I18N
  const i18n = {
    loading: { fr:'Chargement...', en:'Loading...', es:'Cargando...', it:'Caricamento...', pt:'Carregando...' }
  };
  const lang = locale;
  const t = (k) => i18n[k]?.[lang] || i18n[k]?.fr || k;
  
  // URL du widget voiture
  const widgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&locale=${locale}&powered_by=true&campaign_id=172&promo_id=4850`;
  
  console.log('[CAR RENTAL] Widget URL:', widgetUrl);
  
  // Afficher loader
  container.innerHTML = `<div style="text-align:center;padding:40px;color:#64748b;">${t('loading')}</div>`;
  
  // Créer et injecter le script
  const script = document.createElement('script');
  script.src = widgetUrl;
  script.async = true;
  script.charset = 'utf-8';
  
  script.onload = () => {
    console.log('[CAR RENTAL] Script chargé OK');
  };
  
  script.onerror = () => {
    console.error('[CAR RENTAL] Erreur chargement');
  };
  
  container.innerHTML = '';
  container.appendChild(script);
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  console.log('[CAR RENTAL] Modal ouverte');
}

function closeCarRentalModal() {
  const modal = document.getElementById('carRentalModal');
  if (modal) {
    modal.classList.remove('show');
    document.body.style.overflow = '';
    const container = document.getElementById('carWidgetContainer');
    if (container) container.innerHTML = '';
  }
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeCarRentalModal(); });
document.getElementById('carRentalModal')?.addEventListener('click', function(e) { if (e.target === this) closeCarRentalModal(); });
console.log('[CAR RENTAL] ✅ Car rental widget ready');
</script>

<!-- === PARTNER REDIRECT MODAL === -->
<style>
#partnerModal {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 10001;
  background: rgba(17,63,122,0.9);
  align-items: center;
  justify-content: center;
  padding: 20px;
  animation: fadeIn 0.3s ease;
}
#partnerModal.show { display: flex; }
#partnerModal.top-aligned { align-items: flex-start; padding-top: 40px; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideUp { from { transform: translateY(30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
.partner-modal-content {
  background: linear-gradient(135deg, #fff 0%, #f8fafc 100%);
  border-radius: 20px;
  max-width: 750px;
  width: 95%;
  max-height: 90vh;
  overflow: hidden;
  box-shadow: 0 25px 80px rgba(0,0,0,0.4);
  animation: slideUp 0.4s ease;
}
.partner-modal-content.with-widget {
  max-width: 900px;
}
.partner-modal-header {
  padding: 24px 24px 16px;
  text-align: center;
  background: linear-gradient(135deg, #113f7a 0%, #1a5298 100%);
  color: #fff;
  position: relative;
}
.partner-modal-header.compact {
  padding: 12px 24px;
}
.partner-modal-header.compact .partner-icon,
.partner-modal-header.compact h3 {
  display: none;
}
.partner-modal-header h3 {
  margin: 0;
  font-size: 1.4rem;
  font-weight: 700;
}
.partner-modal-header .partner-icon {
  font-size: 3rem;
  margin-bottom: 8px;
  display: block;
}
.partner-modal-body {
  padding: 24px;
  text-align: center;
  color: #334155;
  font-size: 1rem;
  line-height: 1.6;
  overflow-y: auto;
  max-height: 60vh;
}
.partner-modal-body.widget-mode {
  padding: 16px;
  min-height: 350px;
}
.partner-modal-body strong {
  color: #113f7a;
}
.partner-modal-features {
  text-align: left;
  margin-top: 16px;
  padding: 16px;
  background: #f0f7ff;
  border-radius: 12px;
  font-size: 0.95rem;
}
.partner-modal-footer {
  padding: 16px 24px 24px;
  display: flex;
  gap: 12px;
  justify-content: center;
}
.partner-btn {
  padding: 14px 28px;
  border-radius: 12px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  border: none;
}
.partner-btn-primary {
  background: linear-gradient(135deg, #0f9d58 0%, #0b7a45 100%);
  color: #fff;
  box-shadow: 0 4px 15px rgba(15,157,88,0.4);
}
.partner-btn-primary:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(15,157,88,0.5);
}
.partner-btn-secondary {
  background: #e2e8f0;
  color: #64748b;
}
.partner-btn-secondary:hover {
  background: #cbd5e1;
}
.partner-countdown {
  margin-top: 12px;
  font-size: 0.85rem;
  color: #94a3b8;
  text-align: center;
}
.partner-choice-container {
  display: flex;
  gap: 16px;
  margin-top: 16px;
}
.partner-choice-btn {
  flex: 1;
  padding: 20px 16px;
  border-radius: 14px;
  border: 2px solid #e2e8f0;
  background: #fff;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}
.partner-choice-btn:hover {
  border-color: #113f7a;
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(17,63,122,0.15);
}
.partner-choice-btn .choice-icon {
  font-size: 2.5rem;
  display: block;
  margin-bottom: 10px;
}
.partner-choice-btn .choice-title {
  font-weight: 700;
  color: #113f7a;
  font-size: 1rem;
  margin-bottom: 6px;
}
.partner-choice-btn .choice-desc {
  font-size: 0.8rem;
  color: #64748b;
  line-height: 1.4;
}
.partner-choice-btn.car { border-color: #0f9d58; background: linear-gradient(135deg, #f0fdf4 0%, #fff 100%); }
.partner-choice-btn.car:hover { border-color: #0f9d58; box-shadow: 0 8px 20px rgba(15,157,88,0.2); }
.partner-choice-btn.transfer { border-color: #3b82f6; background: linear-gradient(135deg, #eff6ff 0%, #fff 100%); }
.partner-choice-btn.transfer:hover { border-color: #3b82f6; box-shadow: 0 8px 20px rgba(59,130,246,0.2); }
</style>

<div id="partnerModal">
  <div class="partner-modal-content" id="partnerModalContent">
    <div class="partner-modal-header">
      <span class="partner-icon" id="partnerIcon">🚗</span>
      <h3 id="partnerTitle">Redirection</h3>
      <button style="position:absolute;top:16px;right:16px;background:rgba(255,255,255,0.2);border:none;color:#fff;width:32px;height:32px;border-radius:8px;cursor:pointer;font-size:18px;" onclick="closePartnerModal()">✕</button>
    </div>
    <div class="partner-modal-body" id="partnerModalBody">
      <div id="partnerText"></div>
      <div id="partnerChoices" class="partner-choice-container" style="display:none;"></div>
      <div id="partnerWidgetContainer" style="display:none;"></div>
    </div>
    <div class="partner-modal-footer" id="partnerFooter">
      <button class="partner-btn partner-btn-secondary" onclick="closePartnerModal()" id="partnerCancelBtn">Annuler</button>
      <button class="partner-btn partner-btn-primary" onclick="confirmPartnerRedirect()" id="partnerContinueBtn">Continuer</button>
    </div>
    <div class="partner-countdown" id="partnerCountdown"></div>
  </div>
</div>

<script>
// === PARTNER MODAL CONTROLLER ===
let partnerTarget = null;
let partnerCountdownTimer = null;

function getPartnerLang() {
  return (localStorage.getItem('lang') || document.documentElement.lang || 'fr').slice(0,2);
}

// I18N inline pour la modal partenaire
const PARTNER_I18N = {
  vehicleTitle: {
    fr: '🚕 Véhicules & Transferts',
    en: '🚕 Vehicles & Transfers',
    es: '🚕 Vehículos y Traslados',
    it: '🚕 Veicoli e Trasferimenti',
    pt: '🚕 Veículos e Transfers',
    ar: '🚕 المركبات والنقل'
  },
  vehicleText: {
    fr: 'Que recherchez-vous pour votre voyage ?',
    en: 'What are you looking for?',
    es: '¿Qué necesitas para tu viaje?',
    it: 'Di cosa hai bisogno per il tuo viaggio?',
    pt: 'O que você precisa para sua viagem?',
    ar: 'ماذا تحتاج لرحلتك؟'
  },
  carTitle: { fr: 'Location de voiture', en: 'Car Rental', es: 'Alquiler de coches', it: 'Noleggio auto', pt: 'Aluguel de carros', ar: 'تأجير السيارات' },
  carDesc: { fr: 'Louez un véhicule et explorez en liberté', en: 'Rent a car and explore freely', es: 'Alquila un coche y explora libremente', it: 'Noleggia un\'auto ed esplora liberamente', pt: 'Alugue um carro e explore livremente', ar: 'استأجر سيارة واستكشف بحرية' },
  transferTitle: { fr: 'Transfert aéroport', en: 'Airport Transfer', es: 'Traslado aeropuerto', it: 'Trasferimento aeroporto', pt: 'Transfer aeroporto', ar: 'النقل من المطار' },
  transferDesc: { fr: 'Chauffeur privé, prix fixe garanti', en: 'Private driver, fixed price', es: 'Conductor privado, precio fijo', it: 'Autista privato, prezzo fisso', pt: 'Motorista particular, preço fixo', ar: 'سائق خاص، سعر ثابت' },
  carRedirectTitle: { fr: '🚗 Location de voiture', en: '🚗 Car Rental', es: '🚗 Alquiler de coches', it: '🚗 Noleggio auto', pt: '🚗 Aluguel de carros', ar: '🚗 تأجير السيارات' },
  carRedirectText: {
    fr: 'Nous travaillons avec <strong>QEEQ.com</strong>, leader mondial de la location de véhicules.<br><br>🏆 <strong>Meilleurs prix garantis</strong> — Comparaison de +500 loueurs<br>🔄 <strong>Annulation gratuite</strong> — Flexibilité totale<br>🚗 <strong>+7 millions de véhicules</strong> — Du compact au SUV<br>🌍 <strong>Présent dans 170+ pays</strong>',
    en: 'We partner with <strong>QEEQ.com</strong>, the world leader in car rental.<br><br>🏆 <strong>Best prices guaranteed</strong> — Comparing 500+ suppliers<br>🔄 <strong>Free cancellation</strong> — Total flexibility<br>🚗 <strong>+7 million vehicles</strong> — From compact to SUV<br>🌍 <strong>Available in 170+ countries</strong>',
    es: 'Trabajamos con <strong>QEEQ.com</strong>, líder mundial en alquiler de vehículos.<br><br>🏆 <strong>Mejores precios garantizados</strong> — Comparación de +500 proveedores<br>🔄 <strong>Cancelación gratuita</strong> — Flexibilidad total<br>🚗 <strong>+7 millones de vehículos</strong> — Del compacto al SUV<br>🌍 <strong>Presente en 170+ países</strong>',
    it: 'Collaboriamo con <strong>QEEQ.com</strong>, leader mondiale nel noleggio veicoli.<br><br>🏆 <strong>Miglior prezzo garantito</strong> — Confronto di +500 fornitori<br>🔄 <strong>Cancellazione gratuita</strong> — Flessibilità totale<br>🚗 <strong>+7 milioni di veicoli</strong> — Dalla compatta al SUV<br>🌍 <strong>Presente in 170+ paesi</strong>',
    pt: 'Trabalhamos com <strong>QEEQ.com</strong>, líder mundial em aluguel de veículos.<br><br>🏆 <strong>Melhores preços garantidos</strong> — Comparação de +500 fornecedores<br>🔄 <strong>Cancelamento gratuito</strong> — Flexibilidade total<br>🚗 <strong>+7 milhões de veículos</strong> — Do compacto ao SUV<br>🌍 <strong>Presente em 170+ países</strong>',
    ar: 'نتعاون مع <strong>QEEQ.com</strong>، الرائد العالمي في تأجير السيارات.<br><br>🏆 <strong>أفضل الأسعار مضمونة</strong> — مقارنة +500 مورد<br>🔄 <strong>إلغاء مجاني</strong> — مرونة كاملة<br>🚗 <strong>+7 مليون مركبة</strong> — من المدمجة إلى SUV<br>🌍 <strong>متوفر في 170+ دولة</strong>'
  },
  transferRedirectTitle: { fr: '🚐 Transfert aéroport', en: '🚐 Airport Transfer', es: '🚐 Traslado aeropuerto', it: '🚐 Trasferimento aeroporto', pt: '🚐 Transfer aeroporto', ar: '🚐 النقل من المطار' },
  transferRedirectText: {
    fr: 'Nous travaillons avec <strong>GetTransfer</strong>, spécialiste des transferts privés.<br><br>🚘 <strong>Chauffeur professionnel</strong> — Accueil personnalisé à l\'arrivée<br>💰 <strong>Prix fixe garanti</strong> — Pas de surprise, pas de compteur<br>⏰ <strong>Disponible 24h/24</strong> — Même pour les vols tardifs<br>📱 <strong>Suivi en temps réel</strong> — Localisation du chauffeur',
    en: 'We partner with <strong>GetTransfer</strong>, the private transfer specialist.<br><br>🚘 <strong>Professional driver</strong> — Personalized welcome on arrival<br>💰 <strong>Fixed price guaranteed</strong> — No surprises, no meter<br>⏰ <strong>Available 24/7</strong> — Even for late flights<br>📱 <strong>Real-time tracking</strong> — Driver location',
    es: 'Trabajamos con <strong>GetTransfer</strong>, especialista en traslados privados.<br><br>🚘 <strong>Conductor profesional</strong> — Bienvenida personalizada a la llegada<br>💰 <strong>Precio fijo garantizado</strong> — Sin sorpresas, sin taxímetro<br>⏰ <strong>Disponible 24/7</strong> — Incluso para vuelos tardíos<br>📱 <strong>Seguimiento en tiempo real</strong> — Ubicación del conductor',
    it: 'Collaboriamo con <strong>GetTransfer</strong>, specialista nei trasferimenti privati.<br><br>🚘 <strong>Autista professionale</strong> — Accoglienza personalizzata all\'arrivo<br>💰 <strong>Prezzo fisso garantito</strong> — Nessuna sorpresa, nessun tassametro<br>⏰ <strong>Disponibile 24/7</strong> — Anche per voli in ritardo<br>📱 <strong>Tracciamento in tempo reale</strong> — Posizione dell\'autista',
    pt: 'Trabalhamos com <strong>GetTransfer</strong>, especialista em transfers privados.<br><br>🚘 <strong>Motorista profissional</strong> — Recepção personalizada na chegada<br>💰 <strong>Preço fixo garantido</strong> — Sem surpresas, sem taxímetro<br>⏰ <strong>Disponível 24h</strong> — Mesmo para voos atrasados<br>📱 <strong>Rastreamento em tempo real</strong> — Localização do motorista',
    ar: 'نتعاون مع <strong>GetTransfer</strong>، المتخصص في النقل الخاص.<br><br>🚘 <strong>سائق محترف</strong> — استقبال شخصي عند الوصول<br>💰 <strong>سعر ثابت مضمون</strong> — بدون مفاجآت، بدون عداد<br>⏰ <strong>متاح 24/7</strong> — حتى للرحلات المتأخرة<br>📱 <strong>تتبع في الوقت الحقيقي</strong> — موقع السائق'
  },
  transferWidgetTitle: { fr: '🚐 Réservez votre transfert', en: '🚐 Book your transfer', es: '🚐 Reserva tu traslado', it: '🚐 Prenota il tuo trasferimento', pt: '🚐 Reserve seu transfer', ar: '🚐 احجز نقلك' },
  flightWidgetTitle: { fr: '✈️ Trouvez votre vol', en: '✈️ Find your flight', es: '✈️ Encuentra tu vuelo', it: '✈️ Trova il tuo volo', pt: '✈️ Encontre seu voo', ar: '✈️ ابحث عن رحلتك' },
  insuranceTitle: { fr: '🛡 Assurance voyage', en: '🛡 Travel Insurance', es: '🛡 Seguro de viaje', it: '🛡 Assicurazione viaggio', pt: '🛡 Seguro viagem', ar: '🛡 تأمين السفر' },
  insuranceText: {
    fr: 'Nous vous dirigeons vers <strong>Ekta Traveling</strong>.<br><br>✅ Couverture médicale mondiale<br>✅ Annulation & bagages<br>✅ Assistance 24h/24',
    en: 'Redirecting to <strong>Ekta Traveling</strong>.<br><br>✅ Worldwide medical coverage<br>✅ Cancellation & baggage<br>✅ 24/7 assistance',
    es: 'Te redirigimos a <strong>Ekta Traveling</strong>.<br><br>✅ Cobertura médica mundial<br>✅ Cancelación y equipaje<br>✅ Asistencia 24/7',
    it: 'Ti reindirizziamo a <strong>Ekta Traveling</strong>.<br><br>✅ Copertura medica mondiale<br>✅ Cancellazione e bagagli<br>✅ Assistenza 24/7',
    pt: 'Redirecionando para <strong>Ekta Traveling</strong>.<br><br>✅ Cobertura médica mundial<br>✅ Cancelamento e bagagem<br>✅ Assistência 24h',
    ar: 'نوجهك إلى <strong>Ekta Traveling</strong>.<br><br>✅ تغطية طبية عالمية<br>✅ الإلغاء والأمتعة<br>✅ مساعدة 24/7'
  },
  cancel: { fr: 'Annuler', en: 'Cancel', es: 'Cancelar', it: 'Annulla', pt: 'Cancelar', ar: 'إلغاء' },
  continue: { fr: 'Continuer', en: 'Continue', es: 'Continuar', it: 'Continua', pt: 'Continuar', ar: 'متابعة' },
  redirecting: { fr: 'Redirection dans', en: 'Redirecting in', es: 'Redirigiendo en', it: 'Reindirizzamento tra', pt: 'Redirecionando em', ar: 'إعادة التوجيه في' },
  loading: { fr: 'Chargement...', en: 'Loading...', es: 'Cargando...', it: 'Caricamento...', pt: 'Carregando...', ar: 'جار التحميل...' },
  flightTabSearch: { fr: '🔍 Rechercher un vol', en: '🔍 Search flights', es: '🔍 Buscar vuelos', it: '🔍 Cerca voli', pt: '🔍 Pesquisar voos', ar: '🔍 البحث عن رحلات' },
  flightTabCompensation: { fr: '💰 Compensation retard', en: '💰 Delay compensation', es: '💰 Compensación retraso', it: '💰 Rimborso ritardo', pt: '💰 Compensação atraso', ar: '💰 تعويض التأخير' }
};

function pt(key) {
  const lang = getPartnerLang();
  return PARTNER_I18N[key]?.[lang] || PARTNER_I18N[key]?.fr || key;
}

function showPartnerModal(type) {
  const modal = document.getElementById('partnerModal');
  const modalContent = document.getElementById('partnerModalContent');
  const modalBody = document.getElementById('partnerModalBody');
  const icon = document.getElementById('partnerIcon');
  const title = document.getElementById('partnerTitle');
  const text = document.getElementById('partnerText');
  const choices = document.getElementById('partnerChoices');
  const widgetContainer = document.getElementById('partnerWidgetContainer');
  const footer = document.getElementById('partnerFooter');
  const cancelBtn = document.getElementById('partnerCancelBtn');
  const continueBtn = document.getElementById('partnerContinueBtn');
  const countdown = document.getElementById('partnerCountdown');
  
  if (!modal) return;
  
  // Reset
  if (partnerCountdownTimer) clearInterval(partnerCountdownTimer);
  choices.style.display = 'none';
  widgetContainer.style.display = 'none';
  widgetContainer.innerHTML = '';
  footer.style.display = 'flex';
  countdown.textContent = '';
  modalContent.classList.remove('with-widget');
  modalBody.classList.remove('widget-mode');
  text.style.display = 'block';
  
  const lang = getPartnerLang();
  
  // Mode VEHICLE = choix entre location et transferts
  if (type === 'vehicle') {
    partnerTarget = null;
    icon.textContent = '🚕';
    title.textContent = pt('vehicleTitle');
    text.innerHTML = pt('vehicleText');
    
    // Afficher les deux choix
    choices.innerHTML = `
      <button class="partner-choice-btn car" onclick="selectPartnerChoice('car')">
        <span class="choice-icon">🚗</span>
        <div class="choice-title">${pt('carTitle')}</div>
        <div class="choice-desc">${pt('carDesc')}</div>
      </button>
      <button class="partner-choice-btn transfer" onclick="selectPartnerChoice('transfer')">
        <span class="choice-icon">🚐</span>
        <div class="choice-title">${pt('transferTitle')}</div>
        <div class="choice-desc">${pt('transferDesc')}</div>
      </button>
    `;
    choices.style.display = 'flex';
    footer.style.display = 'none';
    
  } else if (type === 'car') {
    // Modale marketing pour location de voiture - lien direct QEEQ
    partnerTarget = 'https://qeeq.tpo.li/rMRoXmko';
    icon.textContent = '🚗';
    title.textContent = pt('carRedirectTitle');
    text.innerHTML = pt('carRedirectText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
    
  } else if (type === 'transfer') {
    // Modale marketing pour transfert aéroport - lien direct GetTransfer
    partnerTarget = 'https://gettransfer.tpo.li/NQ4bVvpZ';
    icon.textContent = '🚐';
    title.textContent = pt('transferRedirectTitle');
    text.innerHTML = pt('transferRedirectText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
    
  } else if (type === 'flight') {
    // Modal vols avec deux onglets : Recherche + Compensation retard
    partnerTarget = null;
    text.style.display = 'none';
    footer.style.display = 'none';
    
    // Masquer le header et remonter la modal
    const header = document.querySelector('.partner-modal-header');
    if (header) header.classList.add('compact');
    modal.classList.add('top-aligned');
    
    // Activer le mode widget
    modalContent.classList.add('with-widget');
    modalBody.classList.add('widget-mode');
    widgetContainer.style.display = 'block';
    
    const locale = { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
    const currency = { fr:'EUR', en:'USD', es:'EUR', it:'EUR', pt:'EUR', ar:'USD' }[lang] || 'EUR';
    
    // URLs des widgets - INVERSÉS : le nouveau widget (4132) est la recherche, l'ancien (2110) est pour compensation
    const searchWidgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&locale=${locale}&curr=${currency}&powered_by=true&border_radius=0&plain=true&color_button=%232681ff&color_button_text=%23ffffff&color_border=%232681ff&promo_id=4132&campaign_id=121`;
    const compensationWidgetUrl = `https://trpwdg.com/content?trs=478677&shmarker=688844&locale=${locale}&width=100&powered_by=true&campaign_id=86&promo_id=2110`;
    
    // Structure avec onglets
    widgetContainer.innerHTML = `
      <style>
        .flight-tabs { display:flex; gap:0; margin-bottom:16px; }
        .flight-tab { flex:1; padding:12px 16px; border:2px solid #2681ff; background:#fff; color:#2681ff; font-weight:600; font-size:0.9rem; cursor:pointer; transition:all 0.2s; }
        .flight-tab:first-child { border-radius:8px 0 0 8px; border-right:none; }
        .flight-tab:last-child { border-radius:0 8px 8px 0; }
        .flight-tab:hover { background:#eff6ff; }
        .flight-tab.active { background:#2681ff; color:#fff; }
        .flight-tab-content { min-height:200px; }
      </style>
      <div class="flight-tabs">
        <button class="flight-tab active" data-tab="search">${pt('flightTabSearch')}</button>
        <button class="flight-tab" data-tab="compensation">${pt('flightTabCompensation')}</button>
      </div>
      <div class="flight-tab-content" id="flightTabSearch"></div>
      <div class="flight-tab-content" id="flightTabCompensation" style="display:none;"></div>
    `;
    
    // Fonction pour charger un widget dans un conteneur
    function loadWidgetInContainer(containerId, widgetUrl) {
      const container = document.getElementById(containerId);
      if (!container || container.dataset.loaded) return;
      container.innerHTML = `<div style="text-align:center;padding:30px;color:#64748b;">${pt('loading')}</div>`;
      const script = document.createElement('script');
      script.src = widgetUrl;
      script.async = true;
      script.charset = 'utf-8';
      script.onload = () => {
        container.dataset.loaded = '1';
        setTimeout(() => {
          const loader = container.querySelector('div[style*="text-align:center"]');
          if (loader && container.children.length > 1) loader.remove();
        }, 500);
        console.log('[PARTNER] Widget chargé dans', containerId);
      };
      script.onerror = () => {
        container.innerHTML = `<div style="text-align:center;padding:40px;color:#ef4444;">Erreur de chargement</div>`;
      };
      container.appendChild(script);
    }
    
    // Charger le widget recherche immédiatement (onglet actif)
    loadWidgetInContainer('flightTabSearch', searchWidgetUrl);
    
    // Handlers onglets
    widgetContainer.querySelectorAll('.flight-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        widgetContainer.querySelectorAll('.flight-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        const isSearch = tab.dataset.tab === 'search';
        document.getElementById('flightTabSearch').style.display = isSearch ? 'block' : 'none';
        document.getElementById('flightTabCompensation').style.display = isSearch ? 'none' : 'block';
        
        // Charger le widget compensation au premier clic (lazy load)
        if (!isSearch) {
          loadWidgetInContainer('flightTabCompensation', compensationWidgetUrl);
        }
      });
    });
    
  } else if (type === 'insurance') {
    const insLang = { fr:'fr', en:'en', es:'es', it:'it', pt:'pt', ar:'en' }[lang] || 'en';
    partnerTarget = `https://ektatraveling.com/${insLang}/?sub_id=8d611d0d167741c58fdfe9e61-688844&utm_source=travelpayouts`;
    icon.textContent = '🛡';
    title.textContent = pt('insuranceTitle');
    text.innerHTML = pt('insuranceText');
    cancelBtn.textContent = pt('cancel');
    continueBtn.textContent = pt('continue');
    startCountdown(countdown);
  }
  
  modal.classList.add('show');
  document.body.style.overflow = 'hidden';
  
  console.log('[PARTNER] Modal ouverte pour:', type);
}

function selectPartnerChoice(choice) {
  closePartnerModal();
  setTimeout(() => showPartnerModal(choice), 100);
}

function startCountdown(countdownEl) {
  let seconds = 5;
  countdownEl.textContent = `${pt('redirecting')} ${seconds}s`;
  
  partnerCountdownTimer = setInterval(() => {
    seconds--;
    if (seconds <= 0) {
      clearInterval(partnerCountdownTimer);
      confirmPartnerRedirect();
    } else {
      countdownEl.textContent = `${pt('redirecting')} ${seconds}s`;
    }
  }, 1000);
}

function closePartnerModal() {
  const modal = document.getElementById('partnerModal');
  const widgetContainer = document.getElementById('partnerWidgetContainer');
  const header = document.querySelector('.partner-modal-header');
  if (modal) {
    modal.classList.remove('show', 'top-aligned');
    document.body.style.overflow = '';
  }
  if (header) {
    header.classList.remove('compact');
  }
  if (widgetContainer) {
    widgetContainer.innerHTML = '';
  }
  if (partnerCountdownTimer) {
    clearInterval(partnerCountdownTimer);
    partnerCountdownTimer = null;
  }
  partnerTarget = null;
}

function confirmPartnerRedirect() {
  if (partnerCountdownTimer) {
    clearInterval(partnerCountdownTimer);
    partnerCountdownTimer = null;
  }
  if (partnerTarget) {
    window.open(partnerTarget, '_blank', 'noopener');
  }
  closePartnerModal();
}

document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closePartnerModal(); });
document.getElementById('partnerModal')?.addEventListener('click', function(e) { if (e.target === this) closePartnerModal(); });
console.log('[PARTNER] ✅ Partner modal ready');

// === Prevent popup from closing when cursor moves from marker to popup ===
// Annuler le timer de fermeture si la souris entre sur la modale
const mapPopup = document.getElementById('mapPopup');
if (mapPopup) {
  mapPopup.addEventListener('mouseenter', () => {
    if (popupCloseTimer) {
      clearTimeout(popupCloseTimer);
      popupCloseTimer = null;
    }
  });
  
  // Relancer le timer si la souris quitte la modale
  mapPopup.addEventListener('mouseleave', () => {
    if (document.body.classList.contains('view-map-only') && !window.popupLocked) {
      popupCloseTimer = setTimeout(() => {
        mapPopup.classList.remove('show');
        popupCloseTimer = null;
      }, 100);
    }
  });
}
</script>

<!-- Budget Modal -->
<div id="budgetModal" style="position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000;padding:16px;">
  <div style="background:#fff;border-radius:16px;max-width:500px;width:100%;max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
    <div style="padding:20px;border-bottom:1px solid #e5e7eb;">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <h3 style="margin:0;color:#113f7a;font-size:1.2rem;">💰 <span data-i18n="budgetTotal">Budget total</span></h3>
        <button onclick="closeBudgetModal()" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:#64748b;">×</button>
      </div>
      <div id="budgetTotalDisplay" style="font-size:2rem;font-weight:800;color:#166534;margin-top:8px;">0 €</div>
    </div>
    <div style="padding:20px;overflow-y:auto;flex:1;">
      <div id="budgetCategories"></div>
      <div id="budgetItems" style="margin-top:16px;"></div>
    </div>
    <div style="padding:16px;border-top:1px solid #e5e7eb;display:flex;gap:8px;">
      <button onclick="goToAddBooking()" style="flex:1;padding:12px;background:#113f7a;color:#fff;border:none;border-radius:8px;font-weight:600;cursor:pointer;">➕ <span data-i18n="addManualItem">Ajouter une dépense</span></button>
      <button onclick="closeBudgetModal()" style="padding:12px 20px;background:#e5e7eb;color:#113f7a;border:none;border-radius:8px;font-weight:600;cursor:pointer;" data-i18n="close">Fermer</button>
    </div>
  </div>
</div>

<script>
// === BUDGET SYSTEM ===
const BUDGET_CATEGORIES = {
  transport: { icon: '✈️', keys: ['flight', 'car_rental', 'transfer'], label: 'budgetTransport' },
  accommodation: { icon: '🏨', keys: ['hotel'], label: 'budgetAccommodation' },
  activities: { icon: '🎯', keys: ['activity', 'visit', 'show'], label: 'budgetActivities' },
  other: { icon: '📋', keys: ['insurance', 'other'], label: 'budgetOther' }
};

let budgetData = { total: 0, byCategory: {}, items: [] };

async function loadBudgetData() {
  if (!window.ORT_TRIP_DATA) return;
  
  // En mode Dashboard, utiliser le tripId de l'URL (pas celui du catalogue)
  const params = new URLSearchParams(location.search);
  const tripIdFromUrl = params.get('tripId') || params.get('id');
  const tripId = tripIdFromUrl || window.state?.tripId || (window.ORT_TRIPID ? ORT_TRIPID.get() : null);
  
  if (!tripId) {
    console.log('[BUDGET] Pas de tripId trouvé');
    return;
  }
  
  console.log('[BUDGET] Chargement données pour tripId:', tripId);
  await ORT_TRIP_DATA.loadTrip(tripId);
  
  // === INJECTER LES PHOTOS UTILISATEUR DANS state.steps ===
  if (window.state?.steps) {
    window.state.steps.forEach((step, i) => {
      const userPhotos = ORT_TRIP_DATA.getStepPhotos(i) || [];
      if (userPhotos.length > 0) {
        // Priorité aux userPhotos, puis les photos catalogue existantes
        const catalogPhotos = step.images || [];
        const combined = [...userPhotos];
        catalogPhotos.forEach(p => {
          if (p && !combined.includes(p)) combined.push(p);
        });
        step.images = combined;
        console.log(`[PHOTOS] Étape ${i+1}: ${userPhotos.length} photos utilisateur injectées`);
      }
    });
    // Re-render si des photos ont été injectées (pour mettre à jour l'affichage)
    if (window.state.steps.some((s, i) => (ORT_TRIP_DATA.getStepPhotos(i) || []).length > 0)) {
      if (typeof renderRows === 'function') {
        console.log('[PHOTOS] Re-render des étapes avec photos utilisateur');
        renderRows();
      }
    }
  }
  
  const travelBookings = ORT_TRIP_DATA.getTravelBookings() || [];
  const allBookings = [...travelBookings];
  
  // Collect step bookings
  if (window.state?.steps) {
    window.state.steps.forEach((step, i) => {
      const stepBookings = ORT_TRIP_DATA.getStepBookings(i) || [];
      stepBookings.forEach(b => allBookings.push({ ...b, stepName: step.name || `Étape ${i+1}` }));
    });
  }
  
  // Calculate totals
  budgetData = { total: 0, byCategory: { transport: 0, accommodation: 0, activities: 0, other: 0 }, items: [] };
  
  allBookings.forEach(b => {
    const price = b.price ? (typeof b.price === 'object' ? b.price.amount : b.price) : 0;
    const amount = parseFloat(price) || 0;
    if (amount <= 0) return;
    
    budgetData.total += amount;
    budgetData.items.push({ ...b, amount });
    
    // Categorize
    let found = false;
    for (const [cat, def] of Object.entries(BUDGET_CATEGORIES)) {
      if (def.keys.includes(b.category)) {
        budgetData.byCategory[cat] += amount;
        found = true;
        break;
      }
    }
    if (!found) budgetData.byCategory.other += amount;
  });
  
  updateBudgetBadge();
}

function updateBudgetBadge() {
  const badge = document.getElementById('budgetBadge');
  const amount = document.getElementById('budgetAmount');
  if (!badge || !amount) return;
  
  if (budgetData.total > 0) {
    badge.style.display = 'inline-flex';
    amount.textContent = budgetData.total.toFixed(0) + ' €';
    badge.title = t('budgetTooltip');
  } else {
    badge.style.display = 'none';
  }
}

function openBudgetModal() {
  const modal = document.getElementById('budgetModal');
  if (!modal) return;
  
  // Update total
  document.getElementById('budgetTotalDisplay').textContent = budgetData.total.toFixed(2) + ' €';
  
  // Update categories
  const catHtml = Object.entries(BUDGET_CATEGORIES).map(([key, def]) => {
    const val = budgetData.byCategory[key] || 0;
    if (val <= 0) return '';
    const pct = budgetData.total > 0 ? Math.round(val / budgetData.total * 100) : 0;
    return `<div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #f1f5f9;">
      <span>${def.icon} ${t(def.label)}</span>
      <span style="font-weight:600;">${val.toFixed(0)} € <span style="color:#64748b;font-size:0.8rem;">(${pct}%)</span></span>
    </div>`;
  }).join('');
  document.getElementById('budgetCategories').innerHTML = catHtml || `<div style="color:#64748b;text-align:center;padding:20px;">${t('noBudget')}</div>`;
  
  // Update items list
  const itemsHtml = budgetData.items.map(item => {
    const icon = { flight:'✈️', car_rental:'🚗', hotel:'🏨', activity:'🎯', visit:'🏛️', show:'🎭', insurance:'🛡️' }[item.category] || '📋';
    return `<div style="display:flex;align-items:center;gap:10px;padding:10px;background:#f8fafc;border-radius:8px;margin-bottom:6px;">
      <span style="font-size:1.2rem;">${icon}</span>
      <div style="flex:1;">
        <div style="font-weight:600;font-size:0.9rem;color:#113f7a;">${item.name || 'Réservation'}</div>
        <div style="font-size:0.75rem;color:#64748b;">${item.date_start || ''} ${item.stepName ? '• ' + item.stepName : ''}</div>
      </div>
      <div style="font-weight:700;color:#166534;">${item.amount.toFixed(0)} €</div>
    </div>`;
  }).join('');
  document.getElementById('budgetItems').innerHTML = itemsHtml;
  
  modal.style.display = 'flex';
  document.body.style.overflow = 'hidden';
}

function closeBudgetModal() {
  const modal = document.getElementById('budgetModal');
  if (modal) {
    modal.style.display = 'none';
    document.body.style.overflow = '';
  }
}

function goToAddBooking() {
  closeBudgetModal();
  const tripId = window.ORT_TRIPID ? ORT_TRIPID.get() : window.state?.tripId;
  const params = new URLSearchParams(location.search);
  const cc = params.get('cc') || '';
  const itin = params.get('itin') || '';
  
  if (window.ORT_TRIPID) {
    ORT_TRIPID.navigateTo('rt-booking-import.html', { cc, itin });
  } else {
    location.href = `rt-booking-import.html?tripId=${tripId}&cc=${cc}&itin=${itin}`;
  }
}

// Event listeners
document.getElementById('budgetBadge')?.addEventListener('click', openBudgetModal);
document.getElementById('budgetModal')?.addEventListener('click', function(e) { if (e.target === this) closeBudgetModal(); });
document.addEventListener('keydown', function(e) { if (e.key === 'Escape') closeBudgetModal(); });

// Load budget after page init
// Load budget appelé manuellement après init complète du mode Dashboard
// setTimeout(loadBudgetData, 2000); // DÉSACTIVÉ - appelé depuis initDashboardMode
window.addEventListener('ort:trip-data-saved', loadBudgetData);

console.log('[BUDGET] ✅ Budget system ready');
</script>


<script src="ort-ratings.js"></script>
<script src="ort-map-resize-fix.js"></script>
<script src="/js/ort-pdf-export-v6.js"></script>
<script src="/js/ort-calendar-export.js"></script>
<script src="/js/ort-share.js"></script>
<script src="/js/ort-footer.js"></script>
</body>
</html>